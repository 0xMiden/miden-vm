# Given [b, c, a, carry] on stack top, following function computes
#
#  tmp = a + (b * c) + carry
#  hi = tmp >> 32
#  lo = tmp & 0xffff_ffff
#  return (hi, lo)
#
# At end of execution of this function, stack top should look like [hi, lo]
# See https://github.com/itzmeanjan/secp256k1/blob/ec3652afe8ed72b29b0e39273a876a898316fb9a/utils.py#L75-L80
proc.mac
  u32overflowing_madd

  movdn.2
  u32overflowing_add

  movup.2
  add
end

# Given [a, b, borrow] on stack top, following function computes
#
#  tmp = a - (b + borrow)
#  hi = tmp >> 32
#  lo = tmp & 0xffff_ffff
#  return (hi, lo)
#
# At end of execution of this function, stack top should look like [hi, lo]
# See https://github.com/itzmeanjan/secp256k1/blob/ec3652afe8ed72b29b0e39273a876a898316fb9a/utils.py#L83-L89
proc.sbb
  movdn.2
  add
  u32overflowing_sub
end

# Given a secp256k1 field element in radix-2^32 representation and 32 -bit unsigned integer,
# this routine computes a 288 -bit number.
#
# Input via stack is expected in this form
#
# [a0, a1, a2, a3, a4, a5, a6, a7, b] | a[0..8] -> 256 -bit number, b = 32 -bit number
#
# Computed output looks like below, on stack
#
# [carry, b7, b6, b5, b4, b3, b2, b1, b0]
proc.u256xu32
  movup.8
  
  push.0
  dup.1
  movup.3
  u32overflowing_madd
  
  dup.2
  movup.4
  u32overflowing_madd

  dup.3
  movup.5
  u32overflowing_madd

  dup.4
  movup.6
  u32overflowing_madd

  dup.5
  movup.7
  u32overflowing_madd

  dup.6
  movup.8
  u32overflowing_madd

  dup.7
  movup.9
  u32overflowing_madd

  movup.8
  movup.9
  u32overflowing_madd
end

# Given a 288 -bit number and 256 -bit number on stack ( in order ), this routine
# computes a 288 -bit number
#
# Expected stack state during routine invocation
#
# [carry, b7, b6, b5, b4, b3, b2, b1, b0, c0, c1, c2, c3, c4, c5, c6, c7]
#
# While after execution of this routine, stack should look like
#
# [d0, d1, d2, d3, d4, d5, d6, d7, carry]
proc.u288_add_u256
  swapw
  movupw.2

  u32overflowing_add

  movup.2
  movup.7
  u32overflowing_add3

  movup.3
  movup.6
  u32overflowing_add3

  movup.4
  movup.5
  movupw.2

  movup.2
  movup.4
  movup.6
  u32overflowing_add3

  movup.5
  movup.5
  u32overflowing_add3

  movup.3
  movup.4
  movupw.2

  movup.2
  movup.4
  movup.6
  u32overflowing_add3

  movup.5
  movup.5
  u32overflowing_add3

  movup.10
  movup.5
  u32overflowing_add3

  movup.4
  add

  swap
  movup.2
  movup.3
  movup.4
  movup.5
  movup.6
  movup.7
  movup.8
end

# Given [c0, c1, c2, c3, c4, c5, c6, c7, c8, pc] on stack top,
# this function attempts to reduce 288 -bit number to 256 -bit number
# along with carry, using montgomery reduction method
#
# In stack top content c[0..9] i.e. first 9 elements, holding 288 -bit
# number. Stack element `pc` ( at stack[9] ) is previous reduction round's
# carry ( for first reduction round, it'll be set to 0 ).
#
# After finishing execution of this function, stack top should look like
#
# [c0, c1, c2, c3, c4, c5, c6, c7, pc] | pc = next round's carry
proc.u288_reduce
  dup
  push.3525653809
  u32wrapping_mul 
  # q at stack top #

  push.0
  movup.2
  push.4294966319
  dup.3
  exec.mac

  swap
  drop

  movup.2
  push.4294967294
  dup.3
  exec.mac

  movup.3
  push.4294967295
  dup.4
  exec.mac

  movup.4
  push.4294967295
  dup.5
  exec.mac

  movup.5
  push.4294967295
  dup.6
  exec.mac

  movup.6
  push.4294967295
  dup.7
  exec.mac

  movup.7
  dup.7
  push.4294967295
  exec.mac

  movup.7
  movup.8
  swap
  push.4294967295
  exec.mac

  movup.9
  movup.9
  u32overflowing_add3

  swap
  movup.2
  movup.3
  movup.4
  movup.5
  movup.6
  movup.7
  movup.8
end

# Given two 256 -bit numbers on stack, where each number is represented in
# radix-2^32 form ( i.e. each number having eight 32 -bit limbs ), following function
# computes modular multiplication of those two operands, computing 256 -bit result.
#
# Stack expected as below, holding input
#
# [a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7] | a[0..8], b[0..8] are 256 -bit numbers
#
# After finishing execution of this function, stack should look like
#
# [c0, c1, c2, c3, c4, c5, c6, c7] | c[0..8] is a 256 -bit number
#
# Note, for computing modular multiplication of a[0..8] & b[0..8],
# school book multiplication equipped with montgomery reduction technique
# is used, which is why a[0..8], b[0..8] are expected to be in montgomery form,
# while computed c[0..8] will also be in montgomery form.
export.u256_mod_mul.2
  loc_storew.0
  swapw
  loc_storew.1
  swapw

  exec.u256xu32

  swap
  movup.2
  movup.3
  movup.4
  movup.5
  movup.6
  movup.7
  movup.8

  push.0
  movdn.9

  exec.u288_reduce

  movup.9
  push.0.0.0.0
  loc_loadw.1
  push.0.0.0.0
  loc_loadw.0

  exec.u256xu32
  exec.u288_add_u256
  exec.u288_reduce

  movup.9
  push.0.0.0.0
  loc_loadw.1
  push.0.0.0.0
  loc_loadw.0

  exec.u256xu32
  exec.u288_add_u256
  exec.u288_reduce

  movup.9
  push.0.0.0.0
  loc_loadw.1
  push.0.0.0.0
  loc_loadw.0

  exec.u256xu32
  exec.u288_add_u256
  exec.u288_reduce

  movup.9
  push.0.0.0.0
  loc_loadw.1
  push.0.0.0.0
  loc_loadw.0

  exec.u256xu32
  exec.u288_add_u256
  exec.u288_reduce

  movup.9
  push.0.0.0.0
  loc_loadw.1
  push.0.0.0.0
  loc_loadw.0

  exec.u256xu32
  exec.u288_add_u256
  exec.u288_reduce

  movup.9
  push.0.0.0.0
  loc_loadw.1
  push.0.0.0.0
  loc_loadw.0

  exec.u256xu32
  exec.u288_add_u256
  exec.u288_reduce

  movup.9
  push.0.0.0.0
  loc_loadw.1
  push.0.0.0.0
  loc_loadw.0

  exec.u256xu32
  exec.u288_add_u256
  exec.u288_reduce

  movup.8
  movup.2
  dup.1
  add

  movup.2
  movup.2
  push.977

  u32overflowing_madd
  drop
end

# Given two 256 -bit numbers on stack, where each number is represented in
# radix-2^32 form ( i.e. each number having eight 32 -bit limbs ), following function
# computes modular addition of those two operands, in secp256k1 prime field.
#
# Stack expected as below, holding input
#
# [a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7] | a[0..8], b[0..8] are 256 -bit numbers
#
# After finishing execution of this function, stack should look like
#
# [c0, c1, c2, c3, c4, c5, c6, c7] | c[0..8] is a 256 -bit number
#
# This implementation takes inspiration from https://gist.github.com/itzmeanjan/d4853347dfdfa853993f5ea059824de6#file-test_montgomery_arithmetic-py-L236-L256
export.u256_mod_add
  movupw.2

  push.0
  movup.5
  u32overflowing_add3

  movup.2
  movup.5
  u32overflowing_add3

  movup.3
  movup.5
  u32overflowing_add3

  movup.4
  movup.5
  u32overflowing_add3

  movup.5
  movup.9
  u32overflowing_add3

  movup.6
  movup.9
  u32overflowing_add3

  movup.7
  movup.9
  u32overflowing_add3

  movup.8
  movup.9
  u32overflowing_add3

  movup.8
  dup.1
  push.977
  u32overflowing_madd
  drop

  swap
  movup.8
  add

  movup.2
  movup.3
  movup.4
  movup.5
  movup.6
  movup.7
  movup.6
  movup.7
end

# Given a secp256k1 field element ( say `a` ) on stack, represented in Montgomery form 
# ( i.e. number having eight 32 -bit limbs ), following function negates it to
# field element `a'` | a' + a = 0
#
# Stack expected as below, holding input
#
# [a0, a1, a2, a3, a4, a5, a6, a7] | a[0..8] is a secp256k1 field element
#
# After finishing execution of this function, stack should look like
#
# [c0, c1, c2, c3, c4, c5, c6, c7] | c[0..8] is a secp256k1 field element
#
# See https://github.com/itzmeanjan/secp256k1/blob/ec3652afe8ed72b29b0e39273a876a898316fb9a/field.py#L77-L95
export.u256_mod_neg
  push.0
  swap
  push.4294966319
  exec.sbb

  movup.2
  push.4294967294
  exec.sbb

  movup.3
  push.4294967295
  exec.sbb

  movup.4
  push.4294967295
  exec.sbb

  movup.5
  push.4294967295
  exec.sbb

  movup.6
  push.4294967295
  exec.sbb

  movup.7
  push.4294967295
  exec.sbb

  movup.8
  push.4294967295
  exec.sbb

  drop
  
  swap
  movup.2
  movup.3
  movup.4
  movup.5
  movup.6
  movup.7
end

# Given two secp256k1 field elements, say a, b, ( represented in Montgomery form, each number having 
# eight 32 -bit limbs ) on stack, following function computes modular subtraction of those 
# two operands c = a + (-b) = a - b
#
# Stack expected as below, holding input
#
# [a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7] | a[0..8], b[0..8] are secp256k1 field elements
#
# After finishing execution of this function, stack should look like
#
# [c0, c1, c2, c3, c4, c5, c6, c7] | c[0..8] is a secp256k1 field element
#
# See https://github.com/itzmeanjan/secp256k1/blob/ec3652afe8ed72b29b0e39273a876a898316fb9a/field.py#L97-L101
export.u256_mod_sub
  movupw.3
  movupw.3

  exec.u256_mod_neg
  exec.u256_mod_add
end

# Given a 256 -bit number on stack, represented in radix-2^32 
# form i.e. eight 32 -bit limbs, this routine computes Montgomery
# representation of provided radix-2^32 number.
#
# - u256 radix-2^32 form input expected on stack as
#
#  [a0, a1, a2, a3, a4, a5, a6, a7]
#
# - u256 montgomery form output on stack
#
# [a0`, a1`, a2`, a3`, a4`, a5`, a6`, a7`]
#
# See section 2.2 of https://eprint.iacr.org/2017/1057.pdf
export.to_mont
  push.0.0.0.0
  push.0.1.1954.954529 # pushed R2's radix-2^32 form;
                       # see https://gist.github.com/itzmeanjan/d4853347dfdfa853993f5ea059824de6

  exec.u256_mod_mul
end

# Given a 256 -bit number on stack, represented in Montgomery 
# form i.e. eight 32 -bit limbs, this routine computes radix-2^32
# representation of provided u256 number.
#
# - u256 montgomery form input on stack expected
#
#  [a0, a1, a2, a3, a4, a5, a6, a7]
#
# - u256 radix-2^32 form output on stack as
#
# [a0`, a1`, a2`, a3`, a4`, a5`, a6`, a7`]
#
# See section 2.2 of https://eprint.iacr.org/2017/1057.pdf
export.from_mont
  push.0.0.0.0
  push.0.0.0.1 # pushed 1's radix-2^32 form;
               # see https://gist.github.com/itzmeanjan/d4853347dfdfa853993f5ea059824de6

  exec.u256_mod_mul
end

# Given a secp256k1 point in projective coordinate system ( i.e. with x, y, z -coordinates
# as secp256k1 prime field elements, represented in Montgomery form ), this routine adds 
# that point with self i.e. does point doubling on elliptic curve, using exception-free 
# doubling formula from algorithm 9 of https://eprint.iacr.org/2015/1060.pdf, while 
# following prototype implementation https://github.com/itzmeanjan/secp256k1/blob/ec3652a/point.py#L131-L165
# 
# Input:
#
# 12 memory addresses on stack such that first 6 memory addresses are for input point &
# last 6 are for storing resulting point.
#
# First 6 addresses hold input elliptic curve point's x, y, z -coordinates, where each coordinate
# is represented in Montgomery form, as eight 32 -bit limbs.
#
# Similarly, last 6 addresses hold resulting (doubled) point's x, y, z -coordinates, where each
# coordinate is represented in Montgomery form, as eight 32 -bit limbs. Note, this is where
# output will be written, so called is expected to read doubled point from last 6 memory addresses.
#
# Expected stack during invocation of this routine:
#
#   [x_addr[0..4], x_addr[4..8], y_addr[0..4], y_addr[4..8], z_addr[0..4], z_addr[4..8], 
#     x3_addr[0..4], x3_addr[4..8], y3_addr[0..4], y3_addr[4..8], z3_addr[0..4], z3_addr[4..8]]
#
# Note, (X, Y, Z)    => input point
#       (X3, Y3, Z3) => output point
#
# Output:
#
# Last 6 memory addresses of 12 memory addresses which were provided during invocation, where resulting doubled
# point is kept in similar form. For seeing X3, Y3, Z3 -coordinates of doubled point, one needs to read from
# those 6 memory addresses.
#
# Stack at end of execution of routine looks like
#
#   [x3_addr[0..4], x3_addr[4..8], y3_addr[0..4], y3_addr[4..8], z3_addr[0..4], z3_addr[4..8]]
export.point_doubling.12
  dup.3
  push.0.0.0.0
  movup.4
  mem_loadw
  dup.6
  push.0.0.0.0
  movup.4
  mem_loadw         # y -coordinate on stack top

  dupw.1
  dupw.1            # repeated y -coordinate

  exec.u256_mod_mul # = t0

  loc_storew.0
  swapw
  loc_storew.1
  swapw             # cache t0

  dupw.1
  dupw.1            # repeated t0

  exec.u256_mod_add # = z3

  dupw.1
  dupw.1            # repeated z3

  exec.u256_mod_add # = z3

  dupw.1
  dupw.1            # repeated z3

  exec.u256_mod_add # = z3

  loc_storew.2
  dropw       
  loc_storew.3
  dropw             # cache z3

  dup.5
  push.0.0.0.0
  movup.4
  mem_loadw
  dup.8
  push.0.0.0.0
  movup.4
  mem_loadw         # z -coordinate on stack top

  dup.11
  push.0.0.0.0
  movup.4
  mem_loadw
  dup.14
  push.0.0.0.0
  movup.4
  mem_loadw         # y -coordinate on stack top

  exec.u256_mod_mul # = t1

  loc_storew.4
  dropw       
  loc_storew.5
  dropw             # cache t1

  dup.5
  push.0.0.0.0
  movup.4
  mem_loadw
  dup.8
  push.0.0.0.0
  movup.4
  mem_loadw         # z -coordinate on stack top

  dupw.1
  dupw.1            # repeated z

  exec.u256_mod_mul # = t2

  push.0.0.0.0
  push.0.0.21.20517 # = b3

  exec.u256_mod_mul # = t2

  loc_storew.6
  swapw
  loc_storew.7    # cache t2
  swapw

  push.0.0.0.0
  loc_loadw.3
  push.0.0.0.0
  loc_loadw.2     # = z3

  exec.u256_mod_mul # = x3

  loc_storew.8
  dropw       
  loc_storew.9
  dropw             # cache x3

  push.0.0.0.0
  loc_loadw.7
  push.0.0.0.0
  loc_loadw.6     # = t2

  push.0.0.0.0
  loc_loadw.1
  push.0.0.0.0
  loc_loadw.0     # = t0

  exec.u256_mod_add # = y3

  loc_storew.10
  dropw       
  loc_storew.11
  dropw           # cache y3

  push.0.0.0.0
  loc_loadw.5
  push.0.0.0.0
  loc_loadw.4     # = t1

  push.0.0.0.0
  loc_loadw.3
  push.0.0.0.0
  loc_loadw.2     # = z3

  exec.u256_mod_mul # = z3

  loc_storew.2
  dropw       
  loc_storew.3
  dropw             # cache z3

  push.0.0.0.0
  loc_loadw.7
  push.0.0.0.0
  loc_loadw.6     # = t2

  dupw.1
  dupw.1            # repeated t2

  exec.u256_mod_add # = t1

  push.0.0.0.0
  loc_loadw.7
  push.0.0.0.0
  loc_loadw.6     # = t2

  exec.u256_mod_add # = t2

  push.0.0.0.0
  loc_loadw.1
  push.0.0.0.0
  loc_loadw.0     # = t0

  exec.u256_mod_sub # = t0

  loc_storew.0
  swapw
  loc_storew.1
  swapw             # cache t0

  push.0.0.0.0
  loc_loadw.11
  push.0.0.0.0
  loc_loadw.10    # = y3

  exec.u256_mod_mul # = y3

  push.0.0.0.0
  loc_loadw.9
  push.0.0.0.0
  loc_loadw.8     # = x3

  exec.u256_mod_add # = y3

  loc_storew.10
  dropw       
  loc_storew.11
  dropw            # cache y3

  dup.3
  push.0.0.0.0
  movup.4
  mem_loadw
  dup.6
  push.0.0.0.0
  movup.4
  mem_loadw         # y -coordinate on stack top

  dup.9
  push.0.0.0.0
  movup.4
  mem_loadw
  dup.12
  push.0.0.0.0
  movup.4
  mem_loadw         # x -coordinate on stack top

  exec.u256_mod_mul # = t1

  push.0.0.0.0
  loc_loadw.1
  push.0.0.0.0
  loc_loadw.0     # = t0

  exec.u256_mod_mul # = x3

  dupw.1
  dupw.1            # repeated x3

  exec.u256_mod_add # = x3

  loc_storew.8
  dropw       
  loc_storew.9
  dropw             # cache x3

  dropw
  drop
  drop

  dup
  push.0.0.0.0
  loc_loadw.8
  movup.4
  mem_storew
  dropw              # write x3[0..4] to memory

  dup.1
  push.0.0.0.0
  loc_loadw.9
  movup.4
  mem_storew
  dropw              # write x3[4..8] to memory

  dup.2
  push.0.0.0.0
  loc_loadw.10
  movup.4
  mem_storew
  dropw              # write y3[0..4] to memory

  dup.3
  push.0.0.0.0
  loc_loadw.11
  movup.4
  mem_storew
  dropw              # write y3[4..8] to memory

  dup.4
  push.0.0.0.0
  loc_loadw.2
  movup.4
  mem_storew
  dropw              # write z3[0..4] to memory

  dup.5
  push.0.0.0.0
  loc_loadw.3
  movup.4
  mem_storew
  dropw              # write z3[4..8] to memory
end

# Given two secp256k1 points in projective coordinate system ( i.e. with x, y, z -coordinates
# as secp256k1 prime field elements, represented in Montgomery form, each coordinate using eight 32 -bit limbs ),
# this routine adds those two points on elliptic curve, using exception-free addition formula from
# algorithm 7 of https://eprint.iacr.org/2015/1060.pdf, while following prototype
# implementation https://github.com/itzmeanjan/secp256k1/blob/ec3652a/point.py#L60-L115
# 
# Input:
#
# 18 memory addresses on stack such that first 6 memory addresses are for first input point, next 6
# memory addresses holding x, y, z -coordinates of second input point & last 6 addresses are for storing 
# resulting point ( addition of two input points ).
#
# Expected stack during invocation of this routine:
#
#   [x1_addr[0..4], x1_addr[4..8], y1_addr[0..4], y1_addr[4..8], z1_addr[0..4], z1_addr[4..8], 
#     x2_addr[0..4], x2_addr[4..8], y2_addr[0..4], y2_addr[4..8], z2_addr[0..4], z2_addr[4..8],
#       x3_addr[0..4], x3_addr[4..8], y3_addr[0..4], y3_addr[4..8], z3_addr[0..4], z3_addr[4..8]]
#
# Note, (X1, Y1, Z1)    => input point 1
#       (X2, Y2, Z2)    => input point 2
#       (X3, Y3, Z3)    => output point
#
# Output:
#
# Last 6 memory addresses of 18 input memory addresses which were provided during invocation, where resulting elliptic curve
# point is kept in similar form. For seeing X3, Y3, Z3 -coordinates of doubled point, one needs to read from
# those 6 memory addresses.
#
# Stack at end of execution of routine looks like
#
#   [x3_addr[0..4], x3_addr[4..8], y3_addr[0..4], y3_addr[4..8], z3_addr[0..4], z3_addr[4..8]]
export.point_addition.16
  dup.6
  dup.8

  push.0.0.0.0
  movup.4
  mem_loadw
  movup.4
  push.0.0.0.0
  movup.4
  mem_loadw # x2 on stack top

  dup.8
  dup.10

  push.0.0.0.0
  movup.4
  mem_loadw
  movup.4
  push.0.0.0.0
  movup.4
  mem_loadw # x1 on stack top

  exec.u256_mod_mul # = t0

  loc_storew.0
  dropw       
  loc_storew.1
  dropw        # cache t0

  dup.8
  dup.10

  push.0.0.0.0
  movup.4
  mem_loadw
  movup.4
  push.0.0.0.0
  movup.4
  mem_loadw # y2 on stack top

  dup.10
  dup.12

  push.0.0.0.0
  movup.4
  mem_loadw
  movup.4
  push.0.0.0.0
  movup.4
  mem_loadw # y1 on stack top

  exec.u256_mod_mul # = t1

  loc_storew.2
  dropw       
  loc_storew.3
  dropw        # cache t1

  dup.10
  dup.12

  push.0.0.0.0
  movup.4
  mem_loadw
  movup.4
  push.0.0.0.0
  movup.4
  mem_loadw # z2 on stack top

  dup.12
  dup.14

  push.0.0.0.0
  movup.4
  mem_loadw
  movup.4
  push.0.0.0.0
  movup.4
  mem_loadw # z1 on stack top

  exec.u256_mod_mul # = t2

  loc_storew.4
  dropw       
  loc_storew.5
  dropw        # cache t2

  dup.2
  dup.4

  push.0.0.0.0
  movup.4
  mem_loadw
  movup.4
  push.0.0.0.0
  movup.4
  mem_loadw # y1 on stack top

  dup.8
  dup.10

  push.0.0.0.0
  movup.4
  mem_loadw
  movup.4
  push.0.0.0.0
  movup.4
  mem_loadw # x1 on stack top

  exec.u256_mod_add # = t3

  loc_storew.6
  dropw       
  loc_storew.7
  dropw        # cache t3

  dup.8
  dup.10

  push.0.0.0.0
  movup.4
  mem_loadw
  movup.4
  push.0.0.0.0
  movup.4
  mem_loadw # y2 on stack top

  dup.15
  dup.15
  swap

  push.0.0.0.0
  movup.4
  mem_loadw
  movup.4
  push.0.0.0.0
  movup.4
  mem_loadw # x2 on stack top
  
  exec.u256_mod_add # = t4

  push.0.0.0.0
  loc_loadw.7
  push.0.0.0.0
  loc_loadw.6 # t3 loaded back

  exec.u256_mod_mul # = t3

  loc_storew.6
  dropw       
  loc_storew.7
  dropw        # cache t3

  push.0.0.0.0
  loc_loadw.3
  push.0.0.0.0
  loc_loadw.2 # t1 loaded back

  push.0.0.0.0
  loc_loadw.1
  push.0.0.0.0
  loc_loadw.0 # t0 loaded back

  exec.u256_mod_add # = t4

  push.0.0.0.0
  loc_loadw.7
  push.0.0.0.0
  loc_loadw.6 # t3 loaded back

  exec.u256_mod_sub # = t3

  loc_storew.6
  dropw       
  loc_storew.7
  dropw        # cache t3

  dup.2
  dup.4

  push.0.0.0.0
  movup.4
  mem_loadw
  movup.4
  push.0.0.0.0
  movup.4
  mem_loadw # y1 on stack top

  dup.12
  dup.14

  push.0.0.0.0
  movup.4
  mem_loadw
  movup.4
  push.0.0.0.0
  movup.4
  mem_loadw # z1 on stack top

  exec.u256_mod_add # = t4

  loc_storew.8
  dropw       
  loc_storew.9
  dropw        # cache t4

  dup.11
  dup.11

  dup.10
  dup.12

  push.0.0.0.0
  movup.4
  mem_loadw
  movup.4
  push.0.0.0.0
  movup.4
  mem_loadw # y2 on stack top

  movup.8
  movup.9

  push.0.0.0.0
  movup.4
  mem_loadw
  movup.4
  push.0.0.0.0
  movup.4
  mem_loadw # z2 on stack top

  exec.u256_mod_add # = x3

  push.0.0.0.0
  loc_loadw.9
  push.0.0.0.0
  loc_loadw.8 # t4 loaded back

  exec.u256_mod_mul # = t4

  loc_storew.8
  dropw       
  loc_storew.9
  dropw        # cache t4

  push.0.0.0.0
  loc_loadw.5
  push.0.0.0.0
  loc_loadw.4 # t2 loaded back

  push.0.0.0.0
  loc_loadw.3
  push.0.0.0.0
  loc_loadw.2 # t1 loaded back

  exec.u256_mod_add # = x3

  push.0.0.0.0
  loc_loadw.9
  push.0.0.0.0
  loc_loadw.8 # t4 loaded back

  exec.u256_mod_sub # = t4

  loc_storew.8
  dropw       
  loc_storew.9
  dropw        # cache t4

  dup.4
  dup.6

  push.0.0.0.0
  movup.4
  mem_loadw
  movup.4
  push.0.0.0.0
  movup.4
  mem_loadw # z1 on stack top

  dup.8
  dup.10

  push.0.0.0.0
  movup.4
  mem_loadw
  movup.4
  push.0.0.0.0
  movup.4
  mem_loadw # x1 on stack top

  exec.u256_mod_add # = x3

  loc_storew.10
  dropw       
  loc_storew.11
  dropw       # cache x3

  dup.10
  dup.12

  push.0.0.0.0
  movup.4
  mem_loadw
  movup.4
  push.0.0.0.0
  movup.4
  mem_loadw # z2 on stack top

  dup.15
  dup.15
  swap

  push.0.0.0.0
  movup.4
  mem_loadw
  movup.4
  push.0.0.0.0
  movup.4
  mem_loadw # x2 on stack top

  exec.u256_mod_add # = y3

  push.0.0.0.0
  loc_loadw.11
  push.0.0.0.0
  loc_loadw.10 # x3 loaded back

  exec.u256_mod_mul # = x3

  loc_storew.10
  dropw       
  loc_storew.11
  dropw       # cache x3

  push.0.0.0.0
  loc_loadw.5
  push.0.0.0.0
  loc_loadw.4 # t2 loaded back

  push.0.0.0.0
  loc_loadw.1
  push.0.0.0.0
  loc_loadw.0 # t0 loaded back

  exec.u256_mod_add # = y3

  push.0.0.0.0
  loc_loadw.11
  push.0.0.0.0
  loc_loadw.10 # x3 loaded back

  exec.u256_mod_sub # = y3

  loc_storew.12
  dropw       
  loc_storew.13
  dropw       # cache y3

  push.0.0.0.0
  loc_loadw.1
  push.0.0.0.0
  loc_loadw.0 # t0 loaded back

  dupw.1
  dupw.1

  exec.u256_mod_add # = x3

  loc_storew.10
  swapw
  loc_storew.11
  swapw # cache x3

  push.0.0.0.0
  loc_loadw.1
  push.0.0.0.0
  loc_loadw.0 # t0 loaded back

  exec.u256_mod_add # = t0

  loc_storew.0
  dropw       
  loc_storew.1
  dropw        # cache t0

  push.0.0.0.0
  push.0.0.21.20517 # b3 on stack top

  push.0.0.0.0
  loc_loadw.5
  push.0.0.0.0
  loc_loadw.4 # t2 loaded back

  exec.u256_mod_mul # = t2

  loc_storew.4
  swapw
  loc_storew.5
  swapw # cache t2

  push.0.0.0.0
  loc_loadw.3
  push.0.0.0.0
  loc_loadw.2 # t1 loaded back

  exec.u256_mod_add # = z3

  loc_storew.14
  dropw       
  loc_storew.15
  dropw       # cache z3

  push.0.0.0.0
  loc_loadw.5
  push.0.0.0.0
  loc_loadw.4 # t2 loaded back

  push.0.0.0.0
  loc_loadw.3
  push.0.0.0.0
  loc_loadw.2 # t1 loaded back

  exec.u256_mod_sub # = t1

  loc_storew.2
  dropw       
  loc_storew.3
  dropw        # cache t1

  push.0.0.0.0
  push.0.0.21.20517 # b3 on stack top

  push.0.0.0.0
  loc_loadw.13
  push.0.0.0.0
  loc_loadw.12 # y3 loaded back

  exec.u256_mod_mul # = y3

  loc_storew.12
  swapw
  loc_storew.13
  swapw # cache y3

  push.0.0.0.0
  loc_loadw.9
  push.0.0.0.0
  loc_loadw.8 # t4 loaded back

  exec.u256_mod_mul # = x3

  loc_storew.10
  dropw       
  loc_storew.11
  dropw       # cache x3

  push.0.0.0.0
  loc_loadw.3
  push.0.0.0.0
  loc_loadw.2 # t1 loaded back

  push.0.0.0.0
  loc_loadw.7
  push.0.0.0.0
  loc_loadw.6 # t3 loaded back

  exec.u256_mod_mul # = t2

  push.0.0.0.0
  loc_loadw.11
  push.0.0.0.0
  loc_loadw.10 # x3 loaded back

  exec.u256_mod_neg
  exec.u256_mod_add # = x3

  loc_storew.10
  dropw       
  loc_storew.11
  dropw       # cache x3

  push.0.0.0.0
  loc_loadw.1
  push.0.0.0.0
  loc_loadw.0 # t0 loaded back

  push.0.0.0.0
  loc_loadw.13
  push.0.0.0.0
  loc_loadw.12 # y3 loaded back

  exec.u256_mod_mul # = y3

  loc_storew.12
  dropw       
  loc_storew.13
  dropw       # cache y3

  push.0.0.0.0
  loc_loadw.15
  push.0.0.0.0
  loc_loadw.14 # z3 loaded back

  push.0.0.0.0
  loc_loadw.3
  push.0.0.0.0
  loc_loadw.2 # t1 loaded back

  exec.u256_mod_mul # = t1

  push.0.0.0.0
  loc_loadw.13
  push.0.0.0.0
  loc_loadw.12 # y3 loaded back

  exec.u256_mod_add # = y3

  loc_storew.12
  dropw       
  loc_storew.13
  dropw       # cache y3

  push.0.0.0.0
  loc_loadw.7
  push.0.0.0.0
  loc_loadw.6 # t3 loaded back

  push.0.0.0.0
  loc_loadw.1
  push.0.0.0.0
  loc_loadw.0 # t0 loaded back

  exec.u256_mod_mul # = t0

  loc_storew.0
  dropw       
  loc_storew.1
  dropw        # cache t0

  push.0.0.0.0
  loc_loadw.9
  push.0.0.0.0
  loc_loadw.8 # t4 loaded back

  push.0.0.0.0
  loc_loadw.15
  push.0.0.0.0
  loc_loadw.14 # z3 loaded back

  exec.u256_mod_mul # = z3

  push.0.0.0.0
  loc_loadw.1
  push.0.0.0.0
  loc_loadw.0 # t0 loaded back

  exec.u256_mod_add # = z3

  loc_storew.14
  dropw       
  loc_storew.15
  dropw       # cache z3

  dropw
  dropw
  dropw

  push.0.0.0.0
  loc_loadw.10
  dup.4
  mem_storew
  dropw              # write x3[0..4] to memory

  push.0.0.0.0
  loc_loadw.11
  dup.5
  mem_storew
  dropw              # write x3[4..8] to memory

  push.0.0.0.0
  loc_loadw.12
  dup.6
  mem_storew
  dropw              # write y3[0..4] to memory

  push.0.0.0.0
  loc_loadw.13
  dup.7
  mem_storew
  dropw              # write y3[4..8] to memory

  push.0.0.0.0
  loc_loadw.14
  dup.8
  mem_storew
  dropw              # write z3[0..4] to memory

  push.0.0.0.0
  loc_loadw.15
  dup.9
  mem_storew
  dropw              # write z3[4..8] to memory
end

# Given an elliptic curve point in projective coordinate system ( total 24 field elements 
# required for representing x, y, z coordinate values s.t. they are provided by 6 distinct 
# memory addresses ) and a 256 -bit scalar, in radix-2^32 representation ( such that it 
# takes 8 stack elements to represent whole scalar, where each limb is of 32 -bit width ), 
# this routine multiplies elliptic curve point by given scalar, producing another point 
# on secp256k1 curve, which will also be presented in projective coordinate system.
#
# Input:
#
# During invocation, this routine expects stack in following form
#
# [X_addr_0, X_addr_1, Y_addr_0, Y_addr_1, Z_addr_0, Z_addr_1, Sc0, Sc1, Sc2, Sc3, Sc4, Sc5, Sc6, Sc7, X'_addr_0, X'_addr_1, Y'_addr_0, Y'_addr_1, Z'_addr_0, Z'_addr_1, ...]
#
# X_addr_0, X_addr_1 -> Input secp256k1 point's X -coordinate to be placed, in Montgomery form, in given addresses
# Y_addr_0, Y_addr_1 -> Input secp256k1 point's Y -coordinate to be placed, in Montgomery form, in given addresses
# Z_addr_1, Z_addr_1 -> Input secp256k1 point's Z -coordinate to be placed, in Montgomery form, in given addresses
# Sc{0..8}           -> 256 -bit scalar in radix-2^32 form | Sc0 is least significant limb & Sc7 is most significant limb
# X'_addr_0, X'_addr_1 -> Resulting secp256k1 point's X -coordinate to be placed, in Montgomery form, in given addresses
# Y'_addr_0, Y'_addr_1 -> Resulting secp256k1 point's Y -coordinate to be placed, in Montgomery form, in given addresses
# Z'_addr_1, Z'_addr_1 -> Resulting secp256k1 point's Z -coordinate to be placed, in Montgomery form, in given addresses
#
# Output:
#
# At end of execution of this routine, stack should look like below
#
# [X_addr_0, X_addr_1, Y_addr_0, Y_addr_1, Z_addr_0, Z_addr_1, ...]
#
# X_addr_0, X_addr_1 -> Resulting secp256k1 point's X -coordinate written, in Montgomery form, in given addresses
# Y_addr_0, Y_addr_1 -> Resulting secp256k1 point's Y -coordinate written, in Montgomery form, in given addresses
# Z_addr_0, Z_addr_1 -> Resulting secp256k1 point's Z -coordinate written, in Montgomery form, in given addresses
#
# One interested in resulting point, should read from provided addresses on stack.
# 
# This routine implements double-and-add algorithm, while following 
# https://github.com/itzmeanjan/secp256k1/blob/d23ea7d/point.py#L174-L186 
export.point_mul.18
  # initialize `base`
  push.0.0.0.0

  movup.4
  mem_loadw
  loc_storew.0

  movup.4
  mem_loadw
  loc_storew.1

  movup.4
  mem_loadw
  loc_storew.2

  movup.4
  mem_loadw
  loc_storew.3

  movup.4
  mem_loadw
  loc_storew.4

  movup.4
  mem_loadw
  loc_storew.5

  dropw

  # initialize `res` ( with group identity )
  # See https://github.com/itzmeanjan/secp256k1/blob/d23ea7d/point.py#L40-L45
  push.0.0.0.0
  loc_storew.6
  loc_storew.7
  dropw

  push.0.0.1.977
  loc_storew.8
  dropw
  push.0.0.0.0
  loc_storew.9

  loc_storew.10
  loc_storew.11

  dropw

  repeat.8
    repeat.32
      dup
      push.1
      u32checked_and

      if.true
        # res = base + res
        locaddr.17
        locaddr.16
        locaddr.15
        locaddr.14
        locaddr.13
        locaddr.12

        # res
        locaddr.11
        locaddr.10
        locaddr.9
        locaddr.8
        locaddr.7
        locaddr.6

        # base
        locaddr.5
        locaddr.4
        locaddr.3
        locaddr.2
        locaddr.1
        locaddr.0

        exec.point_addition

        # write res back
        push.0.0.0.0

        movup.4
        mem_loadw
        loc_storew.6

        movup.4
        mem_loadw
        loc_storew.7

        movup.4
        mem_loadw
        loc_storew.8

        movup.4
        mem_loadw
        loc_storew.9

        movup.4
        mem_loadw
        loc_storew.10

        movup.4
        mem_loadw
        loc_storew.11

        dropw
      end

      # base = base + base
      locaddr.17
      locaddr.16
      locaddr.15
      locaddr.14
      locaddr.13
      locaddr.12

      # base
      locaddr.5
      locaddr.4
      locaddr.3
      locaddr.2
      locaddr.1
      locaddr.0

      exec.point_doubling

      # write base back
      push.0.0.0.0

      movup.4
      mem_loadw
      loc_storew.0

      movup.4
      mem_loadw
      loc_storew.1

      movup.4
      mem_loadw
      loc_storew.2

      movup.4
      mem_loadw
      loc_storew.3

      movup.4
      mem_loadw
      loc_storew.4

      movup.4
      mem_loadw
      loc_storew.5

      dropw

      u32unchecked_shr.1
    end
  
    drop
  end

  # write resulting point to provided output memory addresses
  push.0.0.0.0

  loc_loadw.6
  dup.4
  mem_storew

  loc_loadw.7
  dup.5
  mem_storew

  loc_loadw.8
  dup.6
  mem_storew

  loc_loadw.9
  dup.7
  mem_storew

  loc_loadw.10
  dup.8
  mem_storew

  loc_loadw.11
  dup.9
  mem_storew

  dropw
end
