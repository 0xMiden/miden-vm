# Given [a, b, c, carry] on stack top, following function computes
#
#  tmp = a + (b * c) + carry
#  hi = tmp >> 32
#  lo = tmp & 0xffff_ffff
#  return (hi, lo)
#
#  At end of execution of this function, stack top should look like [hi, lo]
export.mac
  swap
  movup.2
  u32madd.unsafe
  
  swap
  movup.2
  u32add.unsafe

  movup.2
  add
end

# Given [a, b, carry] on stack top, following function computes
#
#  tmp = a + b + carry
#  hi = tmp >> 32
#  lo = tmp & 0xffff_ffff
#  return (hi, lo)
#
#  At end of execution of this function, stack top should look like [hi, lo]
export.adc
  u32add.unsafe
  swap
  movup.2
  u32add.unsafe
  movup.2
  add
end

# Given [a0, a1, a2, a3, a4, a5, a6, a7, b, c_0_addr, c_1_addr] on stack top,
#  this function computes a multiplication of u256 by u32, while also
#  considering u256 computed during previous round.
#
#  - Multiplicand u256 in this context is kept in memory, whose 8 limbs can be loaded
#  into stack by pushing content at memory location `c_1_addr` & `c_0_addr`, in order.
#  - Multiplier u32 is `b` i.e. stack[8] element.
#  - Note, previous round's u256 is kept in first 8 stack elements.
#
#  After finishing execution of this function, stack top should hold u288 i.e.
#
#  [a0, a1, a2, a3, a4, a5, a6, a7, a8] | a8 = carry
export.u256xu32
  dup.9
  pushw.mem
  dup.12

  push.0
  swap
  movup.2
  swap
  movup.6
  exec.mac

  movup.2
  dup.12
  movup.6
  exec.mac

  movup.3
  dup.11
  movup.6
  exec.mac

  movup.4
  dup.10
  movup.6
  exec.mac

  dup.11
  pushw.mem

  movup.4
  swap
  dup.13
  movup.10
  exec.mac

  movup.2
  dup.12
  movup.10
  exec.mac

  movup.3
  dup.11
  movup.10
  exec.mac

  movup.4
  dup.10
  movup.10
  exec.mac

  swap
  movup.2
  movup.3
  movup.4
  movup.5
  movup.6
  movup.7
  movup.8
end

# Given [c0, c1, c2, c3, c4, c5, c6, c7, c8, pc] on stack top,
# this function attempts to reduce 288 -bit number to 256 -bit number
# along with carry, using montgomery reduction method
#
# In stack top content c[0..9] i.e. first 9 elements, holding 288 -bit
# number. Stack element `pc` ( at stack[9] ) is previous reduction round's
# carry ( for first reduction round, it'll be set to 0 ).
#
# After finishing execution of this function, stack top should look like
#
# [c0, c1, c2, c3, c4, c5, c6, c7, pc] | pc = next round's carry
export.u288_reduce
  dup
  push.3525653809
  u32mul.unsafe
  drop 
  # q at stack top #

  dup
  push.0.4294966319
  movup.2
  movup.4
  exec.mac
  swap
  drop

  push.4294967294
  dup.2
  movup.4
  exec.mac

  push.4294967295
  dup.3
  movup.5
  exec.mac

  push.4294967295
  dup.4
  movup.6
  exec.mac

  push.4294967295
  dup.5
  movup.7
  exec.mac

  push.4294967295
  dup.6
  movup.8
  exec.mac

  push.4294967295
  dup.7
  movup.9
  exec.mac

  push.4294967295
  movup.8
  movup.9
  exec.mac

  movup.9
  movup.9
  exec.adc

  swap
  movup.2
  movup.3
  movup.4
  movup.5
  movup.6
  movup.7
  movup.8
end
