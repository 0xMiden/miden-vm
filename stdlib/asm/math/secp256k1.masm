# Given [a, b, c, carry] on stack top, following function computes
#
#  tmp = a + (b * c) + carry
#  hi = tmp >> 32
#  lo = tmp & 0xffff_ffff
#  return (hi, lo)
#
# At end of execution of this function, stack top should look like [hi, lo]
# See https://github.com/itzmeanjan/secp256k1/blob/ec3652afe8ed72b29b0e39273a876a898316fb9a/utils.py#L75-L80
proc.mac
  swap
  movup.2
  u32madd.unsafe
  
  swap
  movup.2
  u32add.unsafe

  movup.2
  add
end

# Given [a, b, borrow] on stack top, following function computes
#
#  tmp = a - (b + borrow)
#  hi = tmp >> 32
#  lo = tmp & 0xffff_ffff
#  return (hi, lo)
#
# At end of execution of this function, stack top should look like [hi, lo]
# See https://github.com/itzmeanjan/secp256k1/blob/ec3652afe8ed72b29b0e39273a876a898316fb9a/utils.py#L83-L89
proc.sbb
  movdn.2
  u32add.unsafe
  drop
  u32sub.full
end

# Given [a0, a1, a2, a3, a4, a5, a6, a7, b, c_0_addr, c_1_addr] on stack top,
#  this function computes a multiplication of u256 by u32, while also
#  considering u256 computed during previous round.
#
#  - Multiplicand u256 in this context is kept in memory, whose 8 limbs can be loaded
#  into stack by pushing content at memory location `c_1_addr` & `c_0_addr`, in order.
#  - Multiplier u32 is `b` i.e. stack[8] element.
#  - Note, previous round's u256 is kept in first 8 stack elements.
#
#  After finishing execution of this function, stack top should hold u288 i.e.
#
#  [a0, a1, a2, a3, a4, a5, a6, a7, a8] | a8 = carry
proc.u256xu32
  dup.9
  pushw.mem
  dup.12

  push.0
  swap
  movup.2
  swap
  movup.6
  exec.mac

  movup.2
  dup.12
  movup.6
  exec.mac

  movup.3
  dup.11
  movup.6
  exec.mac

  movup.4
  dup.10
  movup.6
  exec.mac

  dup.11
  pushw.mem

  movup.4
  swap
  dup.13
  movup.10
  exec.mac

  movup.2
  dup.12
  movup.10
  exec.mac

  movup.3
  dup.11
  movup.10
  exec.mac

  movup.4
  movup.10
  movup.10
  exec.mac

  swap
  movup.2
  movup.3
  movup.4
  movup.5
  movup.6
  movup.7
  movup.8
end

# Given [c0, c1, c2, c3, c4, c5, c6, c7, c8, pc] on stack top,
# this function attempts to reduce 288 -bit number to 256 -bit number
# along with carry, using montgomery reduction method
#
# In stack top content c[0..9] i.e. first 9 elements, holding 288 -bit
# number. Stack element `pc` ( at stack[9] ) is previous reduction round's
# carry ( for first reduction round, it'll be set to 0 ).
#
# After finishing execution of this function, stack top should look like
#
# [c0, c1, c2, c3, c4, c5, c6, c7, pc] | pc = next round's carry
proc.u288_reduce
  dup
  push.3525653809
  u32mul.unsafe
  drop 
  # q at stack top #

  dup
  push.0.4294966319
  movup.2
  movup.4
  exec.mac
  swap
  drop

  push.4294967294
  dup.2
  movup.4
  exec.mac

  push.4294967295
  dup.3
  movup.5
  exec.mac

  push.4294967295
  dup.4
  movup.6
  exec.mac

  push.4294967295
  dup.5
  movup.7
  exec.mac

  push.4294967295
  dup.6
  movup.8
  exec.mac

  push.4294967295
  dup.7
  movup.9
  exec.mac

  push.4294967295
  movup.8
  movup.9
  exec.mac

  movup.9
  swap
  movup.9
  u32add3.unsafe

  swap
  movup.2
  movup.3
  movup.4
  movup.5
  movup.6
  movup.7
  movup.8
end

# Given two 256 -bit numbers on stack, where each number is represented in
# radix-2^32 form ( i.e. each number having eight 32 -bit limbs ), following function
# computes modular multiplication of those two operands, computing 256 -bit result.
#
# Stack expected as below, holding input
#
# [a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7] | a[0..8], b[0..8] are 256 -bit numbers
#
# After finishing execution of this function, stack should look like
#
# [c0, c1, c2, c3, c4, c5, c6, c7] | c[0..8] is a 256 -bit number
#
# Note, for computing modular multiplication of a[0..8] & b[0..8],
# school book multiplication equipped with montgomery reduction technique
# is used, which is why a[0..8], b[0..8] are expected to be in montgomery form,
# while computed c[0..8] will also be in montgomery form.
export.u256_mod_mul.2
  popw.local.0
  popw.local.1

  push.env.locaddr.1
  push.env.locaddr.0
  movup.2
  push.0.0.0.0
  push.0.0.0.0

  exec.u256xu32
  
  push.0
  movdn.9

  exec.u288_reduce

  movup.8
  swap.11
  movdn.8

  exec.u256xu32

  movup.11
  movdn.9

  exec.u288_reduce

  movup.8
  swap.11
  movdn.8

  exec.u256xu32

  movup.11
  movdn.9

  exec.u288_reduce

  movup.8
  swap.11
  movdn.8

  exec.u256xu32

  movup.11
  movdn.9

  exec.u288_reduce

  movup.8
  swap.11
  movdn.8

  exec.u256xu32

  movup.11
  movdn.9

  exec.u288_reduce

  movup.8
  swap.11
  movdn.8

  exec.u256xu32

  movup.11
  movdn.9

  exec.u288_reduce

  movup.8
  swap.11
  movdn.8

  exec.u256xu32

  movup.11
  movdn.9

  exec.u288_reduce

  movup.8
  swap.11
  movdn.8

  exec.u256xu32

  movup.11
  movdn.9

  exec.u288_reduce

  dup.8
  movup.2
  add
  swap

  movup.8
  mul.977
  add

  movup.8
  drop
  movup.8
  drop
end

# Given two 256 -bit numbers on stack, where each number is represented in
# radix-2^32 form ( i.e. each number having eight 32 -bit limbs ), following function
# computes modular addition of those two operands, in secp256k1 prime field.
#
# Stack expected as below, holding input
#
# [a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7] | a[0..8], b[0..8] are 256 -bit numbers
#
# After finishing execution of this function, stack should look like
#
# [c0, c1, c2, c3, c4, c5, c6, c7] | c[0..8] is a 256 -bit number
#
# This implementation takes inspiration from https://gist.github.com/itzmeanjan/d4853347dfdfa853993f5ea059824de6#file-test_montgomery_arithmetic-py-L236-L256
export.u256_mod_add
  push.0
  swap
  movup.9
  u32add3.unsafe

  movup.2
  movup.9
  u32add3.unsafe

  movup.3
  movup.9
  u32add3.unsafe

  movup.4
  movup.9
  u32add3.unsafe

  movup.5
  movup.9
  u32add3.unsafe

  movup.6
  movup.9
  u32add3.unsafe

  movup.7
  movup.9
  u32add3.unsafe

  movup.8
  movup.9
  u32add3.unsafe

  movup.8
  dup.1
  push.977
  u32madd.unsafe
  drop

  movup.8
  movup.2
  u32add.unsafe
  drop

  movup.2
  movup.3
  movup.4
  movup.5
  movup.6
  movup.7
  movup.6
  movup.7
end

# Given a secp256k1 field element ( say `a` ) on stack, represented in Montgomery form 
# ( i.e. number having eight 32 -bit limbs ), following function negates it to
# field element `a'` | a' + a = 0
#
# Stack expected as below, holding input
#
# [a0, a1, a2, a3, a4, a5, a6, a7] | a[0..8] is a secp256k1 field element
#
# After finishing execution of this function, stack should look like
#
# [c0, c1, c2, c3, c4, c5, c6, c7] | c[0..8] is a secp256k1 field element
#
# See https://github.com/itzmeanjan/secp256k1/blob/ec3652afe8ed72b29b0e39273a876a898316fb9a/field.py#L77-L95
export.u256_mod_neg
  push.0
  swap
  push.4294966319
  exec.sbb

  movup.2
  push.4294967294
  exec.sbb

  movup.3
  push.4294967295
  exec.sbb

  movup.4
  push.4294967295
  exec.sbb

  movup.5
  push.4294967295
  exec.sbb

  movup.6
  push.4294967295
  exec.sbb

  movup.7
  push.4294967295
  exec.sbb

  movup.8
  push.4294967295
  exec.sbb

  drop
  
  swap
  movup.2
  movup.3
  movup.4
  movup.5
  movup.6
  movup.7
end

# Given two secp256k1 field elements, say a, b, ( represented in Montgomery form, each number having 
# eight 32 -bit limbs ) on stack, following function computes modular subtraction of those 
# two operands c = a + (-b) = a - b
#
# Stack expected as below, holding input
#
# [a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7] | a[0..8], b[0..8] are secp256k1 field elements
#
# After finishing execution of this function, stack should look like
#
# [c0, c1, c2, c3, c4, c5, c6, c7] | c[0..8] is a secp256k1 field element
#
# See https://github.com/itzmeanjan/secp256k1/blob/ec3652afe8ed72b29b0e39273a876a898316fb9a/field.py#L97-L101
export.u256_mod_sub.2
  popw.local.0
  popw.local.1

  exec.u256_mod_neg

  pushw.local.1
  pushw.local.0

  exec.u256_mod_add
end

# Given a 256 -bit number on stack, represented in radix-2^32 
# form i.e. eight 32 -bit limbs, this routine computes Montgomery
# representation of provided radix-2^32 number.
#
# - u256 radix-2^32 form input expected on stack as
#
#  [a0, a1, a2, a3, a4, a5, a6, a7]
#
# - u256 montgomery form output on stack
#
# [a0`, a1`, a2`, a3`, a4`, a5`, a6`, a7`]
#
# See section 2.2 of https://eprint.iacr.org/2017/1057.pdf
export.to_mont
  push.0.0.0.0
  push.0.1.1954.954529 # pushed R2's radix-2^32 form;
                       # see https://gist.github.com/itzmeanjan/d4853347dfdfa853993f5ea059824de6

  exec.u256_mod_mul
end

# Given a 256 -bit number on stack, represented in Montgomery 
# form i.e. eight 32 -bit limbs, this routine computes radix-2^32
# representation of provided u256 number.
#
# - u256 montgomery form input on stack expected
#
#  [a0, a1, a2, a3, a4, a5, a6, a7]
#
# - u256 radix-2^32 form output on stack as
#
# [a0`, a1`, a2`, a3`, a4`, a5`, a6`, a7`]
#
# See section 2.2 of https://eprint.iacr.org/2017/1057.pdf
export.from_mont
  push.0.0.0.0
  push.0.0.0.1 # pushed 1's radix-2^32 form;
               # see https://gist.github.com/itzmeanjan/d4853347dfdfa853993f5ea059824de6

  exec.u256_mod_mul
end
