use.std::math::ext5

# Given an encoded elliptic curve point `w` s.t. it's expressed using
# an element ∈ GF(p^5) | p = 2^64 - 2^32 + 1, this routine verifies whether
# given point can be successfully decoded or not
#
# Expected stack state 
#
# [w0, w1, w2, w3, w4, ...]
#
# Final stack state 
#
# [flg, ...]
#
# If w can be decoded, flg = 1
# Else flg = 0
#
# Note, if w = (0, 0, 0, 0, 0), it can be successfully decoded to point 
# at infinity i.e. flg = 1, in that case.
#
# See https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L1043-L1052
# for reference implementation
export.validate
    repeat.5
        dup.4
    end

    exec.ext5::square
    sub.2 # = e

    exec.ext5::square
    swap
    sub.1052
    swap # = delta
    
    exec.ext5::legendre
    eq.1
    movdn.5

    push.1
    repeat.5
        swap
        eq.0
        and
    end

    or
end

# Given an encoded elliptic curve point `w` s.t. it's expressed using
# an element ∈ GF(p^5) | p = 2^64 - 2^32 + 1, this routine attempts to decode
# it into x, y coordinates, along with boolean field element denoting whether it's
# point-at-infinity or not.
#
# Expected stack state 
#
# [w0, w1, w2, w3, w4, ...]
#
# Final state state 
#
# [x0, x1, x2, x3, x4, y0, y1, y2, y3, y4, inf, flg, ...]
#
# If `w` has be decoded, flg = 1
# Else flg = 0 and x, y = (0, 0)
#
# Note, when w = (0, 0, 0, 0, 0), it will be successfully decoded to
# point-at-infinity i.e. x, y = (0, 0) and flg = 1
#
# See https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L1022-L1041
# for reference implementation
export.decode
    repeat.5
        dup.4
    end

    exec.ext5::square
    sub.2 # = e

    repeat.5
        dup.4
    end

    exec.ext5::square
    swap
    sub.1052
    swap # = delta

    exec.ext5::sqrt # = (r, c)

    repeat.5
        dup.10
    end

    repeat.5
        dup.9
    end

    exec.ext5::add
    push.0.0.0.0.9223372034707292161
    exec.ext5::mul # = x1

    repeat.5
        movup.9
    end

    repeat.5
        movup.15
    end

    exec.ext5::sub
    push.0.0.0.0.9223372034707292161
    exec.ext5::mul # = x2

    repeat.5
        movup.9
    end

    repeat.5
        dup.4
    end

    exec.ext5::legendre
    eq.1

    if.true
        repeat.5
            movup.5
            drop
        end
    else
        repeat.5
            drop
        end
    end # = x

    repeat.5
        dup.10
    end

    repeat.5
        dup.9
    end

    exec.ext5::mul
    repeat.5
        movup.4
        neg
    end # = y

    dup.10
    not # = inf

    push.1
    repeat.5
        movup.13
        eq.0
        and
    end

    movup.12
    or # = c

    swap

    repeat.5
        movup.6
    end

    repeat.5
        movup.11
    end

    add.6148914689804861441 # = x
end

# Given an elliptic curve point as Weierstraß coordinates (X, Y) along with
# boolean field element `inf`, denoting whether this is point-at-infinity or not, 
# this routine encodes it to a single element ∈ GF(p^5) | p = 2^64 - 2^32 + 1
#
# Expected stack state 
#
# [x0, x1, x2, x3, x4, y0, y1, y2, y3, y4, inf, ...]
#
# Final stack state 
#
# [w0, w1, w2, w3, w4, ...]
#
# Note, when inf = 1, encoded point w = (0, 0, 0, 0, 0)
#
# See https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L1214-L1216
# for reference implementation.
export.encode
    push.0.0.0.0.6148914689804861441 # = a/ 3

    exec.ext5::sub # = (a/ 3) - x

    repeat.5
        movup.9
    end

    exec.ext5::div # = w = y/ ((a/ 3) - x)

    movup.5
    if.true
        repeat.5
            drop
        end

        push.0.0.0.0.0
    end
end

# Given two elliptic curve points ( say a, b ) as Weierstraß coordinates (X, Y) on stack,
# this routine computes elliptic curve point c, resulting from a + b.
#
# Following point addition formulas are complete and they work when two points are 
# same/ different or input operands are point-at-infinity.
#
# Expected stack state
#
# [x1_0, x1_1, x1_2, x1_3, x1_4, y1_0, y1_1, y1_2, y1_3, y1_4, inf1, x2_0, x2_1, x2_2, x2_3, x2_4, y2_0, y2_1, y2_2, y2_3, y2_4, inf2, ...]
#
# s.t. x1_{0..5} -> x1, y1_{0..5} -> y1 |> a = (x1, y1, inf1)
#      x2_{0..5} -> x2, y2_{0..5} -> y2 |> b = (x2, y2, inf2)
#
# Final stack state
#
# [x3_0, x3_1, x3_2, x3_3, x3_4, y3_0, y3_1, y3_2, y3_3, y3_4, inf3, ...]
#
# Read point addition section ( on page 8 ) of https://ia.cr/2022/274
# For reference implementation see https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L1228-L1255
export.add.10
    loc_storew.0
    dropw
    loc_store.1 # cached x1
    drop

    loc_storew.2
    dropw
    loc_store.3 # cached y1
    drop

    loc_store.4 # cached inf1
    drop

    loc_storew.5
    dropw
    loc_store.6 # cached x2
    drop

    loc_storew.7
    dropw
    loc_store.8 # cached y2
    drop

    loc_store.9 # cached inf2
    drop

    loc_load.6
    push.0.0.0.0
    loc_loadw.5 # bring x2

    loc_load.1
    push.0.0.0.0
    loc_loadw.0 # bring x1

    exec.ext5::eq
    dup

    if.true
        loc_load.1
        push.0.0.0.0
        loc_loadw.0 # bring x1

        exec.ext5::square

        repeat.5
            movup.4
            mul.3
        end

        add.6148914689804861439
        swap
        add.263
        swap
    else
        loc_load.3
        push.0.0.0.0
        loc_loadw.2 # bring y1

        loc_load.8
        push.0.0.0.0
        loc_loadw.7 # bring y2

        exec.ext5::sub
    end # = λ0

    dup.5

    if.true
        loc_load.3
        push.0.0.0.0
        loc_loadw.2 # bring y1

        repeat.5
            movup.4
            mul.2
        end
    else
        loc_load.1
        push.0.0.0.0
        loc_loadw.0 # bring x1

        loc_load.6
        push.0.0.0.0
        loc_loadw.5 # bring x2

        exec.ext5::sub
    end # = λ1

    repeat.5
        movup.9
    end

    exec.ext5::div # = λ

    repeat.5
        dup.4
    end

    exec.ext5::square # = λ^2

    loc_load.6
    push.0.0.0.0
    loc_loadw.5 # bring x2

    loc_load.1
    push.0.0.0.0
    loc_loadw.0 # bring x1

    exec.ext5::add

    repeat.5
        movup.9
    end

    exec.ext5::sub # compute x3

    repeat.5
        dup.4
    end

    loc_load.1
    push.0.0.0.0
    loc_loadw.0 # bring x1

    exec.ext5::sub

    repeat.5
        movup.14
    end

    exec.ext5::mul

    loc_load.3
    push.0.0.0.0
    loc_loadw.2 # bring y1

    repeat.5
        movup.9
    end

    exec.ext5::sub # compute y3

    movup.10

    loc_load.3
    push.0.0.0.0
    loc_loadw.2 # bring y1

    loc_load.8
    push.0.0.0.0
    loc_loadw.7 # bring y2

    exec.ext5::neq

    and # compute inf3

    movdn.5

    # finalize selection of y3

    loc_load.8
    push.0.0.0.0
    loc_loadw.7 # bring y2

    loc_load.4 # bring inf1

    if.true
        repeat.5
            movup.5
            drop
        end
    else
        repeat.5
            drop
        end
    end

    loc_load.3
    push.0.0.0.0
    loc_loadw.2 # bring y1

    loc_load.9 # bring inf2

    if.true
        repeat.5
            movup.5
            drop
        end
    else
        repeat.5
            drop
        end
    end

    # finalize selection of x3

    repeat.5
        movup.10
    end

    loc_load.6
    push.0.0.0.0
    loc_loadw.5 # bring x2

    loc_load.4 # bring inf1

    if.true
        repeat.5
            movup.5
            drop
        end
    else
        repeat.5
            drop
        end
    end

    loc_load.1
    push.0.0.0.0
    loc_loadw.0 # bring x1

    loc_load.9 # bring inf2

    if.true
        repeat.5
            movup.5
            drop
        end
    else
        repeat.5
            drop
        end
    end

    # finalize selection of inf3

    movup.10
    loc_load.9 # bring inf2
    loc_load.4 # bring inf1
    cdrop

    loc_load.4 # bring inf1
    loc_load.9 # bring inf2
    cdrop

    movdn.10
end
