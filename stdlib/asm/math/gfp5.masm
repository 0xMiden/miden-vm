# Given two GF(p^5) elements on stack, this routine computes modular
# addition over extension field GF(p^5) s.t. p = 2^64 - 2^32 + 1
#
# Expected stack state :
#
# [a0, a1, a2, a3, a4, b0, b1, b2, b3, b4, ...]
#
# After application of routine stack :
#
# [c0, c1, c2, c3, c4, ...] s.t. c = a + b
#
# See section 3.2 of https://eprint.iacr.org/2022/274.pdf
#
# For reference implementation in high level language, see 
# https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L607-L616
export.add
    repeat.5
        movup.5
        add
        movdn.4
    end
end

# Given two GF(p^5) elements on stack, this routine subtracts second
# element from first one, over extension field GF(p^5) s.t. p = 2^64 - 2^32 + 1
#
# Expected stack state :
#
# [a0, a1, a2, a3, a4, b0, b1, b2, b3, b4, ...]
#
# After application of routine stack :
#
# [c0, c1, c2, c3, c4, ...] s.t. c = a - b
#
# See section 3.2 of https://eprint.iacr.org/2022/274.pdf
#
# For reference implementation in high level language, see 
# https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L629-L638
export.sub
    repeat.5
        movup.5
        sub
        movdn.4
    end
end

# Given two GF(p^5) elements on stack, this routine computes modular
# multiplication ( including reduction by irreducible polynomial ) 
# over extension field GF(p^5) s.t. p = 2^64 - 2^32 + 1
#
# Expected stack state :
#
# [a0, a1, a2, a3, a4, b0, b1, b2, b3, b4, ...]
#
# After application of routine stack :
#
# [c0, c1, c2, c3, c4, ...] s.t. c = a * b
#
# See section 3.2 of https://eprint.iacr.org/2022/274.pdf
#
# For reference implementation in high level language, see 
# https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L676-L689
export.mul
    # compute {c0, c1, c2, c3, c4} - five coefficients of resulting
    # degree-4 polynomial
    
    # compute c4
    dup.9
    dup.1
    mul

    dup.9
    dup.3
    mul

    add

    dup.8
    dup.4
    mul

    add

    dup.7
    dup.5
    mul

    add

    dup.6
    dup.6
    mul
    
    add

    # compute c3
    dup.9
    dup.2
    mul

    dup.9
    dup.4
    mul
    
    add

    dup.8
    dup.5
    mul

    add

    dup.7
    dup.6
    mul

    add

    dup.11
    dup.7
    mul
    mul.3

    add

    # compute c2
    dup.9
    dup.3
    mul

    dup.9
    dup.5
    mul

    add

    dup.8
    dup.6
    mul
    
    add

    dup.12
    dup.7
    mul
    mul.3

    add

    dup.11
    dup.8
    mul
    mul.3

    add

    # compute c1
    dup.9
    dup.4
    mul

    dup.9
    dup.6
    mul

    add

    dup.13
    dup.7
    mul
    mul.3

    add

    dup.12
    dup.8
    mul
    mul.3

    add

    dup.11
    dup.9
    mul
    mul.3

    add

    # compute c0
    movup.9
    movup.5
    mul

    movup.12
    movup.6
    mul
    mul.3

    add

    movup.10
    movup.6
    mul
    mul.3

    add

    movup.8
    movup.6
    mul
    mul.3

    add

    movup.6
    movup.6
    mul
    mul.3

    add
end

# Given one GF(p^5) element on stack, this routine computes modular
# squaring ( including reduction by irreducible polynomial ) 
# over extension field GF(p^5) s.t. p = 2^64 - 2^32 + 1
#
# This routine has same effect as calling mul(a, a) | a ∈ GF(p^5)
#
# Expected stack state :
#
# [a0, a1, a2, a3, a4, ...]
#
# After application of routine stack :
#
# [b0, b1, b2, b3, b4, ...] s.t. b = a * a
#
# See section 3.2 of https://eprint.iacr.org/2022/274.pdf
#
# For reference implementation in high level language, see 
# https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L709-L715
export.square
    # compute {b0, b1, b2, b3, b4} - five coefficients of resulting
    # degree-4 polynomial

    # compute b4
    dup.2
    dup.3
    mul

    dup.5
    dup.2
    mul
    mul.2

    add

    dup.4
    dup.3
    mul
    mul.2

    add

    # compute b3
    dup.4
    dup.2
    mul
    mul.2

    dup.4
    dup.4
    mul
    mul.2

    add

    dup.6
    dup.7
    mul
    mul.3

    add

    # compute b2
    dup.3
    dup.4
    mul
    
    dup.5
    dup.4
    mul
    mul.2

    add

    dup.7
    dup.7
    mul
    mul.6

    add

    # compute b1
    dup.4
    dup.4
    mul
    mul.2

    dup.7
    dup.8
    mul
    mul.3

    add

    dup.8
    dup.7
    mul
    mul.6

    add

    # compute b0
    dup.4
    movup.5
    mul

    movup.8
    movup.6
    mul
    mul.6

    add

    movup.6
    movup.6
    mul
    mul.6

    add
end

# Given an element a ∈ GF(p^5), this routine applies Frobenius operator
# once, raising the element to the power of p | p = 2^64 - 2^32 + 1.
#
# Expected stack state :
#
# [a0, a1, a2, a3, a4, ...]
#
# Final stack state :
#
# [b0, b1, b2, b3, b4, ...]
#
# See https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L723-L737
# for reference implementation in high-level language.
proc.frobenius_once
    movup.4
    mul.1373043270956696022

    movup.4
    mul.211587555138949697

    movup.4
    mul.15820824984080659046

    movup.4
    mul.1041288259238279555

    movup.4
end

# Given an element a ∈ GF(p^5), this routine applies Frobenius operator
# twice, raising the element to the power of p^2 | p = 2^64 - 2^32 + 1.
#
# Expected stack state :
#
# [a0, a1, a2, a3, a4, ...]
#
# Final stack state :
#
# [b0, b1, b2, b3, b4, ...]
#
# See https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L739-L749
# for reference implementation in high-level language.
proc.frobenius_twice
    movup.4
    mul.211587555138949697

    movup.4
    mul.1041288259238279555

    movup.4
    mul.1373043270956696022

    movup.4
    mul.15820824984080659046

    movup.4
end

# Given one GF(p^5) element on stack, this routine computes multiplicative
# inverse over extension field GF(p^5) s.t. p = 2^64 - 2^32 + 1
#
# Expected stack state :
#
# [a0, a1, a2, a3, a4, ...]
#
# After application of routine stack :
#
# [b0, b1, b2, b3, b4, ...] s.t. b = 1 / a
#
# See section 3.2 of https://eprint.iacr.org/2022/274.pdf
#
# For reference implementation in high level language, see 
# https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L751-L775
#
# Note, this routine will not panic even when operand `a` is zero.
export.inv
    repeat.5
        dup.4
    end

    exec.frobenius_once # = t0

    repeat.5
        dup.4
    end

    exec.frobenius_once # = t0.frobenius_once()
    exec.mul            # = t1

    repeat.5
        dup.4
    end

    exec.frobenius_twice # = t1.frobenius_twice()
    exec.mul             # = t2

    movup.5
    dup.1
    mul

    movup.6
    dup.6
    mul
    mul.3

    add

    movup.6
    dup.5
    mul
    mul.3

    add

    movup.6
    dup.4
    mul
    mul.3

    add

    movup.6
    dup.3
    mul
    mul.3

    add                    # = t3

    dup
    push.0
    eq
    add
    inv                    # = t4

    movup.5
    dup.1
    mul

    movup.5
    dup.2
    mul

    movup.5
    dup.3
    mul

    movup.5
    dup.4
    mul

    movup.5
    movup.5
    mul
end

# Given two GF(p^5) elements ( say a, b ) on stack, this routine computes
# modular division over extension field GF(p^5) s.t. p = 2^64 - 2^32 + 1
#
# Expected stack state :
#
# [a0, a1, a2, a3, a4, b0, b1, b2, b3, b4, ...]
#
# After application of routine stack :
#
# [c0, c1, c2, c3, c4, ...] s.t. c = a / b
#
# See section 3.2 of https://eprint.iacr.org/2022/274.pdf
#
# For reference implementation in high level language, see 
# https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L777-L781
export.div
    repeat.5
        movup.9
    end

    exec.inv
    exec.mul
end

# Given an element v ∈ Z_q | q = 2^64 - 2^32 + 1, this routine computes
# legendre symbol, by raising that element to the power (p-1) / 2
#
# Expected stack state :
#
# [v, ...]
#
# After finishing execution stack looks like
#
# [v', ...] s.t. v' = legendre symbol of v
#
# See https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L448-L459
# for reference implementation in higher level language.
proc.gf_legendre
    repeat.31
        dup
        mul
    end

    dup

    repeat.32
        dup
        mul
    end

    swap
    dup
    eq.0
    add

    div
end

# Given an element v ∈ GF(p^5), this routine computes its legendre symbol,
# which is an element ∈ GF(p) | p = 2^64 - 2^32 + 1
#
# At beginning stack looks like
#
# [a0, a1, a2, a3, a4, ...]
#
# At end stack looks like
#
# [b, ...] s.t. b = legendre symbol of a
#
# See https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L857-L877
# for reference implementation in higher level language.
export.legendre
    repeat.5
        dup.4
    end

    exec.frobenius_once

    repeat.5
        dup.4
    end

    exec.frobenius_once
    exec.mul

    repeat.5
        dup.4
    end

    exec.frobenius_twice
    exec.mul

    movup.5
    mul

    movup.5
    movup.5
    mul
    mul.3
    
    add

    movup.4
    movup.4
    mul
    mul.3

    add

    movup.3
    movup.3
    mul
    mul.3

    add

    movup.2
    movup.2
    mul
    mul.3

    add

    exec.gf_legendre
end
