# Given two GF(p^5) elements on stack, this routine computes modular
# addition over extension field GF(p^5) s.t. p = 2^64 - 2^32 + 1
#
# Expected stack state :
#
# [a0, a1, a2, a3, a4, b0, b1, b2, b3, b4, ...]
#
# After application of routine stack :
#
# [c0, c1, c2, c3, c4, ...]
#
# See section 3.2 of https://eprint.iacr.org/2022/274.pdf
#
# For reference implementation in high level language, see 
# https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L607-L616
export.add
    movup.5
    add

    swap
    movup.5
    add
    swap

    movup.2
    movup.5
    add
    movdn.2

    movup.3
    movup.5
    add
    movdn.3

    movup.4
    movup.5
    add
    movdn.4
end

# Given two GF(p^5) elements on stack, this routine subtracts second
# element from first one, over extension field GF(p^5) s.t. p = 2^64 - 2^32 + 1
#
# Expected stack state :
#
# [a0, a1, a2, a3, a4, b0, b1, b2, b3, b4, ...]
#
# After application of routine stack :
#
# [c0, c1, c2, c3, c4, ...]
#
# See section 3.2 of https://eprint.iacr.org/2022/274.pdf
#
# For reference implementation in high level language, see 
# https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L629-L638
export.sub
    movup.5
    sub

    swap
    movup.5
    sub
    swap

    movup.2
    movup.5
    sub
    movdn.2

    movup.3
    movup.5
    sub
    movdn.3

    movup.4
    movup.5
    sub
    movdn.4
end

# Given two GF(p^5) elements on stack, this routine computes modular
# multiplication ( including reduction by irreducible polynomial ) 
# over extension field GF(p^5) s.t. p = 2^64 - 2^32 + 1
#
# Expected stack state :
#
# [a0, a1, a2, a3, a4, b0, b1, b2, b3, b4, ...]
#
# After application of routine stack :
#
# [c0, c1, c2, c3, c4, ...]
#
# See section 3.2 of https://eprint.iacr.org/2022/274.pdf
#
# For reference implementation in high level language, see 
# https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L676-L689
export.mul
    # compute {c0, c1, c2, c3, c4} - five coefficients of resulting
    # degree-4 polynomial
    
    # compute c4
    dup.9
    dup.1
    mul

    dup.9
    dup.3
    mul

    add

    dup.8
    dup.4
    mul

    add

    dup.7
    dup.5
    mul

    add

    dup.6
    dup.6
    mul
    
    add

    # compute c3
    dup.9
    dup.2
    mul

    dup.9
    dup.4
    mul
    
    add

    dup.8
    dup.5
    mul

    add

    dup.7
    dup.6
    mul

    add

    dup.11
    dup.7
    mul
    mul.3

    add

    # compute c2
    dup.9
    dup.3
    mul

    dup.9
    dup.5
    mul

    add

    dup.8
    dup.6
    mul
    
    add

    dup.12
    dup.7
    mul
    mul.3

    add

    dup.11
    dup.8
    mul
    mul.3

    add

    # compute c1
    dup.9
    dup.4
    mul

    dup.9
    dup.6
    mul

    add

    dup.13
    dup.7
    mul
    mul.3

    add

    dup.12
    dup.8
    mul
    mul.3

    add

    dup.11
    dup.9
    mul
    mul.3

    add

    # compute c0
    movup.9
    movup.5
    mul

    movup.12
    movup.6
    mul
    mul.3

    add

    movup.10
    movup.6
    mul
    mul.3

    add

    movup.8
    movup.6
    mul
    mul.3

    add

    movup.6
    movup.6
    mul
    mul.3

    add
end

# Given one GF(p^5) element on stack, this routine computes modular
# squaring ( including reduction by irreducible polynomial ) 
# over extension field GF(p^5) s.t. p = 2^64 - 2^32 + 1
#
# This routine has same effect as calling mul(a, a) | a ∈ GF(p^5)
#
# Expected stack state :
#
# [a0, a1, a2, a3, a4, ...]
#
# After application of routine stack :
#
# [b0, b1, b2, b3, b4, ...]
#
# See section 3.2 of https://eprint.iacr.org/2022/274.pdf
#
# For reference implementation in high level language, see 
# https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L709-L715
export.square
    # compute {b0, b1, b2, b3, b4} - five coefficients of resulting
    # degree-4 polynomial

    # compute b4
    dup.2
    dup.3
    mul

    dup.5
    dup.2
    mul
    mul.2

    add

    dup.4
    dup.3
    mul
    mul.2

    add

    # compute b3
    dup.4
    dup.2
    mul
    mul.2

    dup.4
    dup.4
    mul
    mul.2

    add

    dup.6
    dup.7
    mul
    mul.3

    add

    # compute b2
    dup.3
    dup.4
    mul
    
    dup.5
    dup.4
    mul
    mul.2

    add

    dup.7
    dup.7
    mul
    mul.6

    add

    # compute b1
    dup.4
    dup.4
    mul
    mul.2

    dup.7
    dup.8
    mul
    mul.3

    add

    dup.8
    dup.7
    mul
    mul.6

    add

    # compute b0
    dup.4
    movup.5
    mul

    movup.8
    movup.6
    mul
    mul.6

    add

    movup.6
    movup.6
    mul
    mul.6

    add
end

# Given an element a ∈ GF(p^5), this routine applies Frobenius operator
# once, raising the element to the power of p | p = 2^64 - 2^32 + 1.
#
# Expected stack state :
#
# [a0, a1, a2, a3, a4, ...]
#
# Final stack state :
#
# [b0, b1, b2, b3, b4, ...]
#
# See https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L723-L737
# for reference implementation in high-level language.
proc.frobenius_once
    swap
    mul.1041288259238279555
    swap

    movup.2
    mul.15820824984080659046
    movdn.2

    movup.3
    mul.211587555138949697
    movdn.3

    movup.4
    mul.1373043270956696022
    movdn.4
end

# Given an element a ∈ GF(p^5), this routine applies Frobenius operator
# twice, raising the element to the power of p^2 | p = 2^64 - 2^32 + 1.
#
# Expected stack state :
#
# [a0, a1, a2, a3, a4, ...]
#
# Final stack state :
#
# [b0, b1, b2, b3, b4, ...]
#
# See https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L739-L749
# for reference implementation in high-level language.
proc.frobenius_twice
    swap
    mul.15820824984080659046
    swap

    movup.2
    mul.1373043270956696022
    movdn.2

    movup.3
    mul.1041288259238279555
    movdn.3

    movup.4
    mul.211587555138949697
    movdn.4
end

# Given one GF(p^5) element on stack, this routine computes multiplicative
# inverse over extension field GF(p^5) s.t. p = 2^64 - 2^32 + 1
#
# Expected stack state :
#
# [a0, a1, a2, a3, a4, ...]
#
# After application of routine stack :
#
# [b0, b1, b2, b3, b4, ...]
#
# See section 3.2 of https://eprint.iacr.org/2022/274.pdf
#
# For reference implementation in high level language, see 
# https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L751-L775
#
# Note, this routine will not panic even when operand `a` is zero.
export.inv
    repeat.5
        dup.4
    end

    exec.frobenius_once # = t0

    repeat.5
        dup.4
    end

    exec.frobenius_once # = t0.frobenius_once()
    exec.mul            # = t1

    repeat.5
        dup.4
    end

    exec.frobenius_twice # = t1.frobenius_twice()
    exec.mul             # = t2

    movup.5
    dup.1
    mul

    movup.6
    dup.6
    mul
    mul.3

    add

    movup.6
    dup.5
    mul
    mul.3

    add

    movup.6
    dup.4
    mul
    mul.3

    add

    movup.6
    dup.3
    mul
    mul.3

    add                    # = t3

    dup
    push.0
    eq
    add
    inv                    # = t4

    movup.5
    dup.1
    mul

    movup.5
    dup.2
    mul

    movup.5
    dup.3
    mul

    movup.5
    dup.4
    mul

    movup.5
    movup.5
    mul
end

# Given two GF(p^5) elements ( say a, b ) on stack, this routine computes
# modular division over extension field GF(p^5) s.t. p = 2^64 - 2^32 + 1
#
# Expected stack state :
#
# [a0, a1, a2, a3, a4, b0, b1, b2, b3, b4, ...]
#
# After application of routine stack :
#
# [c0, c1, c2, c3, c4, ...]
#
# See section 3.2 of https://eprint.iacr.org/2022/274.pdf
#
# For reference implementation in high level language, see 
# https://github.com/pornin/ecgfp5/blob/ce059c6/python/ecGFp5.py#L777-L781
export.div
    repeat.5
        movup.9
    end

    exec.inv
    exec.mul
end
