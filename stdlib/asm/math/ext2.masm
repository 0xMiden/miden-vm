#! Given a stack with initial configuration given by [a1,a0,b1,b0,...] where a = (a0,a1) and
#! b = (b0,b1) represent elements in the extension field of degree 2, the procedure outputs the 
#! product c = (c1,c0) where c0 = a0b0 - 2(a1b1) and c1 = (a0 + a1)(b0 + b1) - a0b0
export.mul
    dupw            #[a1,a0,b1,b0,a1,a0,b1,b0,...]
    swap.3          #[b0,a0,b1,a1,a1,a0,b1,b0,...]
    mul             #[b0a0,b1,a1,a1,a0,b1,b0,...]
    dup             #[b0a0,b0a0,b1,a1,a1,a0,b1,b0,...]
    movdn.7         #[b0a0,b1,a1,a1,a0,b1,b0,b0a0,...]
    movdn.2         #[b1,a1,b0a0,a1,a0,b1,b0,b0a0,...]
    mul.2           #[2b1,a1,b0a0,a1,a0,b1,b0,b0a0,...]
    mul             #[2b1a1,b0a0,a1,a0,b1,b0,b0a0,...]
    sub             #[b0a0-2b1a1,a1,a0,b1,b0,b0a0,...]
    movdn.5         #[a1,a0,b1,b0,b0a0,b0a0-2b1a1,...]
    add             #[a1+a0,b1,b0,b0a0,b0a0-2b1a1,...]
    swap.2          #[b0,b1,a1+a0,b0a0,b0a0-2b1a1,...]
    add             #[b0+b1,a1+a0,b0a0,b0a0-2b1a1,...]
    mul             #[(b0+b1)(a1+a0),b0a0,b0a0-2b1a1,...]
    swap            #[b0a0,(b0+b1)(a1+a0),b0a0-2b1a1,...]
    sub             #[(b0+b1)(a1+a0)-b0a0,b0a0-2b1a1,...]
end

#! Given a stack with initial configuration given by [x,a1,a0,...] where a = (a0,a1) is an element
#! in the field extension and x is an element of the base field, this procedure computes the multiplication
#! of x, when looked at as (x,0), with a in the extension field. The output is [xa1,xa0,...]
export.mul_base
    dup         #[x,x,a1,a0,...]
    movdn.3     #[x,a1,a0,x,...]
    mul         #[xa1,a0,x,...]
    movdn.2     #[a0,x,xa1,...]
    mul         #[xa0,xa1,...]
    swap        #[xa1,xa0,...]
end

#! Given a stack in the following initial configuration [a1,a0,b1,b0,...] the following
#! procedure computes [a1+b1,a0+b0,...]
export.add
    swap        #[a0,a1,b1,b0,...]
    movup.3     #[b0,a0,a1,b1,...]
    add         #[b0+a0,a1,b1,...]
    movdn.2     #[a1,b1,b0+a0,...]
    add         #[a1+b1,b0+a0,...]
end

#! Given a stack in the following initial configuration [a1,a0,b1,b0,...] the following
#! procedure computes [a1-b1,a0-b0,...]
export.sub
    swap        #[a0,a1,b1,b0,...]
    movup.3     #[b0,a0,a1,b1,...]
    sub         #[a0-b0,a1,b1,...]
    movdn.2     #[a1,b1,a0-b0,...]
    swap        #[b1,a1,a0-b0,...]
    sub         #[a1-b1,a0-b0,...]
end

#! Given an invertible quadratic extension field element on the stack, this routine computes
#! multiplicative inverse of that element, using non-deterministic technique ( i.e. it takes help
#! of advice provider ). To ensure that non-deterministic computation resulted in correct value,
#! it multiplies input operand with computed output, over quadratic extension field which must produce
#! multiplicative identity (1, 0) of quadratic extension field. In case input operand is additive
#! identity which can't be inverted, program execution fails, as advice provider won't calculate
#! multiplicative inverse in that case.
#!
#! Expected input stack
#!
#! [a1, a0, ...] | a = (a0, a1) ∈ Quadratic extension field over F_q, q = 2^64 - 2^32 + 1
#!
#! Expected output stack
#!
#! [a'1, a'0, ...] | a' = (a'0, a'1) ∈ Quadratic extension field over F_q, q = 2^64 - 2^32 + 1
#!
#! Following is what is checked after reading result of computation, performed outside of VM
#!
#! a  = (a0, a1)
#! a' = (a'0, a'1) ( = a ^ -1 )
#!
#! b  = a * a' ( mod P ) | P = irreducible polynomial x^2 - x + 2 over F_q, q = 2^64 - 2^32 + 1
#! assert b  = (1, 0) | (1, 0) is the multiplicative identity of extension field
export.inv
    adv.ext2inv
    adv_push.2
    dup.1
    dup.1

    movup.5
    movup.5
    exec.mul

    assertz
    assert
end
