use.std::mem

#! Computes the `ilog2(number)` and `2^(ilog2(number))`.
#!
#! number must be non-zero, otherwise this will error
#!
#! Stack transition:
#! Input: [number, ...]
#! Output: [ilog2, power_of_two, ...]
#!
#! Cycles:  12 + 9 * leading_zeros
export.ilog2_checked
  # prepare the stack (2 cycles)
  push.2147483648 # power_of_two from high to low bit
  push.0          # bit_pos from the most-signficant, `31-bit_pos` equals to ilog2
  # stack: [bit_pos, power_of_two, number, ...]

  dup.1 dup.3 u32checked_and eq.0 # (4 cycles)

  # find the first most-significant true bit (9 * leading_zero cycles)
  while.true
    add.1 swap div.2 swap  # (5 cycles)
    dup.1 dup.3 u32checked_and eq.0 # (4 cycles)
  end

  # compute ilog2 (4 cycles)
  push.31 swap sub
  # stack: [ilog2, power_of_two, number, ...]

  # drop number (2 cycles)
  movup.2 drop
  # stack: [ilog2, power_of_two, ...]
end

#! Loads the leaf at the absolute `pos` in the MMR.
#!
#! This MMR implementation supports only u32 positions.
#!
#! Stack transition:
#! Input: [pos, mmr_ptr, ...]
#! Output: [N, ...] where `N` is the leaf and `R` is the MMR peak that owns the leaf.
#!
#! Cycles: 65 + 9 * tree_position (where `tree_position` is 0-indexed bit position from most to least significant)
export.get
  # load the num_leaves of the MMR (2 cycles)
  dup.1 mem_load
  # stack: [num_leaves, pos, mmr_ptr, ...]

  # compute `num_leaves & pos`, this contains all peaks before `pos` (and maybe some after the owning peak) (3 cycles)
  dup.1 dup.1 u32checked_and
  # stack: [before_candidates, num_leaves, pos, mmr_ptr, ...]

  # compute `num_leaves - before_candidates`, this removes every peak before the owner (result may include peaks after owner) (4 cycles)
  dup.1 swap sub
  # stack: [owner_candidates, num_leaves, pos, mmr_ptr, ...]

  # compute `ilog2(owner_candidates)` and `2**depth`, it corresponds to the owner peak and its depth (13 + 9 * leading_zeros cycles)
  exec.ilog2_checked swap
  # stack: [owner_peak, depth, num_leaves, pos, mmr_ptr, ...]

  # compute `owner_peak - 1`, this mask corresponds to every peak after the owner (3 cycles)
  dup.0 sub.1
  # stack: [after_mask, owner_peak, depth, num_leaves, pos, mmr_ptr, ...]

  # compute `num_leaves & after_mask`, uses the mask to compute the actual after peaks (2 cycles)
  dup.3 u32checked_and
  # stack: [after_peaks, owner_peak, depth, num_leaves, pos, mmr_ptr, ...]

  # compute `num_leaves - (after_peaks + owner_peak)`, this computes the before peaks (5 cycles)
  add movup.2 swap sub
  # stack: [peaks_before, depth, pos, mmr_ptr, ...]

  # compute `pos - peaks_before`, this computes the relative_pos of the leaf w.r.t. the owner peak. (4 cycles)
  movup.2 dup.1 sub
  # stack: [relative_pos, peaks_before, depth, mmr_ptr, ...]

  # compute `popcount(peaks_before)`, the count peaks before the target to be skipped when loading from mem (2 cycles)
  swap u32checked_popcnt
  # stack: [peak_count, relative_pos, depth, mmr_ptr, ...]

  # compute `mmr_ptr + peak_count + 1` the target tree index (3 cycles)
  movup.3 add add.1
  # stack: [mmr_ptr, relative_pos, depth, ...]

  # load the target peak (6 cycles)
  padw movup.4 mem_loadw
  # stack: [P, relative_pos, depth, ...]

  # find the tree depth (2 cycles)
  movup.4 movup.5
  # stack: [depth, relative_pos, P, ...]

  # corner case, leaf values are not supported in the VM's Merkle store, so the
  # `mtree_get` instruction will fail for the single leaf case of the MMR. (2 cycles)
  dup.0 eq.0
  if.true
     drop drop # (2 cycles)
     # stack: [leaf, ...]
  else
     # verify and get the leaf (9 cycles)
      mtree_get
     # stack: [leaf, root, ...]

     # drop the root (5 cycles)
     swapw dropw
     # stack: [leaf, ...]
  end
end

#! Load the MMR peak data based on its hash.
#!
#! Input: [HASH, mmr_ptr, ...]
#! Output: [...]
#!
#! Where:
#!  - HASH: is the MMR peak hash, the hash is expected to be padded to an even
#!    length and to have a minimum size of 16 elements
#!  - The advice map must contain a key with HASH, and its value is
#!    `number_of_leaves || hash_data`, and hash_data is the data used to computed `HASH`
#!  - mmt_ptr: the memory location where the MMR data will be written to,
#!    starting with the MMR forest (its total leaves count) followed by its peaks
#!
#! Cycles: 156 + 9 * extra_peak_pair cycles
#!    where `extra_peak` is the number of peak pairs in addition to the first
#!    16, i.e. `round_up((num_of_peaks - 16) / 2)`
export.unpack
  # load the number_of_leaves and peaks to the advice_stack (0 cycles)
  adv.keyval
  # operand_stack => [HASH, mmr_ptr, ...]
  # advice_stack => [number_of_leaves, peaks*, ...]

  # load the size from the advice stack (1 cycles)
  adv_push.1
  # operand_stack => [forest, HASH, mmr_ptr, ...]
  # advice_stack => [peaks*, ...]

  # save the forest to memory (4 cycles)
  dup dup.6 mem_store
  # => [forest, HASH, mmr_ptr, ...]

  # count number of peaks (69 cycles)
  u32split u32unchecked_popcnt swap u32unchecked_popcnt add
  # => [count, HASH, mmr_ptr, ...]

  # the peaks are padded to a minimum length of 16 (10 cycles)
  push.16 u32unchecked_max
  # => [count_min, HASH, mmr_ptr, ...]

  # when the number of peaks is greater than 16, then they are padded to an even number (7 cycles)
  dup is_odd add
  # => [even_count_min, HASH, mmr_ptr, ...]

  # compute the end address including the padding data and forest (3 cycles)
  dup.5 add add.1
  # => [mmt_ptr_end, HASH, mmr_ptr, ...]

  # update the mmr_ptr to account for the size (2 cycles)
  movup.5 add.1
  # => [mmr_ptr+1, mmt_ptr_end, HASH, ...]

  # hash the first 16 words (28 cycles)
  padw padw padw
  adv_pipe adv_pipe adv_pipe adv_pipe
  adv_pipe adv_pipe adv_pipe adv_pipe
  # => [C, B, A, mmr_ptr+17, mmt_ptr_end, HASH, ...]

  # handle MMR with more than 16 elements (10 + 9 * words cycles)
  exec.mem::pipe_double_words_to_memory
  # => [C, B, A, mmr_ptr+17, HASH, ...]

  # drop anything but the hash result, word B (11 cycles)
  dropw swapw dropw movup.4 drop
  # => [B, HASH, ...]

  # assert on the resulting hash (11 cycles)
  assert_eqw
end
