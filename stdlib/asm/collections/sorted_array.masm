use.std::word

# CONSTANTS
# =================================================================================================
const.LOWERBOUND_ARRAY_EVENT=event("stdlib::collections::sorted_array::lowerbound_array")
const.LOWERBOUND_KEY_VALUE_EVENT=event("stdlib::collections::sorted_array::lowerbound_key_value")

# ===== ARRAY UTILITIES ============================================================================

#! Finds a value in a sorted array of words.
#!
#! This function will crash if the following conditions aren't met:
#! - words must be sorted in non-decreasing order,
#! - start_ptr, end_ptr are word-aligned
#! - `start_ptr <= end_ptr`
#!
#! Input:  [VALUE, start_ptr, end_ptr]
#! Output: [is_value_found, value_ptr, start_ptr, end_ptr]
#!
#! Cycles:
#!   Value exists: 46 cycles
#!   Value doesn't exist and the array is empty: 25 cycles
#!   Value doesn't exist and is smaller than all elements: 151 cycles
#!   Value doesn't exist and is larger than all elements: 149 cycles
#!   Value doesn't exist: 286 cycles
export.find_word
    # Call the non-deterministic lowerbound advisor (5 cycles)
    emit.LOWERBOUND_ARRAY_EVENT
    adv_push.2
    #=> [was_value_found, maybe_value_ptr, VALUE, start_ptr, end_ptr]

    if.true
        # assert `start_ptr <= maybe_value_ptr < end_ptr` (15 cycles)
        dup dup.6 u32assert2.err="maybe_value_ptr is not u32"
        u32gte assert.err="lowerbound_array invariant: maybe_value_ptr < start_ptr"
        dup dup.7 u32assert2.err="maybe_value_ptr is not u32"
        u32lt assert.err="lowerbound_array invariant: maybe_value_ptr >= end_ptr"
        #=> [maybe_value_ptr, VALUE, start_ptr, end_ptr]

        # dereference maybe_value_ptr (8 cycles)
        dup movdn.5 padw movup.4 mem_loadw
        #=> [MAYBE_VALUE, VALUE, maybe_value_ptr, start_ptr, end_ptr]

        # check if it matches the requested VALUE (15 cycles)
        exec.word::eq
        dup assert.err="lowerbound_array invariant: value_ptr not pointing to VALUE"
        #=> [is_value_found, maybe_value_ptr, start_ptr, end_ptr]
    else
        # the value was not found
        
        # pre-compute is_start_ptr, is_end_ptr to reduce the depth of the generated MAST
        # (6 cycles)
        dup.6 dup.1 eq
        #=> [is_end_ptr, maybe_value_ptr, VALUE, start_ptr, end_ptr]

        dup.6 dup.2 eq
        #=> [is_start_ptr, is_end_ptr, maybe_value_ptr, VALUE, start_ptr, end_ptr]

        if.true
            # the value was not found, and `maybe_value_ptr = start_ptr`

            if.true
                # the list is empty and `start_ptr = end_ptr` (both are equal to `maybe_value_ptr`)
                #=> [maybe_value_ptr = start_ptr = end_ptr, VALUE, start_ptr, end_ptr]

                # Prepare output (6 cycles)
                movdn.4 dropw push.0
                #=> [is_value_found = 0, value_ptr = start_ptr, start_ptr, end_ptr]
            else
                # the value was not found, `maybe_value_ptr = start_ptr`, and the list is not empty
                # assert `the value at start_ptr > VALUE`
                #=> [maybe_value_ptr = start_ptr, VALUE, start_ptr, end_ptr]

                movdn.4
                #=> [VALUE, maybe_value_ptr, start_ptr, end_ptr]

                # dereference maybe_value_ptr (7 cycles)
                dup.4 padw movup.4 mem_loadw
                #=> [FIRST_WORD, VALUE, maybe_value_ptr = start_ptr, start_ptr, end_ptr]

                # there was no match, the first array element must be larger than VALUE
                # (123 cycles)
                exec.word::lt
                assert.err="lowerbound_array invariant: start_ptr not greater than VALUE"

                # No value was found (1 cycle)
                push.0
                #=> [is_value_found = 0, maybe_value_ptr = start_ptr, start_ptr, end_ptr]
            end
        else
            if.true
                # the value was not found, `maybe_value_ptr = end_ptr`
                # the list is not empty, otherwise `maybe_value_ptr = start_ptr` and handled above
                # assert `the value before end_ptr < VALUE`

                #=> [maybe_value_ptr = end_ptr, VALUE, start_ptr, end_ptr]

                # fetch the last word in the array (10 cycles)
                dup movdn.5 sub.4 padw movup.4 mem_loadw
                #=> [LAST_WORD, VALUE, maybe_value_ptr = end_ptr, start_ptr, end_ptr]

                # there was no match, the last array element must be smaller than VALUE
                # (119 cycles)
                exec.word::gt
                assert.err="lowerbound_array invariant: last word not smaller than VALUE"

                # No value was found (1 cycle)
                push.0
                #=> [is_value_found = 0, maybe_value_ptr = end_ptr, start_ptr, end_ptr]
            else
                # The value was not found, and the maybe_value_ptr is neither the start nor the end
                # of the list. Make sure that:
                # - `the value at maybe_value_ptr-1 < VALUE`, and
                # - `the value at maybe_value_ptr > VALUE`
                #=> [maybe_value_ptr, VALUE, start_ptr, end_ptr]

                # Duplicate VALUE word (5 cycles)
                movdn.4 dupw
                #=> [VALUE, VALUE, maybe_value_ptr, start_ptr, end_ptr]

                # dereference maybe_value_ptr (8 cycles)
                padw dup.12 mem_loadw
                #=> [MAYBE_VALUE, VALUE, VALUE, maybe_value_ptr, start_ptr, end_ptr]
                
                # there was no match, MAYBE_VALUE must be larger than VALUE (123 cycles)
                exec.word::lt
                assert.err="lowerbound_array invariant: *maybe_value_ptr not greater than VALUE"

                # dereference `maybe_value_ptr-4` (11 cycles)
                padw dup.8 sub.4 mem_loadw
                #=> [MAYBE_VALUE_PREV, VALUE, maybe_value_ptr, start_ptr, end_ptr]
                
                # there was no match, MAYBE_VALUE_PREV must be smaller than VALUE (119 cycles)
                exec.word::gt
                assert.err="lowerbound_array invariant: *(maybe_value_ptr-4) not smaller than VALUE"
                
                # No value was found (1 cycle)
                push.0
                #=> [is_value_found = 0, maybe_value_ptr, start_ptr, end_ptr]
            end
        end
    end
end

# ===== KEY-VALUE UTILITIES ============================================================================

#! TODO: Docs.
#!
#! Inputs: [KEY, start_ptr, end_ptr]
#! Output: [is_key_found, key_ptr, start_ptr, end_ptr]
export.find_key_value
    push.0
    # => [use_half_key = 0, KEY, start_ptr, end_ptr]

    movdn.6
    # => [KEY, start_ptr, end_ptr, use_half_key]

    exec.find_key_value_inner
    # => [is_key_found, key_ptr, start_ptr, end_ptr]
end

#! TODO: Docs.
#!
#! Inputs: [key_prefix, key_suffix, start_ptr, end_ptr]
#! Output: [is_key_found, key_ptr, start_ptr, end_ptr]
export.find_half_key_value
    push.0 movdn.2
    # => [key_prefix, key_suffix, 0, start_ptr, end_ptr]

    push.0 movdn.2
    # => [key_prefix, key_suffix, 0, 0, start_ptr, end_ptr]
    # => [KEY, start_ptr, end_ptr]

    push.1
    # => [use_half_key = 0, KEY, start_ptr, end_ptr]

    movdn.6
    # => [KEY, start_ptr, end_ptr, use_half_key]

    exec.find_key_value_inner
    # => [is_key_found, key_ptr, start_ptr, end_ptr]
end

#! TODO: Update cycle counts.
#! TODO: Avoid local memory.
#!
#! Finds a key in a sorted array of (key, value) word tuples.
#!
#! This function will crash if the following conditions aren't met:
#! - keys must be sorted in non-decreasing order,
#! - start_ptr must be word-aligned
#! - end_ptr must be double-word-aligned with the start_ptr:
#!       `(end_ptr - start_ptr)` must be divisible by 8
#! - `start_ptr <= end_ptr`
#!
#! Input:  [KEY, start_ptr, end_ptr, use_half_key]
#! Output: [is_key_found, key_ptr, start_ptr, end_ptr]
#!
#! Cycles:
#!   Key exists: 56 cycles
#!   Key doesn't exist and the array is empty: 25 cycles
#!   Key doesn't exist and is smaller than all stored keys: 151 cycles
#!   Key doesn't exist and is larger than all stored keys: 149 cycles
#!   Key doesn't exist: 298 cycles
proc.find_key_value_inner.1
    # Call the non-deterministic lowerbound advisor (5 cycles)
    emit.LOWERBOUND_KEY_VALUE_EVENT
    # => [KEY, start_ptr, end_ptr, use_half_key]

    # store use_half_key for later
    movup.6 loc_store.0
    # => [KEY, start_ptr, end_ptr]

    adv_push.2
    #=> [was_key_found, maybe_key_ptr, KEY, start_ptr, end_ptr]

    if.true
        # assert `start_ptr <= maybe_key_ptr < end_ptr` (15 cycles)
        dup dup.6 u32assert2.err="maybe_key_ptr is not u32"
        u32gte assert.err="lowerbound_key_value invariant: maybe_key_ptr < start_ptr"
        dup dup.7 u32assert2.err="maybe_key_ptr is not u32"
        u32lt assert.err="lowerbound_key_value invariant: maybe_key_ptr >= end_ptr"
        #=> [maybe_key_ptr, KEY, start_ptr, end_ptr]

        # make sure maybe_key_ptr is pointing to a key, not value (10 cycles)
        dup dup.6 sub u32mod.8 assertz.err="lowerbound_key_value invariant: key_ptr must be double-word aligned with start_ptr"
        #=> [maybe_key_ptr, KEY, start_ptr, end_ptr]

        # dereference maybe_key_ptr (8 cycles)
        dup movdn.5
        #=> [maybe_key_ptr, KEY, maybe_key_ptr, start_ptr, end_ptr]

        loc_load.0 exec.load_key
        #=> [MAYBE_KEY, KEY, maybe_key_ptr, start_ptr, end_ptr]

        # check if it matches the requested KEY (15 cycles)
        exec.word::eq
        dup assert.err="lowerbound_key_value invariant: key_ptr not pointing to KEY"
        #=> [is_key_found, maybe_key_ptr, start_ptr, end_ptr]
    else
        # pre-compute is_start_ptr, is_end_ptr to reduce the depth of the
        # generated MAST (6 cycles)
        dup.6 dup.1 eq
        #=> [is_end_ptr, maybe_key_ptr, KEY, start_ptr, end_ptr]

        dup.6 dup.2 eq
        #=> [is_start_ptr, is_end_ptr, maybe_key_ptr, KEY, start_ptr, end_ptr]

        if.true
            # the key was not found, `maybe_key_ptr = start_ptr`

            if.true
                # the list is empty and `start_ptr = end_ptr` (both are equal to `maybe_value_ptr`)
                #=> [maybe_key_ptr = start_ptr = end_ptr, KEY, start_ptr, end_ptr]

                # Prepare output (6 cycles)
                movdn.4 dropw push.0
                #=> [is_key_found = 0, key_ptr = start_ptr, start_ptr, end_ptr]
            else
                # the key was not found, `maybe_key_ptr = start_ptr` and the list is not empty
                # assert `the key at start_ptr > KEY`
                #=> [maybe_key_ptr = start_ptr, KEY, start_ptr, end_ptr]

                dup movdn.5
                #=> [maybe_key_ptr, KEY, maybe_key_ptr, start_ptr, end_ptr]

                # dereference maybe_key_ptr (7 cycles)
                loc_load.0 exec.load_key
                #=> [FIRST_KEY, KEY, maybe_key_ptr = start_ptr, start_ptr, end_ptr]

                # there was no match, the first map element must be larger than KEY
                # (123 cycles)
                exec.word::lt
                assert.err="lowerbound_key_value invariant: start_ptr not greater than KEY"

                # No value was found (1 cycle)
                push.0
                #=> [is_key_found = 0, maybe_key_ptr = start_ptr, start_ptr, end_ptr]
            end
        else
            if.true
                # the key was not found, `maybe_key_ptr = end_ptr`
                # the list is not empty, otherwise `maybe_value_ptr = start_ptr` and handled above
                # assert `the key before end_ptr < KEY`

                #=> [maybe_key_ptr = end_ptr, KEY, start_ptr, end_ptr]

                # fetch the last key in the array (10 cycles)
                dup movdn.5 sub.8
                #=> [maybe_key_ptr-8, KEY, maybe_key_ptr, start_ptr, end_ptr]

                loc_load.0 exec.load_key
                #=> [LAST_KEY, KEY, maybe_key_ptr = end_ptr, start_ptr, end_ptr]

                # there was no match, the last map element must be smaller than KEY
                # (119 cycles)
                exec.word::gt
                assert.err="lowerbound_key_value invariant: last key-value pair not smaller than KEY"

                # No value was found (1 cycle)
                push.0
                #=> [is_key_found = 0, maybe_key_ptr = end_ptr, start_ptr, end_ptr]
            else
                # The key was not found, and the maybe_key_ptr is neither the start nor the end
                # of the list. Make sure that:
                # - `the key at maybe_key_ptr-1 < KEY`, and
                # - `the key at maybe_key_ptr > KEY`
                #=> [maybe_key_ptr, KEY, start_ptr, end_ptr]

                # make sure maybe_key_ptr is pointing to a key, not value (10 cycles)
                dup dup.6 sub u32assert2.err="maybe_key_ptr is not u32"
                u32mod.8 assertz.err="lowerbound_key_value invariant: key_ptr must be double-word aligned with start_ptr"

                # Duplicate KEY word (5 cycles)
                movdn.4 dupw
                #=> [KEY, KEY, maybe_key_ptr, start_ptr, end_ptr]

                # dereference maybe_key_ptr (8 cycles)
                dup.8 loc_load.0 exec.load_key
                #=> [MAYBE_KEY, KEY, KEY, maybe_key_ptr, start_ptr, end_ptr]

                # there was no match, `*maybe_key_ptr` must be larger than KEY (123 cycles)
                exec.word::lt
                assert.err="lowerbound_key_value invariant: MAYBE_KEY not greater than KEY"
                #=> [KEY, maybe_key_ptr, start_ptr, end_ptr]

                # dereference `maybe_key_ptr-8` (previous key) (11 cycles)
                dup.4 sub.8
                #=> [maybe_key_ptr-8, KEY, maybe_key_ptr, start_ptr, end_ptr]

                loc_load.0 exec.load_key
                #=> [MAYBE_KEY_PREV, KEY, maybe_key_ptr, start_ptr, end_ptr]
                
                # there was no match, `*(maybe_key_ptr-8)` must be smaller than KEY (119 cycles)
                exec.word::gt
                assert.err="lowerbound_key_value invariant: MAYBE_KEY_PREV not smaller than KEY"
                
                # No value was found (1 cycle)
                push.0
                #=> [is_key_found = 0, maybe_key_ptr, start_ptr, end_ptr]
            end
        end
    end
end

#! Inputs:  [use_half_key, key_ptr]
#! Outputs: [KEY]
proc.load_key
    swap
    # => [key_ptr, use_half_key]

    padw movup.4 mem_loadw
    # => [FULL_KEY, use_half_key]

    dupw
    # => [FULL_KEY, FULL_KEY, use_half_key]

    push.0 swap.4 drop
    # => [[key3, key2, key1, 0], FULL_KEY, use_half_key]

    push.0 swap.3 drop
    # => [[key3, key2, 0, 0], FULL_KEY, use_half_key]
    # => [HALF_KEY, FULL_KEY, use_half_key]

    movup.8
    # => [use_half_key, HALF_KEY, FULL_KEY]

    # If use_half_key HALF_KEY remains.
    # If !use_half_key FULL_KEY remains.
    cdropw
    # => [KEY]
end