# Constant value for empty sub-tree root at depth 16
const.EMPTY_16_0=17483286922353768131
const.EMPTY_16_1=353378057542380712
const.EMPTY_16_2=1935183237414585408
const.EMPTY_16_3=4820339620987989650

# Constant value for empty sub-tree root at depth 32
const.EMPTY_32_0=11677748883385181208
const.EMPTY_32_1=15891398395707500576
const.EMPTY_32_2=3790704659934033620
const.EMPTY_32_3=2126099371106695189

# Constant value for empty sub-tree root at depth 48
const.EMPTY_48_0=10650694022550988030
const.EMPTY_48_1=5634734408638476525
const.EMPTY_48_2=9233115969432897632
const.EMPTY_48_3=1437907447409278328

# HELPER METHODS
# =================================================================================================

#! Extracts 16 most significant bits from the passed-in value.
#!
#! Input:  [v, ...]
#! Output: [v >> 48, ...]
#!
#! Cycles: 6
proc.get_top_16_bits
    u32split
    swap drop
    u32unchecked_shr.16
end

#! Extracts 32 most significant bits from the passed-in value.
#!
#! Input:  [v, ...]
#! Output: [v >> 32, ...]
#!
#! Cycles: 3
proc.get_top_32_bits
    u32split swap drop
end

#! Extracts 48 most significant bits from the passed-in value.
#!
#! Input:  [v, ...]
#! Output: [v >> 16, ...]
#!
#! Cycles: 9
proc.get_top_48_bits
    u32split
    swap
    u32unchecked_shr.16
    swap
    mul.65536
    add
end

# GET
# =================================================================================================

#! Get the leaf value for depth 16.
#!
#! Input:  [K, R, ...]
#! Output: [V, R, ...]
#!
#! Cycles: 85
proc.get_16.2
    # compute index of the node by extracting top 16 bits from the key (8 cycles)
    dup exec.get_top_16_bits movdn.4
    # => [K, i, R, ...]

    # save [0, 0, 0, 0] into loc[0] (7 cycles)
    padw loc_storew.0

    # load Ka from advice provider and compare it to K (16 cycles)
    # Ka is expected to be the key for the node stored at depth 16; it could be either equal
    # to K, or could be something different
    adv_loadw eqw
    # => [Ka ?= K, Ka, K, i, R, ...]

    # move the comparison result out of the way (1 cycle)
    movdn.8
    # => [Ka, K, Ka ?= K, i, R, ...]

    # load the value from adv provider and prepare hash (6 cycles)
    push.0.16.0.0 swapw.2 adv_loadw
    # => [V, Ka, D, Ka ?= K, i, R, ...]

    # save the value into loc[1] (4 cycles)
    loc_storew.1
    # => [V, Ka, D, Ka ?= K, i, R, ...]

    # compute the value of the node as hash(K, V, domain=16) (10 cycles)
    hperm dropw swapw dropw
    # => [N, Ka ?= K, i, R, ...]

    # push the root of the empty subtree (5 cycles)
    push.EMPTY_16_0.EMPTY_16_1.EMPTY_16_2.EMPTY_16_3 swapw
    # => [N, E, Ka ?= K, i, R, ...]

    # read the flag if the node is empty subtree (5 cycles)
    adv_push.1 movdn.8 dup.8
    # => [not_empty?, N, E, not_empty?, Ka ?= K, i, R, ...]

    # conditionally select node (5 cycles)
    cdropw
    # => [N', not_empty?, Ka ?= K, i, R, ...]

    # compute the flag indicating if value is not zero (3 cycles)
    movup.5 movup.5 and
    # => [take_val?, N', i, R, ...]

    # move take_val out of the way (4 cycles)
    movdn.9
    # => [N', i, R, take_val?, ...]

    # verify Merkle path from N' to R (3 cycles)
    push.16 movdn.4 mtree_verify
    # => [N', 16, i, R, take_val?, ...]

    # reorganize stack (4 cycles)
    movup.4 drop movup.4 drop movup.8
    # => [take_val?, N', R, ...]

    # compute the address of the return value based on `take_val` and return it, being either
    # zero or V (3 cycles)
    locaddr.0 add
    # => [addr, N', R, ...]

    # load the selected value and return (1 cycle)
    mem_loadw
    # => [V, R, ...]
end

#! Get the leaf value for depth 32.
#!
#! Input:  [K, R, ...]
#! Output: [V, R, ...]
#!
#! Cycles: 81
proc.get_32.2
    # compute index of the node by extracting top 16 bits from the key (4 cycles)
    dup u32split movdn.5 drop
    # => [K, i, R, ...]

    # save [0, 0, 0, 0] into loc[0] (7 cycles)
    padw loc_storew.0

    # load Ka from advice provider and compare it to K (16 cycles)
    # Ka is expected to be the key for the node stored at depth 32; it could be either equal
    # to K, or could be something different
    adv_loadw eqw
    # => [Ka ?= K, Ka, K, i, R, ...]

    # move the comparison result out of the way (1 cycle)
    movdn.8
    # => [Ka, K, Ka ?= K, i, R, ...]

    # load the value from adv provider and prepare hash (6 cycles)
    push.0.32.0.0 swapw.2 adv_loadw
    # => [V, Ka, D, Ka ?= K, i, R, ...]

    # save the value into loc[1] (4 cycles)
    loc_storew.1
    # => [V, Ka, D, Ka ?= K, i, R, ...]

    # compute the value of the node as hash(K, V, domain=32) (10 cycles)
    hperm dropw swapw dropw
    # => [N, Ka ?= K, i, R, ...]

    # push the root of the empty subtree (5 cycles)
    push.EMPTY_32_0.EMPTY_32_1.EMPTY_32_2.EMPTY_32_3 swapw
    # => [N, E, Ka ?= K, i, R, ...]

    # read the flag if the node is empty subtree (5 cycles)
    adv_push.1 movdn.8 dup.8
    # => [not_empty?, N, E, not_empty?, Ka ?= K, i, R, ...]

    # conditionally select node (5 cycles)
    cdropw
    # => [N', not_empty?, Ka ?= K, i, R, ...]

    # compute the flag indicating if value is not zero (3 cycles)
    movup.5 movup.5 and
    # => [take_val?, N', i, R, ...]

    # move take_val out of the way (4 cycles)
    movdn.9
    # => [N', i, R, take_val?, ...]

    # verify Merkle path from N' to R (3 cycles)
    push.32 movdn.4 mtree_verify
    # => [N', 32, i, R, take_val?, ...]

    # reorganize stack (4 cycles)
    movup.4 drop movup.4 drop movup.8
    # => [take_val?, N', R, ...]

    # compute the address of the return value based on `take_val` and return it, being either
    # zero or V (3 cycles)
    locaddr.0 add
    # => [addr, N', R, ...]

    # load the selected value and return (1 cycle)
    mem_loadw
    # => [V, R, ...]
end

#! Get the leaf value for depth 48.
#!
#! Input:  [K, R, ...]
#! Output: [V, R, ...]
#!
#! Cycles: 88
proc.get_48.2
    # compute index of the node by extracting top 48 bits from the key (11 cycles)
    dup exec.get_top_48_bits movdn.4
    # => [K, i, R, ...]

    # save [0, 0, 0, 0] into loc[0] (7 cycles)
    padw loc_storew.0

    # load Ka from advice provider and compare it to K (16 cycles)
    # Ka is expected to be the remaining key for the node stored at depth 48; it could be either
    # equal to K, or could be something different
    adv_loadw eqw
    # => [Ka ?= K, Ka, K, i, R, ...]

    # move the comparison result out of the way (1 cycle)
    movdn.8
    # => [Ka, K, Ka ?= K, i, R, ...]

    # load the value from adv provider and prepare hash (6 cycles)
    push.0.48.0.0 swapw.2 adv_loadw
    # => [V, Ka, D, Ka ?= K, i, R, ...]

    # save the value into loc[1] (4 cycles)
    loc_storew.1
    # => [V, Ka, D, Ka ?= K, i, R, ...]

    # compute the value of the node as hash(K, V, domain=48) (10 cycles)
    hperm dropw swapw dropw
    # => [N, Ka ?= K, i, R, ...]

    # push the root of the empty subtree (5 cycles)
    push.EMPTY_48_0.EMPTY_48_1.EMPTY_48_2.EMPTY_48_3 swapw
    # => [N, E, Ka ?= K, i, R, ...]

    # read the flag if the node is empty subtree (5 cycles)
    adv_push.1 movdn.8 dup.8
    # => [not_empty?, N, E, not_empty?, Ka ?= K, i, R, ...]

    # conditionally select node (5 cycles)
    cdropw
    # => [N', not_empty?, Ka ?= K, i, R, ...]

    # compute the flag indicating if value is not zero (3 cycles)
    movup.5 movup.5 and
    # => [take_val?, N', i, R, ...]

    # move take_val out of the way (4 cycles)
    movdn.9
    # => [N', i, R, take_val?, ...]

    # verify Merkle path from N' to R (3 cycles)
    push.48 movdn.4 mtree_verify
    # => [N', 48, i, R, take_val?, ...]

    # reorganize stack (4 cycles)
    movup.4 drop movup.4 drop movup.8
    # => [take_val?, N', R, ...]

    # compute the address of the return value based on `take_val` and return it, being either
    # zero or V (3 cycles)
    locaddr.0 add
    # => [addr, N', R, ...]

    # load the selected value and return (1 cycle)
    mem_loadw
    # => [V, R, ...]
end

#! Returns the value stored under the specified key in a Sparse Merkle Tree with the specified root.
#!
#! If the value for a given key has not been set, the returned `V` will consist of all zeroes.
#!
#! Input:  [K, R, ...]
#! Output: [V, R, ...]
#!
#! Depth 16: 91 cycles
#! Depth 32: 87 cycles
#! Depth 48: 94 cycles
#! Depth 64: unimplemented
export.get
    # invoke adv and fetch target depth flags
    adv.push_smtget adv_push.2
    # => [d ∈ {16, 32}, d ∈ {16, 48}, K, R, ...]

    # call the inner procedure depending on the depth
    if.true
        if.true
            # depth 16
            exec.get_16
        else
            # depth 32
            exec.get_32
        end
    else
        if.true
            # depth 48
            exec.get_48
        else
            # depth 64
            # currently not implemented
            push.0 assert
        end
    end
    # => [V, R, ...]
end

# INSERT
# =================================================================================================

#! Updates a leaf node at depths 16, 32, or 48.
#!
#! Input:  [d, idx, V, K, R, ...];
#! Output: [V_old, R_new, ...]
#!
#! Where:
#! - R is the initial root of the TSMT, and R_new is the new root of the TSMT.
#! - d, idx are the depth and index (at that depth) of the leaf node to be updated.
#! - K, V are the key-value pair for the leaf node where V is a new value for key K.
#! - V_old is the value previously stored under key K.
#!
#! This procedure succeeds only if:
#! - Node to be replaced at (d, idx) is a leaf node for the same key K.
#!
#! Cycles: 101
proc.update_16_32_48.2
    # save [idx, d, 0, 0] in loc[0] (5 cycles)
    push.0.0 loc_storew.0
    # => [0, 0, d, idx, V, K, R, ...]

    # prepare the stack for computing N = hash([K, V], domain=d), and also save K into loc[1]
    # (10 cycles)
    movdn.3 movup.2 drop push.0 swapw.2 loc_storew.1 swapw
    # => [V, K, 0, 0, d, 0, R, ...]

    # compute the hash of the node N = hash([K, V], domain=d) - (1 cycle)
    hperm
    # => [X, N, X, R, ...]

    # prepare the stack for the mtree_set operation (8 cycles)
    swapw.3 swapw swapw.2 loc_loadw.0 drop drop
    # => [d, idx, R, N, X, ...]

    # insert the new leaf node into the tree at the specified index/depth; this also leaves the
    # previous value of the node on the stack (29 cycle)
    mtree_set
    # => [N_old, R_new, X, ...]

    # verify that N_old is a leaf node for the same key K

    # prepare the stack for computing E = hash([K, V_old], domain=d); value of V_old is read
    # from the advice provider and is saved into loc[0] (21 cycles)
    swapw.2 loc_loadw.0 movdn.3 push.0 movup.3 push.0.0.0 loc_loadw.1 adv_push.4 loc_storew.0
    # => [V_old, K, 0, 0, d, 0, R_new, N_old, ...]

    # compute E = hash([K, V_old], domain=d)
    # (10 cycle)
    hperm dropw swapw dropw
    # => [E, R_new, N_old, ...]

    # make sure E and N_old are the same (14 cycles)
    swapw swapw.2
    repeat.4
        dup.4 assert_eq
    end
    # => [E, R_new, ...]

    # load the old value (which we saved previously) onto the stack (3 cycles)
    loc_loadw.0
    # => [V_old, R_new, ...]
end

#! Inserts a new leaf node at depth 16.
#!
#! Input: [V, K, R, ...];
#! Output:[0, 0, 0, 0, R_new, ...]
#!
#! Where:
#! - R is the initial root of the TSMT, and R_new is the new root of the TSMT.
#! - K and V is the key-value pair for the leaf node to be inserted.
#!
#! This procedure succeeds only if:
#! - Node to be replaced at depth 16 is a root of an empty subtree.
#!
#! Cycles: 73
proc.insert_16
    # extract 16-bit index from the key (8 cycles)
    swapw dup exec.get_top_16_bits
    # => [idx, K, V, R, ...]

    # prepare the stack for computing leaf node value (6 cycles)
    movdn.8 push.0.16.0.0 swapw.2
    # => [V, K, 0, 0, 16, 0, idx, R, ...]

    # compute leaf node value as N = hash([K, V], domain=16) (10 cycles)
    hperm dropw swapw dropw
    # => [N, idx, R, ...]

    # prepare the stack for mtree_set operation (4 cycles)
    swapw movup.8 movdn.4 push.16
    # => [16, idx, R, N, ...]

    # insert the node into the tree at depth 16; this also leaves the old value of the node on the
    # stack (29 cycle)
    mtree_set
    # => [N_old, R_new, ...]

    # verify that the old value of the node was a root of an empty subtree for depth 16 (12 cycles)
    push.EMPTY_16_3 assert_eq
    push.EMPTY_16_2 assert_eq
    push.EMPTY_16_1 assert_eq
    push.EMPTY_16_0 assert_eq

    # put the return value onto the stack and return (4 cycles)
    padw
    # => [0, 0, 0, 0, R_new, ...]
end

#! Inserts a new leaf node at depth 32.
#!
#! Input: [V, K, R, ...];
#! Output:[0, 0, 0, 0, R_new, ...]
#!
#! Where:
#! - R is the initial root of the TSMT, and R_new is the new root of the TSMT.
#! - K, V is the key-value pair for the leaf node to be inserted into the TSMT.
#!
#! This procedure consists of two high-level steps:
#! - First, insert N = hash([K, V], domain=32) into a subtree with root P, where P is the
#!   internal node at depth 16 on the path to the new leaf node. This outputs the new root
#!   of the subtree P_new.
#! - Then, insert P_new into the TSMT with root R.
#!
#! We do this to minimize the number of hashes consumed by the procedure for Merkle path
#! verification. Specifically, Merkle path verification will require exactly 64 hashes.
#!
#! This procedure succeeds only if:
#! - Node at depth 16 is an internal node.
#! - Node at depth 32 is a root of an empty subtree.
#!
#! Cycles: 154
proc.insert_32.2
    # load the value of P from the advice provider (5 cycles)
    adv_push.4 swapw.2
    # => [K, V, P, R, ...]

    # save k3 into loc[0][0] (4 cycles)
    dup loc_store.0
    # => [K, V, P, R, ...]

    # prepare the stack for computing N = hash([K, V], domain=32) - (5 cycles)
    push.0.32.0.0 swapw.2
    # => [V, K, 0, 0, 32, 0, P, R, ...]

    # compute N = hash([K, V], domain=32) (1 cycle)
    hperm
    # => [X, N, X, P, R, ...]

    # save P into loc[1] to be used later (5 cycles)
    swapw.3 loc_storew.1
    # => [P, N, X, X, R, ...]

    # make sure P is not a root of an empty subtree at depth 16 (17 cycles)
    dup push.EMPTY_16_3 eq
    dup.2 push.EMPTY_16_2 eq
    dup.4 push.EMPTY_16_1 eq
    dup.6 push.EMPTY_16_0 eq
    and and and assertz
    # => [P, N, X, X, R, ...]

    # load k3 from memory, extract upper 32 bits from it and split them into two 16-bit values
    # such that the top 16-bits are in idx_hi and the next 16 bits are in idx_lo (9 cycles)
    loc_load.0 exec.get_top_32_bits u32unchecked_divmod.65536
    # => [idx_lo, idx_hi, P, N, X, X, R, ...]

    # save idx_hi into loc[0][0] to be used later (5 cycles)
    swap loc_store.0
    # => [idx_lo, P, N, X, X, R, ...]

    # replace node at idx_lo in P with N, the old value of the node is left on the stack; this also
    # proves that P is a leaf node because a leaf node cannot have children at depth 16 (30 cycles)
    push.16 mtree_set
    # => [N_old, P_new, X, X, R, ...]

    # make sure that N_old is a root of an empty subtree at depth 32 (12 cycles)
    push.EMPTY_32_3 assert_eq
    push.EMPTY_32_2 assert_eq
    push.EMPTY_32_1 assert_eq
    push.EMPTY_32_0 assert_eq
    # => [P_new, X, X, R, ...]

    # prepare the stack for mtree_set operation against R; here we load idx_hi from loc[0][0]
    # (11 cycles)
    swapw.2 dropw swapw.2 loc_load.0 push.16
    # => [16, idx_hi, R, P_new, X, ...]

    # insert P_new into tree with root R at depth 16 and idx_hi index (29 cycles)
    mtree_set
    # => [P_old, R_new, X, ...]

    # load previously saved P to compare it with P_old (6 cycles)
    swapw swapw.2 loc_loadw.1
    # => [P, P_old, R_new, ...]

    # make sure P and P_old are the same (11 cycles)
    assert_eqw
    # => [R_new, ...]

    # put the return value onto the stack and return (4 cycles)
    padw
    # => [0, 0, 0, 0, R_new, ...]
end

#! Inserts a new leaf node at depth 48.
#!
#! Input: [V, K, R, ...];
#! Output:[0, 0, 0, 0, R_new, ...]
#! 
#! This procedure is nearly identical to the insert_32 procedure above, adjusted for the use of
#! constants and idx_hi/idx_lo computation. It may be possible to combine the two at the expense
#! of extra 10 - 20 cycles.
proc.insert_48.2
    # load the value of P from the advice provider (5 cycles)
    adv_push.4 swapw.2
    # => [K, V, P, R, ...]

    # save k3 into loc[0][0] (4 cycles)
    dup loc_store.0
    # => [K, V, P, R, ...]

    # prepare the stack for computing N = hash([K, V], domain=48) - (5 cycles)
    push.0.48.0.0 swapw.2
    # => [V, K, 0, 0, 48, 0, P, R, ...]

    # compute N = hash([K, V], domain=48) (1 cycle)
    hperm
    # => [X, N, X, P, R, ...]

    # save P into loc[1] to be used later (5 cycles)
    swapw.3 loc_storew.1
    # => [P, N, X, X, R, ...]

    # make sure P is not a root of an empty subtree at depth 32 (17 cycles)
    dup push.EMPTY_32_3 eq
    dup.2 push.EMPTY_32_2 eq
    dup.4 push.EMPTY_32_1 eq
    dup.6 push.EMPTY_32_0 eq
    and and and assertz
    # => [P, N, X, X, R, ...]

    # load k3 from memory, extract upper 48 bits from it and split them into two values such that
    # the top 32-bits are in idx_hi and the next 16 bits are in idx_lo (9 cycles)
    loc_load.0 u32split swap u32unchecked_divmod.65536 drop
    # => [idx_lo, idx_hi, P, N, X, X, R, ...]

    # save idx_hi into loc[0][0] to be used later (5 cycles)
    swap loc_store.0
    # => [idx_lo, P, N, X, X, R, ...]

    # replace node at idx_lo in P with N, the old value of the node is left on the stack; this also
    # proves that P is a leaf node because a leaf node cannot have children at depth 16 (30 cycles)
    push.16 mtree_set
    # => [N_old, P_new, X, X, R, ...]

    # make sure that N_old is a root of an empty subtree at depth 48 (12 cycles)
    push.EMPTY_48_3 assert_eq
    push.EMPTY_48_2 assert_eq
    push.EMPTY_48_1 assert_eq
    push.EMPTY_48_0 assert_eq
    # => [P_new, X, X, R, ...]

    # prepare the stack for mtree_set operation against R; here we load idx_hi from loc[0][0]
    # (11 cycles)
    swapw.2 dropw swapw.2 loc_load.0 push.32
    # => [32, idx_hi, R, P_new, X, ...]

    # insert P_new into tree with root R at depth 32 and idx_hi index (29 cycles)
    mtree_set
    # => [P_old, R_new, X, ...]

    # load previously saved P with P_old to make sure they are the same (6 cycles)
    swapw swapw.2 loc_loadw.1
    # => [P, P_old, R_new, ...]

    # make sure P and P_old are the same (11 cycles)
    assert_eqw
    # => [R_new, ...]

    # put the return value onto the stack and return (4 cycles)
    padw
    # => [0, 0, 0, 0, R_new, ...]
end

#! Replaces a leaf node at depth 16 with a subtree containing two leaf nodes at depth 32 such that
#! one of the leaf nodes commits to a key-value pair equal to the leaf node at depth 16, and the
#! other leaf node comments to the key-value pair being inserted.
#!
#! Input: [V, K, R, ...];
#! Output:[0, 0, 0, 0, R_new, ...]
#!
#! Where:
#! - R is the initial root of the TSMT, and R_new is the new root of the TSMT.
#! - K, V is the key-value pair for the leaf node to be inserted into the TSMT.
#!
#! This procedure consists of three high-level steps:
#! - First, insert M = hash([K_e, V_e], domain=32) into an empty subtree at depth 16, where K_e
#!   and V_e are the key-value pair for the existing leaf node. This outputs the new root
#!   of the subtree T.
#! - Then, insert N = hash([K, V], domain=32) into a subtree with root T. This outputs the new
#!   root of the subtree P_new.
#! - Then, insert P_new into the TSMT with root R.
#!
#! This procedure succeeds only if:
#! - Node at depth 16 is a leaf node.
#! - The key in this node has a common prefix with the key to be inserted. This common prefix
#!   must be greater or equal to 16, but smaller than 32.
#!
#! Cycles: 216
proc.replace_16.3
    # save k3 into loc[0][0] - (6 cycles)
    swapw dup loc_store.0
    # => [K, V, R, ...]

    # compute N = hash([K, V], domain=32) - (6 cycles)
    push.0.32.0.0 swapw.2 hperm
    # => [X, N, X, R, ...]

    # load the key associated with the existing leaf P from the advice provider and save it in
    # loc[1] - (5 cycles)
    adv_loadw loc_storew.1
    # => [K_e, N, X, R, ...]

    # load the value associated with the existing leaf P from the advice provider and save it in
    # loc[2] - (10 cycles)
    push.0.16.0.0 swapw.2 swapw.3 adv_loadw loc_storew.2
    # => [V_e, K_e, 0, 0, 16, 0, N, R, ...]

    # compute P = hash([K_e, V_e], domain=16); we will use this later to prove correct execution
    # of mtree_set instruction (1 cycle)
    hperm
    # => [X, P, X, N, R, ...]

    # load K_e from loc[1] - (9 cycles)
    push.0.32.0.0 swapw loc_loadw.1
    # => [K_e, 0, 0, 32, 0, P, X, N, R, ...]

    # extract from the most significant element of K_e (i.e., ke_3) two most significant 16-bit
    # limbs: idx_hi_eidx_lo_e - (6 cycles)
    dup exec.get_top_32_bits u32unchecked_divmod.65536
    # => [idx_lo_e, idx_hi_e, K_e, 0, 0, 32, 0, P, X, N, R, ...]

    # load k3 from loc[0][0] and also extract the two most significant 16-bit limbs from it
    # (8 cycles)
    loc_load.0 exec.get_top_32_bits u32unchecked_divmod.65536
    # => [idx_lo, idx_hi, idx_lo_e, idx_hi_e, K_e, 0, 0, 32, 0, P, X, N, R, ...]

    # make sure the top 16 bits of both keys are the same (4 cycles)
    movup.3 dup.2 assert_eq
    # => [idx_lo, idx_hi, idx_lo_e, K_e, 0, 0, 32, 0, P, X, N, R, ...]

    # make sure that the next 16 bits of the keys are not the same; this proves that the keys
    # have the same 16-bit prefix, but not the same 32-bit prefix (6 cycles)
    movup.2 dup dup.2 neq assert
    # => [idx_lo_e, idx_lo, idx_hi, K_e, 0, 0, 32, 0, P, X, N, R, ...]

    # save [idx_hi, idx_lo, idx_lo_e, 0] into loc[0] - (4 cycles)
    push.0 loc_storew.0
    # => [0, idx_lo_e, idx_lo, idx_hi, K_e, 0, 0, 32, 0, P, X, N, R, ...]

    # load the value V_e from loc[2] and compute M = hash([K_e, K_e], domain=32) - (4 cycles)
    loc_loadw.2 hperm
    # => [X, M, X, P, X, N, R, ...]

    # load the indexes from loc[0] and drop all but idx_lo_e from the stack (7 cycles)
    loc_loadw.0 drop movdn.2 drop drop
    # => [idx_lo_e, M, X, P, X, N, R, ...]    

    # push the root of an empty subtree at depth 16 onto the stack (4 cycles)
    push.EMPTY_16_0.EMPTY_16_1.EMPTY_16_2.EMPTY_16_3
    # => [E16, idx_lo_e, M, X, P, X, N, R, ...]

    # insert node M into the empty subtree at depth 16; this leaves the new root of the
    # subtree T together with the root of an empty subtree at depth 32 - (31 cycles)
    movup.4 push.16 mtree_set
    # => [E32, T, X, P, X, N, R, ...]

    # drop the E32 root as we don't need it, and arrange the stack for inserting the next
    # leaf (12 cycles)
    dropw swapw dropw swapw swapw.3 swapw.2
    # => [X, N, T, P, R, ...]

    # load the indexes from loc[0] and drop all but idx_lo from the stack (7 cycles)
    loc_loadw.0 drop drop swap drop
    # => [idx_lo, N, T, P, R, ...]

    # insert node N into the subtree with root T at depth 16; this leaves the new root of the
    # subtree P_new on the stack together with the root of an empty subtree at depth 32 - (30 cycles)
    push.16 mtree_set
    # => [E32, P_new, P, R, ...]

    # prepare the stack for an mtree_set operation against R; we drop the E32 value as we don't
    # need it; the index idx_hi is loaded from memory (10 cycles)
    dropw swapw swapw.2 loc_load.0 push.16
    # => [16, idx_hi, R, P_new, P, ...]

    # insert node P_new into the TSMT at depth 16; this puts the new value of TSMT root onto the
    # stack together with the old value of the node at depth 16 - (29 cycles)
    mtree_set
    # => [P_old, R_new, P, ...]

    # make sure P (which we computed as hash([K_e, V_e], domain=16)) and P_old are the same
    # (13 cycles)
    swapw swapw.2 assert_eqw
    # => [R_new, ...]

    # put the return value onto the stack and return (4 cycles)
    padw
    # => [0, 0, 0, 0, R_new, ...]
end

#! Inserts the specified value into a Sparse Merkle Tree with the specified root under the
#! specified key.
#!
#! The value previously stored in the SMT under this key is left on the stack together with
#! the updated tree root.
#!
#! This assumes that the value is not [ZERO; 4]. If it is, the procedure fails.
#!
#! Input: [V, K, R, ...];
#! Output:[V_old, R_new, ...]
#!
#! Cycles:
#! - Update existing leaf:
#!   - Depth 16: 129
#!   - Depth 32: 126
#!   - Depth 48: 131
#! - Insert new leaf:
#!   - Depth 16: 100
#!   - Depth 32: 181
#!   - Depth 48: 181
#! - Replace a leaf with a subtree:
#!   - Depth 32: 243
#!   - Depth 48: TODO
export.insert
    # make sure the value is not [ZERO; 4] (17 cycles)
    repeat.4
        dup.3 eq.0
    end
    and and and assertz
    # => [V, K, R, ...]

    # arrange the data needed for the insert procedure on the advice stack and move the
    # first 4 flags onto the operand stack; meaning of the flags f0, f1, and f2 depends
    # on what type of insert is being executed (4 cycles)
    adv.push_smtinsert adv_push.4
    # => [is_update, f0, f1, f2, V, K, R, ...]

    # call the inner procedure depending on the type of insert and depth
    if.true # --- update leaf -------------------------------------------------
        # => [is_16_or_32, is_16_or_48, ZERO, V, K, R, ...]
        if.true 
            if.true # --- update a leaf node at depth 16 ---
                drop
                # => [V, K, R, ...]

                # (cycles 8)
                dup.4 exec.get_top_16_bits
                push.16
                # => [16, idx, V, K, R, ...]

                exec.update_16_32_48
            else # --- update a leaf node at depth 32 ---
                drop
                # => [V, K, R, ...]

                #(5 cycles)
                dup.4 exec.get_top_32_bits
                push.32
                # => [32, idx, V, K, R, ...]

                exec.update_16_32_48
            end
        else
            if.true # --- update a leaf node at depth 48 ---
                drop
                # => [V, K, R, ...]

                # (10 cycles)
                dup.4 exec.get_top_48_bits
                push.48
                # => [48, idx, V, K, R, ...]

                exec.update_16_32_48
            else
                # depth 64 - currently not implemented
                push.0 assert
            end
        end
    else
        # => [is_simple_insert, is_16_or_32, is_16_or_48, V, K, R, ...]
        if.true # --- inset new leaf ----------------------------------------------
            if.true
                if.true
                    exec.insert_16
                else
                    exec.insert_32
                end
            else
                if.true
                    exec.insert_48
                else
                    # depth 64 - currently not implemented
                    push.0 assert
                end
            end
        else # --- replace leaf with subtree ----------------------------------
            if.true
                if.true
                    # replace a leaf node at depth 16 with a subtree containing
                    # two leaf nodes at depth 32.
                    exec.replace_16
                else
                    # not implemented
                    push.0 assert
                end
            else
                # not implemented
                push.0 assert
            end
        end
    end

    # => [V_old, R_new, ...]
end
