# Constant value for the depth at which leaves sit
const.LEAF_DEPTH=64

# SET
# =================================================================================================

#! Inserts or removes a value associated with the given key. The leaf to which we're inserting is
#! guaranteed to be empty.
#!
#! Inputs:  
#!   Operand stack: [V, K, R, ...]
#!
#! Outputs: 
#!   Operand stack: [V_old, R_new, ...]
proc.set_empty_leaf
    # Check if we're inserting the empty value
    padw eqw

    if.true
        # Inserting an empty value; this is a no-op
        #=> [ZERO, V, K, R, ...]
        
        # Prepare stack for return
        dropw swapw dropw
        #=> [V, R, ...]
    else
        # Inserting a non-empty value
        dropw
        #=> [V, K, R, ...]

        # Update advice map with new leaf preimage
        # adv_map[hash(K, V)] = [K, V]
        adv.insert_hdword
        #=> [V, K, R]

        # Compute hash([K, V]); the new node value (NV)
        dupw.1 swapw hmerge
        # => [NV, K, R]

        # Prepare stack for `mtree_set`
        movupw.2 dup.8 push.LEAF_DEPTH
        #=> [depth, K[0], R, NV, K]

        # Insert node in Merkle store
        mtree_set
        #=> [V_in_leaf, R_new, K]

        # Check that V_in_leaf is indeed empty
        padw assert_eqw
        #=> [R_new, K]

        # Prepare stack for return
        swapw dropw padw
        #=> [ZERO, R_new]
    end
end

#! Inserts a value at the given key. The leaf to which we're inserting is
#! guaranteed to hold a single key-value pair (provided on the advice stack).
#!
#! Inputs: 
#!   Operand stack: [V, V_old, K, R, ...]
#!
#! Outputs:
#!   Operand stack: [V_old, R_new, ...]
proc.insert_single_leaf
    swapw
    # => [V_old, V, K, R, ...] 

    # Note: We don't need the `V_old_in_leaf` value.
    # It is sufficient to deal with `V_old` from `adv.push_smtpeek`, and check its authenticity
    # at the end after inserting with `mtree_set`
    adv_push.8 dropw
    # => [K_in_leaf, V_old, V, K, R]

    # Check if the key stored in the leaf is the same
    dupw.3 eqw
    # => [K_in_leaf==K, K, K_in_leaf, V_old, V, K, R]

    if.true
        # Leaf stays a "single" variant

        dropw dropw
        # => [V_old, V, K, R]

        # Update advice map
        movdnw.3 adv.insert_hdword
        # => [V, K, R, V_old]

        # Compute hash([K, V]); the new node value (NV)
        dupw.1 swapw hmerge
        # => [NV, K, R, V_old]

        # Prepare stack to update Merkle store
        movupw.2 dup.8 push.LEAF_DEPTH
        # => [depth, K[0], R, NV, K, V_old]

        # Update Merkle store
        mtree_set
        # => [NV_old, R_new, K, V_old_from_peek]

        # Confirm that claimed `V_old` from `adv.push_smtpeek` is correct by checking if 
        # `[K, V_old]` hashes to `NV_old`
        movupw.2 dupw.3 hmerge assert_eqw
        # => [R_new, V_old_from_peek]

        # Clean up stack for return
        swapw
        # => [V_old, R_new]
    else
        # Leaf becomes a Multiple kv-pair case
        # TODO (fail for now)
        push.1 assertz
    end
end

#! Removes the provided key/value pair from the leaf. The leaf to which we're inserting is
#! guaranteed to hold a single key-value pair (provided on the advice stack). Hence, after the
#! operation, the leaf will be empty.
#!
#! Inputs:
#!   Operand stack: [V (=ZERO), V_old, K, R, ...]
#!
#! Outputs:
#!   Operand stack: [V_old, R_new, ...]
proc.remove_single_leaf
    # Update advice map
    movupw.2 swapw adv.insert_hdword
    # => [V, K, V_old, R, ...] 

    # Prepare the stack for `mtree_set`
    # Note that the new node value will be the empty word, so we can use `V`
    # as the node value (since we confirmed that it's `ZERO`)
    movupw.3 dup.8 push.LEAF_DEPTH
    # => [depth, K[0], R, V, K, V_old, ...] 

    mtree_set
    # => [NV_old, R_new, K, V_old, ...] 

    # Confirm that hmerge([K, V_old]) = NV
    movupw.2 dupw.3 hmerge assert_eqw
    # => [R_new, V_old, ...] 

    # Cleanup stack for return
    swapw
    # => [V_old, R_new, ...] 
end

#! Inserts or removes a value associated with the given key. The leaf to which we're inserting is
#! guaranteed to hold a single key-value pair (provided on the advice stack).
#!
#! Inputs:
#!   Operand stack: [V_old, V, K, R, ...]
#!   Advice stack:  [K_in_leaf, V_in_leaf]
#!
#! Outputs:
#!   Operand stack: [V_old, R_new, ...]
proc.set_single_leaf
    # Check if we're inserting or removing a value
    swapw padw eqw
    # => [V==ZERO, ZERO, V, V_old, K, R, ...] 
    if.true
        # we're removing the key/value pair from the leaf; i.e. the leaf becomes empty

        dropw 
        # => [V, V_old, K, R, ...] 

        exec.remove_single_leaf
        # => [V_old, R_new]
    else
        # we're inserting the key/value pair

        dropw 
        # => [V, V_old, K, R, ...] 

        exec.insert_single_leaf
        # => [V_old, R_new]
    end
end

#! Inserts the specified value under the specified key in a Sparse Merkle Tree defined by the
#! specified root. If the insert is successful, the old value located under the specified key
#! is returned via the stack.
#!
#! If the VALUE is an empty word (i.e., [ZERO; 4]), the new state of the tree is guaranteed to
#! be equivalent to the state as if the updated value was never inserted.
#!
#! Inputs:
#!   Operand stack: [V, K, R, ...]
#! Outputs:
#!   Operand stack: [V_old, R_new, ...]
#!
#! Fails if the tree with the specified root does not exits in the VM's advice provider.
export.set
    movdnw.2 adv.push_smtpeek movupw.2
    # => [V, K, R]

    # Push peeked value on stack
    adv_push.4
    # => [V_old, V, K, R]

    padw eqw
    # => [V_old == ZERO, ZERO, V_old, V, K, R]

    if.true
        # empty leaf

        dropw dropw
        #=> [V, K, R]

        exec.set_empty_leaf
    else
        # Single or Multiple leaf

        dropw
        # => [V_old, V, K, R]

        # Prepare stack to retrieve leaf pre-image
        dupw.2 dupw.1 hmerge
        # => [NV, V_old, V, K, R]

        # Retrieve leaf pre-image on advice stack, and push leaf size on stack
        adv.push_mapvaln dropw adv_push.1
        # => [leaf_size, V_old, V, K, R]

        # Leaf size will be a multiple of 8 (each kv-pair in a leaf is 8 elements)
        dup eq.8
        # => [is_single_kv_pair, leaf_size, V_old, V, K, R]

        if.true
            #  Single kv-pair case

            drop
            # => [V_old, V, K, R]

            exec.set_single_leaf
        else
            # Multiple kv-pair case
            # TODO (fail for now)
            push.1 assertz
        end
    end
end

# GET
# =================================================================================================

#! Returns the value located under the specified key in the Sparse Merkle Tree defined by the
#! specified root.
#!
#! If no values had been previously inserted under the specified key, an empty word (i.e.,
#! [ZERO; 4]) is returned.
#!
#! Inputs:
#!   Operand stack: [K, R, ...]
#!
#! Outputs:
#!   Operand stack: [V, R, ...]
#!
#! Fails if the tree with the specified root does not exits in the VM's advice provider.
export.get
    # Prepare for `mtree_get`
    dupw.1 dup.4 push.LEAF_DEPTH
    # => [depth, K[0], R, K, R]

    # Retrieve node value from merkle store
    mtree_get swapw dropw
    # => [NV, K, R]

    # Check if value is empty; if so, return empty value
    padw eqw
    # => [NV == 0, ZERO, V, K, R]

    if.true
        # Return empty value
        dropw swapw dropw
        # => [NV, R]
    else
        # Drop extra ZERO word
        dropw
        # => [NV, K, R]

        # Get leaf pre-image from advice map. Push the leaf preimage size on the stack
        adv.push_mapvaln adv_push.1
        # => [leaf_size, NV, K, R]

        # Leaf size will be a multiple of 8 (each kv-pair in a leaf is 8 elements)
        dup eq.8
        # => [is_single_kv_pair, leaf_size, NV, K, R]

        if.true
            # Single kv-pair case

            # Push leaf pre-image on stack (single K-V pair)
            drop adv_push.8
            # => [V, K, NV, K, R]

            # Confirm that the key stored in the leaf is as expected
            movupw.3 dupw.2 assert_eqw
            # => [V, K, NV, R]

            # Duplicate V to return it after hash check
            dupw movdnw.3
            # => [V, K, NV, V, R]

            # Hash leaf preimage and ensure that it equals node value
            hmerge assert_eqw
            # => [V, R]
        else
            # Multiple kv-pair case
            # TODO (fail for now)
            push.1 assertz
        end
    end
end
