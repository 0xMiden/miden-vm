# Constant value for empty sub-tree root at depth 16
const.EMPTY_16_0=17483286922353768131
const.EMPTY_16_1=353378057542380712
const.EMPTY_16_2=1935183237414585408
const.EMPTY_16_3=4820339620987989650

# Constant value for empty sub-tree root at depth 32
const.EMPTY_32_0=11677748883385181208
const.EMPTY_32_1=15891398395707500576
const.EMPTY_32_2=3790704659934033620
const.EMPTY_32_3=2126099371106695189

# Constant value for empty sub-tree root at depth 48
const.EMPTY_48_0=10650694022550988030
const.EMPTY_48_1=5634734408638476525
const.EMPTY_48_2=9233115969432897632
const.EMPTY_48_3=1437907447409278328

# HELPER METHODS
# =================================================================================================

#! Extracts 16 most significant bits from the passed-in value.
#!
#! Input:  [v, ...]
#! Output: [v >> 48, ...]
#!
#! Cycles: 6
proc.get_top_16_bits
    u32split
    swap drop
    u32unchecked_shr.16
end

#! Extracts 48 most significant bits from the passed-in value.
#!
#! Input:  [v, ...]
#! Output: [v >> 16, ...]
#!
#! Cycles: 9
proc.get_top_48_bits
    u32split
    swap
    u32unchecked_shr.16
    swap
    mul.65536
    add
end

# GET
# =================================================================================================

#! Get the leaf value for depth 16.
#!
#! Input:  [K, R, ...]
#! Output: [V, R, ...]
#!
#! Cycles: 85
proc.get16.2
    # compute index of the node by extracting top 16 bits from the key (8 cycles)
    dup exec.get_top_16_bits movdn.4
    # => [K, i, R, ...]

    # save [0, 0, 0, 0] into loc[0] (7 cycles)
    padw loc_storew.0

    # load Ka from advice provider and compare it to K (16 cycles)
    # Ka is expected to be the key for the node stored at depth 16; it could be either equal
    # to K, or could be something different
    adv_loadw eqw
    # => [Ka ?= K, Ka, K, i, R, ...]

    # move the comparison result out of the way (1 cycle)
    movdn.8
    # => [Ka, K, Ka ?= K, i, R, ...]

    # load the value from adv provider and prepare hash (6 cycles)
    push.0.16.0.0 swapw.2 adv_loadw
    # => [V, Ka, D, Ka ?= K, i, R, ...]

    # save the value into loc[1] (4 cycles)
    loc_storew.1
    # => [V, Ka, D, Ka ?= K, i, R, ...]

    # compute the value of the node as hash(K, V, domain=16) (10 cycles)
    hperm dropw swapw dropw
    # => [N, Ka ?= K, i, R, ...]

    # push the root of the empty subtree (5 cycles)
    push.EMPTY_16_0.EMPTY_16_1.EMPTY_16_2.EMPTY_16_3 swapw
    # => [N, E, Ka ?= K, i, R, ...]

    # read the flag if the node is empty subtree (5 cycles)
    adv_push.1 movdn.8 dup.8
    # => [not_empty?, N, E, not_empty?, Ka ?= K, i, R, ...]

    # conditionally select node (5 cycles)
    cdropw
    # => [N', not_empty?, Ka ?= K, i, R, ...]

    # compute the flag indicating if value is not zero (3 cycles)
    movup.5 movup.5 and
    # => [take_val?, N', i, R, ...]

    # move take_val out of the way (4 cycles)
    movdn.9
    # => [N', i, R, take_val?, ...]

    # verify Merkle path from N' to R (3 cycles)
    push.16 movdn.4 mtree_verify
    # => [N', 16, i, R, take_val?, ...]

    # reorganize stack (4 cycles)
    movup.4 drop movup.4 drop movup.8
    # => [take_val?, N', R, ...]

    # compute the address of the return value based on `take_val` and return it, being either
    # zero or V (3 cycles)
    locaddr.0 add
    # => [addr, N', R, ...]

    # load the selected value and return (1 cycle)
    mem_loadw
    # => [V, R, ...]
end

#! Get the leaf value for depth 32.
#!
#! Input:  [K, R, ...]
#! Output: [V, R, ...]
#!
#! Cycles: 81
proc.get32.2
    # compute index of the node by extracting top 16 bits from the key (4 cycles)
    dup u32split movdn.5 drop
    # => [K, i, R, ...]

    # save [0, 0, 0, 0] into loc[0] (7 cycles)
    padw loc_storew.0

    # load Ka from advice provider and compare it to K (16 cycles)
    # Ka is expected to be the key for the node stored at depth 32; it could be either equal
    # to K, or could be something different
    adv_loadw eqw
    # => [Ka ?= K, Ka, K, i, R, ...]

    # move the comparison result out of the way (1 cycle)
    movdn.8
    # => [Ka, K, Ka ?= K, i, R, ...]

    # load the value from adv provider and prepare hash (6 cycles)
    push.0.32.0.0 swapw.2 adv_loadw
    # => [V, Ka, D, Ka ?= K, i, R, ...]

    # save the value into loc[1] (4 cycles)
    loc_storew.1
    # => [V, Ka, D, Ka ?= K, i, R, ...]

    # compute the value of the node as hash(K, V, domain=32) (10 cycles)
    hperm dropw swapw dropw
    # => [N, Ka ?= K, i, R, ...]

    # push the root of the empty subtree (5 cycles)
    push.EMPTY_32_0.EMPTY_32_1.EMPTY_32_2.EMPTY_32_3 swapw
    # => [N, E, Ka ?= K, i, R, ...]

    # read the flag if the node is empty subtree (5 cycles)
    adv_push.1 movdn.8 dup.8
    # => [not_empty?, N, E, not_empty?, Ka ?= K, i, R, ...]

    # conditionally select node (5 cycles)
    cdropw
    # => [N', not_empty?, Ka ?= K, i, R, ...]

    # compute the flag indicating if value is not zero (3 cycles)
    movup.5 movup.5 and
    # => [take_val?, N', i, R, ...]

    # move take_val out of the way (4 cycles)
    movdn.9
    # => [N', i, R, take_val?, ...]

    # verify Merkle path from N' to R (3 cycles)
    push.32 movdn.4 mtree_verify
    # => [N', 32, i, R, take_val?, ...]

    # reorganize stack (4 cycles)
    movup.4 drop movup.4 drop movup.8
    # => [take_val?, N', R, ...]

    # compute the address of the return value based on `take_val` and return it, being either
    # zero or V (3 cycles)
    locaddr.0 add
    # => [addr, N', R, ...]

    # load the selected value and return (1 cycle)
    mem_loadw
    # => [V, R, ...]
end

#! Get the leaf value for depth 48.
#!
#! Input:  [K, R, ...]
#! Output: [V, R, ...]
#!
#! Cycles: 88
proc.get48.2
    # compute index of the node by extracting top 48 bits from the key (11 cycles)
    dup exec.get_top_48_bits movdn.4
    # => [K, i, R, ...]

    # save [0, 0, 0, 0] into loc[0] (7 cycles)
    padw loc_storew.0

    # load Ka from advice provider and compare it to K (16 cycles)
    # Ka is expected to be the remaining key for the node stored at depth 48; it could be either
    # equal to K, or could be something different
    adv_loadw eqw
    # => [Ka ?= K, Ka, K, i, R, ...]

    # move the comparison result out of the way (1 cycle)
    movdn.8
    # => [Ka, K, Ka ?= K, i, R, ...]

    # load the value from adv provider and prepare hash (6 cycles)
    push.0.48.0.0 swapw.2 adv_loadw
    # => [V, Ka, D, Ka ?= K, i, R, ...]

    # save the value into loc[1] (4 cycles)
    loc_storew.1
    # => [V, Ka, D, Ka ?= K, i, R, ...]

    # compute the value of the node as hash(K, V, domain=48) (10 cycles)
    hperm dropw swapw dropw
    # => [N, Ka ?= K, i, R, ...]

    # push the root of the empty subtree (5 cycles)
    push.EMPTY_48_0.EMPTY_48_1.EMPTY_48_2.EMPTY_48_3 swapw
    # => [N, E, Ka ?= K, i, R, ...]

    # read the flag if the node is empty subtree (5 cycles)
    adv_push.1 movdn.8 dup.8
    # => [not_empty?, N, E, not_empty?, Ka ?= K, i, R, ...]

    # conditionally select node (5 cycles)
    cdropw
    # => [N', not_empty?, Ka ?= K, i, R, ...]

    # compute the flag indicating if value is not zero (3 cycles)
    movup.5 movup.5 and
    # => [take_val?, N', i, R, ...]

    # move take_val out of the way (4 cycles)
    movdn.9
    # => [N', i, R, take_val?, ...]

    # verify Merkle path from N' to R (3 cycles)
    push.48 movdn.4 mtree_verify
    # => [N', 48, i, R, take_val?, ...]

    # reorganize stack (4 cycles)
    movup.4 drop movup.4 drop movup.8
    # => [take_val?, N', R, ...]

    # compute the address of the return value based on `take_val` and return it, being either
    # zero or V (3 cycles)
    locaddr.0 add
    # => [addr, N', R, ...]

    # load the selected value and return (1 cycle)
    mem_loadw
    # => [V, R, ...]
end

#! Returns the value stored under the specified key in a Sparse Merkle Tree with the specified root.
#!
#! If the value for a given key has not been set, the returned `V` will consist of all zeroes.
#!
#! Input:  [K, R, ...]
#! Output: [V, R, ...]
#!
#! Depth 16: 91 cycles
#! Depth 32: 87 cycles
#! Depth 48: 94 cycles
#! Depth 64: unimplemented
export.get
    # invoke adv and fetch target depth flags
    adv.push_smtget adv_push.2
    # => [d ∈ {16, 32}, d ∈ {16, 48}, K, R, ...]

    # call the inner procedure depending on the depth
    if.true
        if.true
            # depth 16
            exec.get16
        else
            # depth 32
            exec.get32
        end
    else
        if.true
            # depth 48
            exec.get48
        else
            # depth 64
            # currently not implemented
            push.0 assert
        end
    end
    # => [V, R, ...]
end

# INSERT
# =================================================================================================

#! Input: [d, idx, V, K, R, ...];
#! Output:[V_old, R', ...]
#!
#! Cycles: 101
proc.update_16_32_48.2
    # save [idx, d, 0, 0] in loc[0] (5 cycles)
    push.0.0 loc_storew.0
    # => [0, 0, d, idx, V, K, R, ...]

    # prepare the stack for computing N = hash([K, V], domain=d), and also save K into lock[1]
    # (10 cycles)
    movdn.3 movup.2 drop push.0 swapw.2 loc_storew.1 swapw
    # => [V, K, 0, 0, d, 0, R, ...]

    # compute the hash of the node N = hash([K, V], domain=d) - (1 cycle)
    hperm
    # => [X, N, X, R, ...]

    # (8 cycles)
    swapw.3 swapw swapw.2 loc_loadw.0 drop drop
    # => [d, idx, R, N, X, ...]

    # (29 cycle)
    mtree_set
    # => [N_old, R_new, X, ...]

    # (21 cycles)
    swapw.2 loc_loadw.0 movdn.3 push.0 movup.3 push.0.0.0 loc_loadw.1 adv_push.4 loc_storew.0
    # => [V_old, K, 0, 0, d, 0, R_new, N_old, ...]

    # (1 cycle)
    hperm
    # => [X, E, X, R_new, N_old, ...]

    # (11 cycles)
    dropw swapw dropw swapw swapw.2
    # => [N_old, E, R_new, ...]

    # (12 cycles)
    repeat.4
        dup.4 assert_eq
    end
    # => [E, R_new, ...]

    # (3 cycles)
    loc_loadw.0
    # => [V_old, R_new, ...]
end

#! Input: [V, K, R, ...];
#! Output:[0, 0, 0, 0, R', ...]
#!
#! Cycles: 73
proc.insert_16
    # (8 cycles)
    swapw dup exec.get_top_16_bits
    # => [idx, K, V, R, ...]

    # (6 cycles)
    movdn.8 push.0.16.0.0 swapw.2
    # => [V, K, 0, 0, 16, 0, idx, R, ...]

    # (10 cycles)
    hperm dropw swapw dropw
    # => [N, idx, R, ...]

    # (4 cycles)
    swapw movup.8 movdn.4 push.16
    # => [16, idx, R, N, ...]

    # (1 cycle)
    mtree_set
    # => [N_old, R_new, ...]

    # (12 cycles)
    push.EMPTY_16_3 assert_eq
    push.EMPTY_16_2 assert_eq
    push.EMPTY_16_1 assert_eq
    push.EMPTY_16_0 assert_eq

    # (4 cycles)
    padw
    # => [0, 0, 0, 0, R_new, ...]
end

#! Input: [idx_lo, idx_hi, E, K, V, R, ...];
#! Output:[0, 0, 0, 0, R', ...]
#!
#! Cycles: 120
proc.insert_32_48.2
    # (4 cycles)
    push.0 loc_storew.0
    # => [0, idx_lo, idx_hi, E, K, V, R, ...]

    # (11 cycles)
    movdn.3 drop drop push.0.0 swapw.2 swapw loc_storew.1
    # => [E, K, 0, 0, 16, 0, V, R, ...]

    # (2 cycle)
    swapw.3 hperm
    # => [X, N, X, E, R, ...]

    # (7 cycles)
    swapw swapw.2 swapw.3 swapw loc_loadw.0
    # => [0, idx_lo, idx_hi, d, E, N, X, R, ...]

    # (5 cycles)
    drop movdn.2 drop drop push.16
    # => [16, idx_lo, E, N, X, R, ...]

    # (29 cycle)
    mtree_set
    # => [N_old, P, X, R, ...]

    # (3 cycles)
    loc_load.0
    # => [0, idx_lo, idx_hi, d, P, X, R, ...]

    # (7 cycles)
    swapw swapw.2 swapw.3 swapw drop drop swap
    # => [d, idx_hi, R, P, X, ...]

    # (31 cycles)
    sub.16 mtree_set
    # => [P_old, R_new, X, ...]

    # (6 cycles)
    swapw swapw.2 loc_loadw.1
    # => [E, P_old, R_new, ...]

    # (11 cycles)
    assert_eqw
    # => [R_new, ...]

    # (4 cycles)
    padw
    # => [0, 0, 0, 0, R_new, ...]
end

#! Inserts the specified value into a Sparse Merkle Tree with the specified root under the
#! specified key.
#!
#! The value previously stored in the SMT under this key is left on the stack together with
#! the updated tree root.
#!
#! This assumes that the value is not [ZERO; 4]. If it is, the procedure fails.
#!
#! Input: [V, K, R, ...];
#! Output:[V_old, R', ...]
#!
#! Cycles:
#! - Update existing leaf:
#!   - Depth 16: 129
#!   - Depth 32: 126
#!   - Depth 48: 131
#! - Insert new leaf:
#!   - Depth 16: 100
#!   - Depth 32: 159
#!   - Depth 48: 159
#! - Replace a leaf with a subtree:
#!   - Depth 32: TODO
#!   - Depth 48: TODO
export.insert
    # make sure the value is not [ZERO; 4] (17 cycles)
    repeat.4
        dup.3 eq.0
    end
    and and and assertz
    # => [V, K, R, ...]

    # invoke adv and fetch target depth flags (4 cycles)
    adv.push_smtinsert adv_push.4
    # => [TODO]

    # call the inner procedure depending on the type of insert and depth
    if.true # --- update leaf -----------------------------------------------------
        if.true 
            if.true # --- update a leaf node at depth 16 ---
                drop

                # (cycles 8)
                dup.4 exec.get_top_16_bits
                push.16
                # => [16, idx, V, K, R, ...]

                exec.update_16_32_48
            else # --- update a leaf node at depth 32 ---
                drop

                #(5 cycles)
                dup.4 u32split swap drop
                push.32
                # => [32, idx, V, K, R, ...]

                exec.update_16_32_48
            end
        else
            if.true # --- update a leaf node at depth 48 ---
                drop

                # (10 cycles)
                dup.4 exec.get_top_48_bits
                push.48
                # => [48, idx, V, K, R, ...]

                exec.update_16_32_48
            else
                # depth 64 - currently not implemented
                push.0 assert
            end
        end
    else
        if.true # --- inset new leaf ----------------------------------------------
            if.true
                if.true # --- insert new leaf at depth 16 ---
                    exec.insert_16
                else # --- insert new leaf at depth 32 ---
                    # (5 cycles)
                    swapw push.EMPTY_16_0.EMPTY_16_1.EMPTY_16_2.EMPTY_16_3
                    # => [E16, K, V, R, ...]

                    # (7 cycles)
                    push.32
                    dup.5 u32split swap drop u32unchecked_divmod.65536
                    # => [idx_lo, idx_hi, d, E16, K, V, R, ...]

                    exec.insert_32_48
                end
            else
                if.true # --- insert new leaf at depth 48 ---
                    # (5 cycles)
                    swapw push.EMPTY_32_0.EMPTY_32_1.EMPTY_32_2.EMPTY_32_3
                    # => [E32, K, V, R, ...]

                    # (7 cycles)
                    push.48
                    dup.5 u32split swap u32unchecked_divmod.65536 drop
                    # => [idx_lo, idx_hi, d, E32, K, V, R, ...]

                    exec.insert_32_48
                else
                    # depth 64 - currently not implemented
                    push.0 assert
                end
            end
        else # --- replace leaf with subtree ----------------------------------
            # TODO: implement replace leaf with subtree
            push.0 assert
        end
    end

    # => [V, R, ...]
end
