# Constant value for empty sub-tree root at depth 16
const.EMPTY_16_0=17483286922353768131
const.EMPTY_16_1=353378057542380712
const.EMPTY_16_2=1935183237414585408
const.EMPTY_16_3=4820339620987989650

# Constant value for empty sub-tree root at depth 32
const.EMPTY_32_0=11677748883385181208
const.EMPTY_32_1=15891398395707500576
const.EMPTY_32_2=3790704659934033620
const.EMPTY_32_3=2126099371106695189

# Constant value for empty sub-tree root at depth 48
const.EMPTY_48_0=10650694022550988030
const.EMPTY_48_1=5634734408638476525
const.EMPTY_48_2=9233115969432897632
const.EMPTY_48_3=1437907447409278328

# HELPER METHODS
# =================================================================================================

#! Extracts 16 most significant bits from the passed-in value.
#!
#! Input:  [v, ...]
#! Output: [v >> 48, ...]
#!
#! Cycles: 6
proc.get_top_16_bits
    u32split
    swap drop
    u32unchecked_shr.16
end

#! Extracts 48 most significant bits from the passed-in value.
#!
#! Input:  [v, ...]
#! Output: [v >> 16, ...]
#!
#! Cycles: 9
proc.get_top_48_bits
    u32split
    swap
    u32unchecked_shr.16
    swap
    mul.65536
    add
end

# GET
# =================================================================================================

#! Get the leaf value for depth 16.
#!
#! Input:  [K, R, ...]
#! Output: [V, R, ...]
#!
#! Cycles: 85
proc.get16.2
    # compute index of the node by extracting top 16 bits from the key (8 cycles)
    dup exec.get_top_16_bits movdn.4
    # => [K, i, R, ...]

    # save [0, 0, 0, 0] into loc[0] (7 cycles)
    padw loc_storew.0

    # load Ka from advice provider and compare it to K (16 cycles)
    # Ka is expected to be the key for the node stored at depth 16; it could be either equal
    # to K, or could be something different
    adv_loadw eqw
    # => [Ka ?= K, Ka, K, i, R, ...]

    # move the comparison result out of the way (1 cycle)
    movdn.8
    # => [Ka, K, Ka ?= K, i, R, ...]

    # load the value from adv provider and prepare hash (6 cycles)
    push.0.16.0.0 swapw.2 adv_loadw
    # => [V, Ka, D, Ka ?= K, i, R, ...]

    # save the value into loc[1] (4 cycles)
    loc_storew.1
    # => [V, Ka, D, Ka ?= K, i, R, ...]

    # compute the value of the node as hash(K, V, domain=16) (10 cycles)
    hperm dropw swapw dropw
    # => [N, Ka ?= K, i, R, ...]

    # push the root of the empty subtree (5 cycles)
    push.EMPTY_16_0.EMPTY_16_1.EMPTY_16_2.EMPTY_16_3 swapw
    # => [N, E, Ka ?= K, i, R, ...]

    # read the flag if the node is empty subtree (5 cycles)
    adv_push.1 movdn.8 dup.8
    # => [not_empty?, N, E, not_empty?, Ka ?= K, i, R, ...]

    # conditionally select node (5 cycles)
    cdropw
    # => [N', not_empty?, Ka ?= K, i, R, ...]

    # compute the flag indicating if value is not zero (3 cycles)
    movup.5 movup.5 and
    # => [take_val?, N', i, R, ...]

    # move take_val out of the way (4 cycles)
    movdn.9
    # => [N', i, R, take_val?, ...]

    # verify Merkle path from N' to R (3 cycles)
    push.16 movdn.4 mtree_verify
    # => [N', 16, i, R, take_val?, ...]

    # reorganize stack (4 cycles)
    movup.4 drop movup.4 drop movup.8
    # => [take_val?, N', R, ...]

    # compute the address of the return value based on `take_val` and return it, being either
    # zero or V (3 cycles)
    locaddr.0 add
    # => [addr, N', R, ...]

    # load the selected value and return (1 cycle)
    mem_loadw
    # => [V, R, ...]
end

#! Get the leaf value for depth 32.
#!
#! Input:  [K, R, ...]
#! Output: [V, R, ...]
#!
#! Cycles: 81
proc.get32.2
    # compute index of the node by extracting top 16 bits from the key (4 cycles)
    dup u32split movdn.5 drop
    # => [K, i, R, ...]

    # save [0, 0, 0, 0] into loc[0] (7 cycles)
    padw loc_storew.0

    # load Ka from advice provider and compare it to K (16 cycles)
    # Ka is expected to be the key for the node stored at depth 32; it could be either equal
    # to K, or could be something different
    adv_loadw eqw
    # => [Ka ?= K, Ka, K, i, R, ...]

    # move the comparison result out of the way (1 cycle)
    movdn.8
    # => [Ka, K, Ka ?= K, i, R, ...]

    # load the value from adv provider and prepare hash (6 cycles)
    push.0.32.0.0 swapw.2 adv_loadw
    # => [V, Ka, D, Ka ?= K, i, R, ...]

    # save the value into loc[1] (4 cycles)
    loc_storew.1
    # => [V, Ka, D, Ka ?= K, i, R, ...]

    # compute the value of the node as hash(K, V, domain=32) (10 cycles)
    hperm dropw swapw dropw
    # => [N, Ka ?= K, i, R, ...]

    # push the root of the empty subtree (5 cycles)
    push.EMPTY_32_0.EMPTY_32_1.EMPTY_32_2.EMPTY_32_3 swapw
    # => [N, E, Ka ?= K, i, R, ...]

    # read the flag if the node is empty subtree (5 cycles)
    adv_push.1 movdn.8 dup.8
    # => [not_empty?, N, E, not_empty?, Ka ?= K, i, R, ...]

    # conditionally select node (5 cycles)
    cdropw
    # => [N', not_empty?, Ka ?= K, i, R, ...]

    # compute the flag indicating if value is not zero (3 cycles)
    movup.5 movup.5 and
    # => [take_val?, N', i, R, ...]

    # move take_val out of the way (4 cycles)
    movdn.9
    # => [N', i, R, take_val?, ...]

    # verify Merkle path from N' to R (3 cycles)
    push.32 movdn.4 mtree_verify
    # => [N', 32, i, R, take_val?, ...]

    # reorganize stack (4 cycles)
    movup.4 drop movup.4 drop movup.8
    # => [take_val?, N', R, ...]

    # compute the address of the return value based on `take_val` and return it, being either
    # zero or V (3 cycles)
    locaddr.0 add
    # => [addr, N', R, ...]

    # load the selected value and return (1 cycle)
    mem_loadw
    # => [V, R, ...]
end

#! Get the leaf value for depth 48.
#!
#! Input:  [K, R, ...]
#! Output: [V, R, ...]
#!
#! Cycles: 88
proc.get48.2
    # compute index of the node by extracting top 48 bits from the key (11 cycles)
    dup exec.get_top_48_bits movdn.4
    # => [K, i, R, ...]

    # save [0, 0, 0, 0] into loc[0] (7 cycles)
    padw loc_storew.0

    # load Ka from advice provider and compare it to K (16 cycles)
    # Ka is expected to be the remaining key for the node stored at depth 48; it could be either
    # equal to K, or could be something different
    adv_loadw eqw
    # => [Ka ?= K, Ka, K, i, R, ...]

    # move the comparison result out of the way (1 cycle)
    movdn.8
    # => [Ka, K, Ka ?= K, i, R, ...]

    # load the value from adv provider and prepare hash (6 cycles)
    push.0.48.0.0 swapw.2 adv_loadw
    # => [V, Ka, D, Ka ?= K, i, R, ...]

    # save the value into loc[1] (4 cycles)
    loc_storew.1
    # => [V, Ka, D, Ka ?= K, i, R, ...]

    # compute the value of the node as hash(K, V, domain=48) (10 cycles)
    hperm dropw swapw dropw
    # => [N, Ka ?= K, i, R, ...]

    # push the root of the empty subtree (5 cycles)
    push.EMPTY_48_0.EMPTY_48_1.EMPTY_48_2.EMPTY_48_3 swapw
    # => [N, E, Ka ?= K, i, R, ...]

    # read the flag if the node is empty subtree (5 cycles)
    adv_push.1 movdn.8 dup.8
    # => [not_empty?, N, E, not_empty?, Ka ?= K, i, R, ...]

    # conditionally select node (5 cycles)
    cdropw
    # => [N', not_empty?, Ka ?= K, i, R, ...]

    # compute the flag indicating if value is not zero (3 cycles)
    movup.5 movup.5 and
    # => [take_val?, N', i, R, ...]

    # move take_val out of the way (4 cycles)
    movdn.9
    # => [N', i, R, take_val?, ...]

    # verify Merkle path from N' to R (3 cycles)
    push.48 movdn.4 mtree_verify
    # => [N', 48, i, R, take_val?, ...]

    # reorganize stack (4 cycles)
    movup.4 drop movup.4 drop movup.8
    # => [take_val?, N', R, ...]

    # compute the address of the return value based on `take_val` and return it, being either
    # zero or V (3 cycles)
    locaddr.0 add
    # => [addr, N', R, ...]

    # load the selected value and return (1 cycle)
    mem_loadw
    # => [V, R, ...]
end

#! Returns the value stored under the specified key in a Sparse Merkle Tree with the specified root.
#!
#! If the value for a given key has not been set, the returned `V` will consist of all zeroes.
#!
#! Input:  [K, R, ...]
#! Output: [V, R, ...]
#!
#! Depth 16: 91 cycles
#! Depth 32: 87 cycles
#! Depth 48: 94 cycles
#! Depth 64: unimplemented
export.get
    # invoke adv and fetch target depth flags
    adv.push_smtget adv_push.2
    # => [d ∈ {16, 32}, d ∈ {16, 48}, K, R, ...]

    # call the inner procedure depending on the depth
    if.true
        if.true
            # depth 16
            exec.get16
        else
            # depth 32
            exec.get32
        end
    else
        if.true
            # depth 48
            exec.get48
        else
            # depth 64
            # currently not implemented
            push.0 assert
        end
    end
    # => [V, R, ...]
end

# INSERT
# =================================================================================================

# Input: [V, K, R, ...];
# Output:[V_old, R', ...]
proc.insert16.1
  # split the k3 into index and remainder (8 cycles)
  swapw
  exec.split_16
  # => [rem, idx, k2, k1, k0, V, R, ...]

  # move idx out of the way and save the updated key to memory (5 cycles)
  swap
  movdn.8
  loc_storew.0
  # => [rem, k2, k1, k0, V, idx, R, ...]

  # prepare hasher state (5 cycles)
  push.0.16.0.0
  swapw.2
  # => [V, rem, k2, k1, k0, 0, 0, 16, 0, idx, R, ...]

  # put (node |-> (key', value)) into the advice map
  adv.insert_hdword.16

  # hash the value + rem_key to get new node value (10 cycles)
  hperm
  dropw swapw dropw
  # => [N, idx, R, ...]

  # arrange the stack and update the Merkle tree; if we update mtree_set instruction to take
  # input as [d, i, V, R], then instructions below marked as "not needed" can be removed
  movup.4
  movdn.8  # not needed
  swapw    # not needed
  movup.8  # not needed
  push.16
  mtree_set
  # => [N_old, R_new, ...]

  # if N_old is an empty subtree go into the `true` branch; otherwise go into `else` branch
  adv_push.1
  if.true
    # push root of an empty subtree of depth 16 onto the stack (4 cycles)
    push.EMPTY_16_0.EMPTY_16_1.EMPTY_16_2.EMPTY_16_3
    # => [E, N_old, R_new, ...]

    # make sure the node is in fact a root of an empty subtree and return zeros (15 cycles)
    assert_eqw
    push.0.0.0.0
  else
    # prepare hasher state (13 cycles)
    push.0.16.0.0
    push.0.0.0.0
    loc_loadw.0
    adv_push.4
    # => [V_old, rem, k2, k1, k0, 0, 0, 16, 0, N_old, R_new, ...]    

    # save the old value to memory (3 cycle)
    loc_storew.0

    # compute the hash (10 cycles)
    hperm
    dropw swapw dropw
    # => [N_old_computed, N_old, R_new, ...]

    # make sure the old node value from mtree_set is the same as computed one (11 cycles)
    assert_eqw
    # => [R_new, ...]

    # load and return old value (7 cycles)
    push.0.0.0.0
    loc_loadw.0
    # => [V_old, R_new, ...]
  end
end

#! Inserts the specified value into a Sparse Merkle Tree with the specified root under the
#! specified key.
#!
#! The value previously stored in the SMT under this key is left on the stack together with
#! the updated tree root.
#!
#! This assumes that the value is not [ZERO; 4]. If it is, the procedure fails.
#!
#! Input: [V, K, R, ...];
#! Output:[V_old, R', ...]
export.insert
    # make sure the value is not [ZERO; 4] (17 cycles)
    repeat.4
        dup.3 eq.0
    end
    and and and assertz
    # => [V, K, R, ...]

    # invoke adv and fetch target depth flags (2 cycles)
    adv.push_smtinsert adv_push.2
    # => [d ∈ {16, 32}, d ∈ {16, 48}, V, K, R, ...]

    # call the inner procedure depending on the depth
    if.true
        if.true
            # depth 16
            exec.insert16
        else
            # depth 32 - TODO
            push.0 assert
        end
    else
        if.true
            # depth 48 - TODO
            push.0 assert
        else
            # depth 64 - currently not implemented
            push.0 assert
        end
    end
    # => [V, R, ...]
end
