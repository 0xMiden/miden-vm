const.DEPTH=64

#! Input:  [V, K, R, ...]
#! Output: [V_old, R_new, ...]
export.set
    adv.push_smtpeek adv_push.4
    # => [V_old, V, K, R]

    padw eqw
    # => [V_old == ZERO, ZERO, V_old, V, K, R]

    if.true
        # empty leaf

        dropw dropw
        #=> [V, K, R]

        # Update advice map with new leaf preimage
        # adv_map[hash(K, V)] = [K, V]
        adv.insert_hdword
        #=> [V, K, R]

        # Prepare stack for `mtree_set`
        movupw.2 dup.11 push.DEPTH
        #=> [depth, K[3], R, V, K]

        # Insert node in Merkle store
        mtree_set
        #=> [V_in_leaf, R_new, K]

        # Check that V_in_leaf is indeed empty
        padw assert_eqw
        #=> [R_new, K]

        # Prepare stack for return
        swapw dropw padw
        #=> [ZERO, R_new]
    else
        # Single or Multiple leaf
    end
end

#! Input:  [K, R, ...]
#! Output: [V, R, ...]
export.get
    # Prepare for `mtree_get`
    # TODO: Confirm K[3] is indeed the MSB (i.e. are words pushed in reversed order on stack?)
    dupw.1 dup.7 push.DEPTH
    # => [depth, K[3], R, K, R]

    # Retrieve node value from merkle store
    mtree_get swapw dropw
    # => [NV, K, R]

    # Check if value is empty; if so, return empty value
    padw eqw
    # => [NV == 0, ZERO, V, K, R]

    if.true
        # Return empty value
        dropw swapw dropw
        # => [NV, R]
    else
        # Drop extra ZERO word
        dropw
        # => [NV, K, R]

        # Get leaf pre-image from advice map. Push the leaf preimage size on the stack
        adv.push_mapvaln adv_push.1
        # => [leaf_size, NV, K, R]

        # Leaf size will be a multiple of 8 (each kv-pair in a leaf is 8 elements)
        dup eq.8
        # => [is_single_kv_pair, leaf_size, NV, K, R]

        if.true
            # Single kv-pair case

            # TODO: Does `adv_push` return `K, V` or `V, K`?
            # As of currently, the order of inputs to `hmerge` below are
            # inverted; `hmerge` should act on `[V, K]`.
            # Push leaf pre-image on stack (single K-V pair)
            drop adv_push.8
            # => [K, V, NV, K, R]

            # Confirm that the key stored in the leaf is as expected
            movupw.3 dupw.1 assert_eqw
            # => [K, V, NV, R]

            # Duplicate V to return it after hash check
            dupw.1 movdnw.3
            # => [K, V, NV, V, R]

            # Hash leaf preimage and ensure that it equals node value
            hmerge assert_eqw
            # => [V, R]
        else
            # Multiple kv-pair case
            # TODO (fail for now)
            push.1 assertz
        end
    end
end
