#! Given starting memory address to q i.e. 64 polynomial evaluations ( FRI codeword ), this routine computes
#! τ, by first non-deterministically interpolating polynomial p ( of degree at max 7 i.e. with 8 coefficients )
#! using advice provider ( i.e. computation performed outside of the VM ) and then sequentially hashing coefficients
#! of q, p ( in order ), using Rescue Prime Optimized hash function.
#!
#! Note, both q ( polynomial evaluations i.e. in NTT form ), p ( polynomial in coefficient form ), is over quadratic 
#! extension field over Fq | q = 2^64 - 2^32 + 1
#!
#! Other than starting address of q, starting memory address of p is also provided on stack, which is used for
#! piping interpolated polynomial coefficients into memory, which will be later used for computing α.
#!
#! See https://github.com/0xPolygonMiden/miden-vm/issues/592#issuecomment-1341814867 for how τ is computed.
#!
#! Expected stack state
#!
#! [mem_ptr_q, mem_ptr_p, ...]
#!
#! Final stack state
#!
#! [τ1, τ0, mem_ptr_q, ...] | τ = (τ0, τ1)
#!
#! τ = rescue_prime_optimized::hash_elements(q... ++ p...)[..2]
#!
#! - `hash_elements` routine works over vector of elements of Fq | q = 2^64 -2^32 + 1
#! - ... -> spread operator
#! - ++ -> concatenate two vectors
#! - q... -> vector of length 128 s.t. each element ∈ Fq
#! - p... -> vector of length 16 s.t. each element ∈ Fq
#! - Rescue Prime Optimized hash produces four Fq elements as its digest
#! - [..2] -> picks first two Fq elements from digest
proc.compute_tau
    push.64
    push.8
    adv.ext2intt # interpolate polynomial p, using advice provider

    drop
    drop
    dup

    # Initialize Rescue Prime Optimized state
    # More on RPO256 @ https://github.com/0xPolygonMiden/crypto/blob/3c60484/src/hash/rpo/mod.rs
    push.0.0.0.0.0.0.0.0.0.0.0.0

    # Consume `q` into Rescue state
    repeat.16
        mem_stream
    end

    movup.12
    drop
    movup.13
    movdn.12

    # Consume `p` into Rescue state
    repeat.2
        adv_pipe
    end

    movup.12
    drop

    dropw
    swapw
    dropw
    drop
    drop
end

#! Given ω, accumulator ν and τ on stack top, this routine first computes ⍳ ( using following formula ), 
#! then it loads four elements from memory address (mem_ptr_q + 1) i.e. a3, a2, a1, a0 and finally accumulates
#! it into ν, while consuming <a1, a0>, only when j is even | j ∈ [0..64), following formula for computing β,
#! described in https://github.com/0xPolygonMiden/miden-vm/pull/644#pullrequestreview-1265141094
#!
#! Expected stack state
#!
#! [ω, ν1, ν0, τ1, τ0, mem_ptr_q - 1, ...]
#!
#! One computes ⍳ = ω/ (τ - ω)
#! <a3, a2, a1, a0> loaded from (mem_ptr_q + 1) s.t. a1, a0 are consumed into ν
#!
#! Final stack state
#!
#! [a3, a2, ν1', ν0', τ1, τ0, mem_ptr_q, ...]
#!
#! Remaining part of word i.e. a3, a2 will be consumed during immediate next iteration
#! of computing β which involves invocation of accumulate_for_odd_index.
proc.accumulate_for_even_index
    # compute ⍳ s.t. ⍳ = ω/ (τ - ω)
    dup.4
    dup.1
    sub
    dup.4
    ext2inv
    swap
    dup.2
    mul
    movdn.2
    mul

    # load <a3, a2, a1, a0> from mem_ptr_q + 1
    #
    # notice, first increment memory address and then load from it.
    movup.6
    add.1
    movdn.6
    push.0.0.0
    dup.9
    push.0
    swap
    mem_loadw

    # consume <a1, a0> into ν' s.t. j is even && j ∈ [0..64)
    #
    # uses formula ν' = ν + ⍳ * a | a = (a0, a1), ⍳ = (⍳0, ⍳1), ν = (ν0, ν1) and ν' = (ν'0, ν'1)
    # also note, ν' becomes the new state of accumulator ν
    movup.5
    movup.5
    movup.5
    movup.5
    ext2mul
    swap
    movup.5
    add
    swap
    movup.4
    add
    movdn.3
    movdn.3
    # notice, <a3, a2> were not consumed in this iteration, they will be consumed
    # into ν, in next iteration, when j is odd.
end

#! Given ω, accumulator ν and τ on stack top, this routine first computes ⍳ ( using following formula ), and then accumulates
#! ⍳ into ν, while consuming <a3, a2>, only when j is odd | j ∈ [0..64), following formula for computing β,
#! described in https://github.com/0xPolygonMiden/miden-vm/pull/644#pullrequestreview-1265141094
#!
#! Expected stack state
#!
#! [ω, a3, a2, ν1, ν0, τ1, τ0, mem_ptr_q, ...]
#!
#! One computes ⍳ = ω/ (τ - ω)
#! <a3, a2> which was loaded ( during previous itertion i.e. when j was even ) from mem_ptr_q 
#! is consumed into ν.
#!
#! Final stack state
#!
#! [ν1', ν0', τ1, τ0, mem_ptr_q, ...]
proc.accumulate_for_odd_index
    # compute ⍳ s.t. ⍳ = ω/ (τ - ω)
    dup.6
    dup.1
    sub
    dup.6
    ext2inv
    swap
    dup.2
    mul
    movdn.2
    mul

    # consume <a3, a2> into ν' s.t. j is odd && j ∈ [0..64)
    #
    # uses formula ν' = ν + ⍳ * a | a = (a2, a3), ⍳ = (⍳0, ⍳1), ν = (ν0, ν1) and ν' = (ν'0, ν'1)
    # and ν' becomes the new value of accumulator ν
    ext2mul
    swap
    movup.3
    add
    swap
    movup.2
    add
end

#! Given τ and starting memory address to q ( FRI codeword with 64 evaluations ), this routine computes β
#! using formula described in https://github.com/0xPolygonMiden/miden-vm/pull/644#pullrequestreview-1265141094
#!
#! Expected stack state
#!
#! [τ1, τ0, mem_ptr_q, ...]
#!
#! Final stack state
#!
#! [β1, β0, τ1, τ0, mem_ptr_q, ...]
proc.compute_beta
    # subtract starting address by 1, because we first increment and then load
    # onto stack
    movup.2
    sub.1
    movdn.2

    push.0.0 # accumulator for β

    # for j = 0
    push.1
    exec.accumulate_for_even_index
    
    # for j = 1
    push.549755813888
    exec.accumulate_for_odd_index

    # for j = 2
    push.70368744161280
    exec.accumulate_for_even_index

    # for j = 3
    push.18446744069412487169
    exec.accumulate_for_odd_index

    # for j = 4
    push.17293822564807737345
    exec.accumulate_for_even_index

    # for j = 5
    push.8
    exec.accumulate_for_odd_index

    # for j = 6
    push.4398046511104
    exec.accumulate_for_even_index

    # for j = 7
    push.562949953290240
    exec.accumulate_for_odd_index

    # for j = 8
    push.18446744069397807105
    exec.accumulate_for_even_index

    # for j = 9
    push.9223372032559808513
    exec.accumulate_for_odd_index

    # for j = 10
    push.64
    exec.accumulate_for_even_index

    # for j = 11
    push.35184372088832
    exec.accumulate_for_odd_index

    # for j = 12
    push.4503599626321920
    exec.accumulate_for_even_index

    # for j = 13
    push.18446744069280366593
    exec.accumulate_for_odd_index

    # for j = 14
    push.18446744052234715141
    exec.accumulate_for_even_index

    # for j = 15
    push.512
    exec.accumulate_for_odd_index

    # for j = 16
    push.281474976710656
    exec.accumulate_for_even_index

    # for j = 17
    push.36028797010575360
    exec.accumulate_for_odd_index

    # for j = 18
    push.18446744068340842497
    exec.accumulate_for_even_index

    # for j = 19
    push.18446743931975630881
    exec.accumulate_for_odd_index

    # for j = 20
    push.4096
    exec.accumulate_for_even_index

    # for j = 21
    push.2251799813685248
    exec.accumulate_for_odd_index

    # for j = 22
    push.288230376084602880
    exec.accumulate_for_even_index

    # for j = 23
    push.18446744060824649729
    exec.accumulate_for_odd_index

    # for j = 24
    push.18446742969902956801
    exec.accumulate_for_even_index

    # for j = 25
    push.32768
    exec.accumulate_for_odd_index

    # for j = 26
    push.18014398509481984
    exec.accumulate_for_even_index

    # for j = 27
    push.2305843008676823040
    exec.accumulate_for_odd_index

    # for j = 28
    push.18446744000695107585
    exec.accumulate_for_even_index

    # for j = 29
    push.18446735273321564161
    exec.accumulate_for_odd_index

    # for j = 30
    push.262144
    exec.accumulate_for_even_index

    # for j = 31
    push.144115188075855872
    exec.accumulate_for_odd_index

    # for j = 32
    push.18446744069414584320
    exec.accumulate_for_even_index

    # for j = 33
    push.18446743519658770433
    exec.accumulate_for_odd_index

    # for j = 34
    push.18446673700670423041
    exec.accumulate_for_even_index

    # for j = 35
    push.2097152
    exec.accumulate_for_odd_index

    # for j = 36
    push.1152921504606846976
    exec.accumulate_for_even_index

    # for j = 37
    push.18446744069414584313
    exec.accumulate_for_odd_index

    # for j = 38
    push.18446739671368073217
    exec.accumulate_for_even_index

    # for j = 39
    push.18446181119461294081
    exec.accumulate_for_odd_index

    # for j = 40
    push.16777216
    exec.accumulate_for_even_index

    # for j = 41
    push.9223372036854775808
    exec.accumulate_for_odd_index

    # for j = 42
    push.18446744069414584257
    exec.accumulate_for_even_index

    # for j = 43
    push.18446708885042495489
    exec.accumulate_for_odd_index

    # for j = 44
    push.18442240469788262401
    exec.accumulate_for_even_index

    # for j = 45
    push.134217728
    exec.accumulate_for_odd_index

    # for j = 46
    push.17179869180
    exec.accumulate_for_even_index

    # for j = 47
    push.18446744069414583809
    exec.accumulate_for_odd_index

    # for j = 48
    push.18446462594437873665
    exec.accumulate_for_even_index

    # for j = 49
    push.18410715272404008961
    exec.accumulate_for_odd_index

    # for j = 50
    push.1073741824
    exec.accumulate_for_even_index

    # for j = 51
    push.137438953440
    exec.accumulate_for_odd_index

    # for j = 52
    push.18446744069414580225
    exec.accumulate_for_even_index

    # for j = 53
    push.18444492269600899073
    exec.accumulate_for_odd_index

    # for j = 54
    push.18158513693329981441
    exec.accumulate_for_even_index

    # for j = 55
    push.8589934592
    exec.accumulate_for_odd_index

    # for j = 56
    push.1099511627520
    exec.accumulate_for_even_index

    # for j = 57
    push.18446744069414551553
    exec.accumulate_for_odd_index

    # for j = 58
    push.18428729670905102337
    exec.accumulate_for_even_index

    # for j = 59
    push.16140901060737761281
    exec.accumulate_for_odd_index

    # for j = 60
    push.68719476736
    exec.accumulate_for_even_index

    # for j = 61
    push.8796093020160
    exec.accumulate_for_odd_index

    # for j = 62
    push.18446744069414322177
    exec.accumulate_for_even_index

    # for j = 63
    push.18302628881338728449
    exec.accumulate_for_odd_index

    # compute (τ^64 - 1)/ 64
    dup.3
    dup.3

    repeat.6
        dup.1
        dup.1
        ext2mul
    end

    swap
    sub.1
    swap

    push.18158513693329981441.0
    ext2mul
    ext2mul
end

#! Given τ and end memory address of interpolated polynomial p ( with degree at max 7, over 
#! quadratic extension field of Fq ) on stack top, this routine computes α, following formula described
#! in https://github.com/0xPolygonMiden/miden-vm/issues/592#issue-1481983459
#!
#! Expected stack state
#!
#! [_, _, τ1, τ0, mem_ptr_p, ...]
#!
#! Final stack state
#!
#! [α1, α0, _, _, ...]
#!
#! Note, mem_ptr_p is absolute memory address of polynomial p ( which was interpolated using advice provider )
#! s.t. next 3 decreasing ( by 1 ) memory addresses hold remaining 6 coefficients of p. Why this descending order of
#! memory addressing ? - Read point 2 of https://github.com/0xPolygonMiden/miden-vm/issues/592#issue-1481983459
proc.compute_alpha
    movup.4
    dup
    sub.1
    movdn.5
    push.0.0.0.0
    movup.4
    mem_loadw

    dup.7
    dup.7
    ext2mul
    ext2add

    movup.6
    dup
    sub.1
    movdn.7
    push.0.0.0.0
    movup.4
    mem_loadw

    movup.5
    movup.5
    dup.9
    dup.9
    ext2mul
    ext2add

    dup.7
    dup.7
    ext2mul
    ext2add

    movup.6
    dup
    sub.1
    movdn.7
    push.0.0.0.0
    movup.4
    mem_loadw

    movup.5
    movup.5
    dup.9
    dup.9
    ext2mul
    ext2add

    dup.7
    dup.7
    ext2mul
    ext2add

    movup.6
    push.0.0.0.0
    movup.4
    mem_loadw

    movup.5
    movup.5
    dup.9
    dup.9
    ext2mul
    ext2add

    movup.7
    movup.7
    ext2mul
    ext2add
end

#! Given remainder codeword with 64 evaluations ( as starting memory address on stack ), this routine attempts to
#! probabilistically verify remainder following the technique described in https://github.com/0xPolygonMiden/miden-vm/issues/592
#! and an optimization of how to efficiently compute β in https://github.com/0xPolygonMiden/miden-vm/pull/644#pullrequestreview-1265141094
#!
#! Expected stack state
#!
#! [mem_ptr_q, ...]
#!
#! A few assumptions about mem_ptr_q
#!
#! - mem_ptr_q should be absolute memory address of the beginning of remainder codeword
#! - Each evaluation is 2 field elements wide because they belong to quadratic extension field over F_p | p = 2^64 - 2^32 + 1
#! - Meaning each memory address will hold two consecutive evaluations
#! - Words ( four field elements ), in memory, are laid out in this order (a0_0, a0_1, a1_0, a1_1)
#! - That means (a0_1, a0_0) -> first evaluation and (a1_1, a1_0) -> next evaluation
#! - Next 31 memory addresses should be holding remaining 62 evaluations
#! - If mem_ptr_q holds (a0_0, a0_1, a1_0, a1_1), then mem_ptr_q + 1, must hold (a2_0, a2_1, a3_0, a3_1)
#! - That way, mem_ptr_q + 31 should be holding (a62_0, a62_1, a63_0, a63_1)
#!
#! Final stack looks like
#!
#! [...]
#!
#! If remainder verification fails, execution of the program stops.
export.verify_remainder_64.4
    # [mem_ptr_q, ...]
    locaddr.0
    swap

    # [mem_ptr_q, mem_ptr_p, ...]
    #
    # note, mem_ptr_p is pointing to function local memory address space
    # which will be filled up with polynomial p's coefficients, which is computed
    # outside of the VM, from given codeword q.
    exec.compute_tau

    # [τ1, τ0, mem_ptr_q, ...]
    exec.compute_beta

    # [β1, β0, τ1, τ0, mem_ptr_q, ...]
    movup.4
    drop
    locaddr.3
    movdn.4

    # [β1, β0, τ1, τ0, mem_ptr_p, ...]
    exec.compute_alpha
    
    # assert α == β
    #
    # [α1, α0, β1, β0, ...]
    movup.2
    eq
    movdn.2
    eq
    and
    assert
    # [...]
end
