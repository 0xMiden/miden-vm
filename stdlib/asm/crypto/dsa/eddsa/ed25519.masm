use.std::crypto::hashes::rpo
use.std::sys

# ENCODING CONVENTIONS
# ================================================================================================
#
# - Byte data is stored in memory as packed u32 values in little-endian format
# - Each u32 packs four bytes: u32 = u32::from_le_bytes([b0, b1, b2, b3])
# - Unused bytes in the final u32 must be zero
# - Memory addresses supplied to this module must be word-aligned (divisible by 4)

# CONSTANTS
# ================================================================================================

const.EDDSA_VERIFY_EVENT=event("stdlib::crypto::dsa::eddsa25519::verify")

const.PK_LEN_FELTS=8       # 32.div_ceil(4)
const.K_DIGEST_LEN_FELTS=16 # 64.div_ceil(4)
const.SIG_LEN_FELTS=16     # 64.div_ceil(4)

# PROCEDURES
# ================================================================================================

#! Verifies an EdDSA (Ed25519) signature.
#!
#! This procedure uses deferred verification via a precompile. The actual cryptographic
#! verification is performed by the host, and the result is provided via the advice stack.
#!
#! Input:  `[pk_ptr, k_digest_ptr, sig_ptr, ...]`
#! Output: `[result, ...]`
#!
#! Where:
#! - `pk_ptr`:  word-aligned memory address containing the 32-byte Ed25519 public key
#! - `k_digest_ptr`: word-aligned memory address containing the 64-byte challenge hash `k`
#! - `sig_ptr`: word-aligned memory address containing the 64-byte Ed25519 signature
#! - `result`:  1 if the signature is valid, 0 otherwise
#!
#! All data must be stored in memory as packed u32 values (little-endian), with unused bytes
#! in the final u32 set to zero.
export.verify
    exec.verify_impl
    # => [COMM, TAG, result, ...]

    # Log the precompile request for deferred verification.
    exec.sys::log_precompile_request
    # => [result, ...]
end

# INTERNAL PROCEDURES
# ================================================================================================

#! Internal implementation of EdDSA verification via deferred computation.
#!
#! Emits an event to trigger the host precompile, reads the verification result from the
#! advice stack, and computes the commitment/tag pair used for deferred verification.
#!
#! Input:  `[pk_ptr, k_digest_ptr, sig_ptr, ...]`
#! Output: `[COMM, TAG, result, ...]`
#!
#! Where:
#! - `COMM`: `Rpo256(Rpo256(Rpo256(pk) || Rpo256(k_digest)) || Rpo256(sig))`
#! - `TAG`:  `[EDDSA_VERIFY_EVENT, result, 0, 0]`
#! - `result`: host verification result (1 or 0)
export.verify_impl
    emit.EDDSA_VERIFY_EVENT
    # => [pk_ptr, k_digest_ptr, sig_ptr, ...]

    # Read verification result from advice stack (provided by the host).
    adv_push.1
    # => [result, pk_ptr, k_digest_ptr, sig_ptr, ...]

    # Compute COMM_PK = Rpo256(pk)
    push.PK_LEN_FELTS movup.2 exec.rpo::hash_memory
    # => [COMM_PK, result, k_digest_ptr, sig_ptr]

    # Compute COMM_K = Rpo256(k_digest)
    push.K_DIGEST_LEN_FELTS movup.6 exec.rpo::hash_memory
    # => [COMM_K, COMM_PK, result, sig_ptr]

    # Merge COMM_PK and COMM_K into COMM_PK_K = Rpo256(Rpo256(pk) || Rpo256(k_digest))
    hmerge
    # => [COMM_PK_K, result, sig_ptr]

    # Compute COMM_SIG = Rpo256(sivg)
    push.SIG_LEN_FELTS movup.6 exec.rpo::hash_memory
    # => [COMM_SIG, COMM_PK_K, result]

    # Merge into final commitment COMM = Rpo256(COMM_PK_K || COMM_SIG)
    hmerge
    # => [COMM, result]

    # Create TAG = [EDDSA_VERIFY_EVENT, result, 0, 0]
    push.EDDSA_VERIFY_EVENT dup.5 push.0.0 swapw
    # => [COMM, TAG, result]
end
