use.std::crypto::dsa::rpo_stark::constants
use.std::crypto::dsa::rpo_stark::utils
use.std::crypto::hashes::rpo
use.std::crypto::stark::random_coin

#! Return the first half of the rate portion of the random coin state
#!
#! The random coin uses RPO to generate data. The RPO state is composed of 3
#! words, 2 words for the rate, and 1 word for the capacity. This procedure
#! returns the first word of the RPO state.
#!
#! Input: [...]
#! Output: [R1, ...]
#! Cycles: 6
export.get_rate_1
    padw exec.constants::r1_ptr mem_loadw
end

#! Return the second half of the rate portion of the random coin state
#!
#! The random coin uses RPO to generate data. The RPO state is composed of 3
#! words, 2 words for the rate, and 1 word for the capacity. This procedure
#! returns the first word of the RPO state.
#!
#! Input: [...]
#! Output: [R2, ...]
#! Cycles: 6
export.get_rate_2
    padw exec.constants::r2_ptr mem_loadw
end

#! Return the capacity portion of the random coin state
#!
#! The random coin uses RPO to generate data. The RPO state is composed of 3
#! words, 2 words for the rate, and 1 word for the capacity. This procedure
#! returns the first word of the RPO state.
#!
#! Input: [...]
#! Output: [C, ...]
#! Cycles: 6
export.get_capacity
    padw exec.constants::c_ptr mem_loadw
end

#! Initializes the seed for randomness generation by computing the hash of the proof context using
#! the trace length, number of queries, logarithm of blowup factor and the number of bits of
#! grinding. Currently, this part, as well as the rest of the STARK verifier assumes a blowup factor
#! equal to 8.
#! The ouput of this procedure is the capacity portion of the state after applying `hperm`.
#!
#! Input: [ptr, M, PK, ...]
#! Output: [C]
#! Cycles: 55
export.init_seed.2

    # Move the pointer behind the public inputs
    dup movdn.9

    # Store the message and public key as public inputs
    mem_storew
    swapw
    dup.8 add.1
    mem_storew
    swapw

    # Lay out the proof context
    push.0x0c00 # main segment width is 12 and there are 0 auxiliary segments
    movdn.4
    push.0x08 # main segment length is 8
    movdn.4
    push.0x01 # lower half of the modulus
    push.0xffffffff # upper half of the modulus

    # Hash the proof context, with the message as meta data
    # The reason for this hack is the need to have message as a public
    # input while not appearing in the main trace. Hence we use the meta
    # data field as workaround.
    push.4.0.0.0
    exec.constants::zero_zero_zero_four_word mem_storew
    movdnw.2

    hperm
    dropw dropw

    push.0x020407 # field extension degree || FRI folding factor || FRI remainder polynomial max degree
    exec.constants::grinding_factor
    exec.constants::blowup_factor

    # Number of FRI queries
    exec.constants::num_fri_queries

    movupw.2

    hperm
    dropw

    # Absorb
    movup.8
    mem_loadw
    padw
    hperm

    dropw
    swapw
    dropw
    # => [C]
end

#! Reseed the random coin with `DATA`
#!
#! Input: [DATA, ...]
#! Ouput: [...]
#! Cycles: 54
export.reseed
    # Load previous state and update it
    # --------------------------------------------------------------------------------------------
    exec.get_rate_1
    # => [R1, DATA, ...] (6 cycles)

    exec.random_coin::add_two_words
    # => [R1, ...] (16 cycles)

    exec.get_capacity
    swapw
    exec.get_rate_2
    # => [R2, R1, C, ...] (13 cycles)

    hperm
    # => [R2', R1', C', ...] (1 cycles)

    # Save the new state to memory
    # --------------------------------------------------------------------------------------------
    exec.constants::r2_ptr mem_storew
    dropw
    exec.constants::r1_ptr mem_storew
    dropw
    exec.constants::c_ptr mem_storew
    dropw
    # => [...] (18 cycles)
end

#! Reseed the random coin with `DATA`
#!
#! Input: [DATA, ...]
#! Ouput: [...]
#! Cycles: 71
export.reseed_with_salt
    # Load previous state and update it
    # --------------------------------------------------------------------------------------------
    exec.get_rate_1
    # => [R1, DATA, ...] (6 cycles)

    exec.random_coin::add_two_words
    # => [R1, ...] (16 cycles)

    exec.get_capacity
    swapw
    exec.get_rate_2
    padw adv_loadw 
    exec.random_coin::add_two_words
    # => [R2, R1, C, ...] (30 cycles)

    hperm
    # => [R2', R1', C', ...] (1 cycles)

    # Save the new state to memory
    # --------------------------------------------------------------------------------------------
    exec.constants::r2_ptr mem_storew
    dropw
    exec.constants::r1_ptr mem_storew
    dropw
    exec.constants::c_ptr mem_storew
    dropw
    # => [...] (18 cycles)
end


#! Draw constraint composition random coefficients and save them into memory in the region from
#! `compos_coef_ptr` `compos_coef_ptr + 112 - 1` as `(r1_1, r1_0, r0_1, r0_0)`
#!
#! Input: [compos_coef_ptr, ...]
#! Output: [...]
#! Cycles: 203
export.generate_constraint_composition_coefficients
    push.24
    swap
    exec.random_coin::generate_random_coefficients
    #=> [...]
end


#! Draw deep composition polynomial random coefficients and save them into memory in the region from
#! `deep_rand_coef_ptr` to `deep_rand_coef_ptr + 89 - 1` as `(0, 0, r0_1, r0_0)`
#! The number of coefficients is equal to:
#! 1. 12 * 2 Felt for the main and auxiliary traces.
#! 2. 12 * 2 Felt for constraint polynomial.
#! Total: 24 tuples of type (Felt, Felt)
#!
#! Input: [deep_rand_coef_ptr, ...]
#! Output: [...]
#! Cycles: 520
export.generate_deep_composition_random_coefficients
    push.24
    swap
    exec.random_coin::generate_random_coefficients_pad
    #=> [...]
end

# OOD POINT GENERATION
# =============================================================================================

#! Generate the OOD challenge point `z = (z0, z1)` and compute `z^N` where N is
#! the trace length. The resulting word `[(z_1, z_0)^N, z1, z0]` is stored in the
#! global memory address `exec.z_ptr` reservedfor it.
#!
#! Input: [X, ...]
#! Output: [...]
#! Note: The top word on the stack is consumed by this procedure.
#! Cycles: 21 + 10 * log(N)
export.generate_z_zN
    # Load z (first two felts of the random coin state) and log trace length N
    exec.constants::r1_ptr mem_loadw
    drop drop

    # 2^0
    dup.1 dup.1

    # 2^3
    dup.1 dup.1
    repeat.3
        dup.1 dup.1
        ext2mul
    end
    # => [z3_1, z3_0, z_1, z_0, z_1, z_0, ...]
    dup.1 dup.1
    repeat.1
        dup.1 dup.1
        ext2mul
    end
    # => [z4_1, z4_0, z3_1, z3_0, z_1, z_0, z_1, z_0, ...]

    dup.1 dup.1
    repeat.2
        dup.1 dup.1
        ext2mul
    end
    # => [z6_1, z6_0, z4_1, z4_0, z3_1, z3_0, z_1, z_0, z_1, z_0, ...]

    repeat.3
        ext2mul
    end

    # Store z and z^N
    exec.constants::z_ptr mem_storew
    dropw
end

# INDEX GENERATION
# =============================================================================================

#! Generate a list of `num_queries` number of random indices in the range
#! [0, lde_size] and store it in memory starting from `query_ptr`.
#! The list is stored as `(r, depth, y, y)` where `depth` is `log(lde_domain_size)`.
#!`depth` is needed when computing the deep queries.
#!
#! Input: [query_ptr, num_queries, ...]
#! Output: [...]
#!
#! Cycles: 282 + q * 250 + r * 29 where q = num_queries / 8 and r = num_queries % 8
#!
#! NOTE: This procedure is called first, and right after the PoW check, thus the first element
#! in the rate portion of the state is discarded.
#! NOTE: The cycle count can be estimated, using the fact that r < 8, via the more compact formula
#!  485 + 31 * num_queries
export.generate_list_indices
    # push the depth
    exec.constants::initial_lde_domain_log_size
    # push the mask
    exec.constants::initial_lde_domain_size sub.1
    #=> [mask, depth, query_ptr, num_queries] where depth = log(lde_size)

    # Get address holding the integers (this will later hold the FRI queries)
    movup.2
    #=> [query_ptr, mask, depth, num_queries]

    # Load the first half of the rate portion of the state of the random coin. We discard the first
    # element as it is used for PoW and use the remaining the 3.
    exec.get_rate_1
    exec.random_coin::generate_three_integers
    #=> [R, query_ptr, mask, depth, num_queries]

    # Load the second half of the rate portion of the state of the random coin.
    exec.constants::r2_ptr mem_loadw
    exec.random_coin::generate_four_integers
    #=> [R2, query_ptr, mask, depth, num_queries, ...]

    # Squeeze
    exec.constants::c_ptr mem_loadw
    exec.get_rate_1
    exec.get_rate_2
    hperm

    # Save the new state
    exec.constants::r2_ptr mem_storew
    dropw
    # => [R1, C]
    exec.constants::r1_ptr mem_storew
    swapw
    # => [C, R1]
    exec.constants::c_ptr mem_storew
    dropw
    #=> [R1, query_ptr, mask, depth, num_queries, ...]


    # Use `num_queries` to iterate.

    ## Subtract the 7 elements we have already generated above.
    movup.7
    push.7 sub

    ## Divide by 8 to get the number of iterations
    u32assert u32divmod.8
    #=> [remainder, quotient, X, query_ptr, mask, depth, ...]


    ## Save remainder for later use
    movdn.8
    #=> [quotient, X, query_ptr, mask, depth, remainder, ...]

    ## Use `quotient` to iterate
    dup movdn.8
    #=> [quotient, X, query_ptr, mask, depth, quotient, remainder, ...]

    push.0 neq
    while.true
        exec.random_coin::generate_four_integers
        exec.constants::r2_ptr mem_loadw
        exec.random_coin::generate_four_integers
        #=> [R2, query_ptr, mask, depth, num_remaining_iterations, remainder, ...]

        # Squeeze
        exec.constants::c_ptr mem_loadw
        exec.get_rate_1
        exec.get_rate_2
        hperm

        # Save the new state
        exec.constants::r2_ptr mem_storew
        dropw
        # => [R1, C]
        exec.constants::r1_ptr mem_storew
        swapw
        # => [C, R1]
        exec.constants::c_ptr mem_storew
        dropw
        #=> [R1, query_ptr, mask, depth, num_remaining_iterations, remainder, ...]

        movup.7 sub.1 dup movdn.8
        push.0 neq
    end
    #=> [R1, query_ptr, mask, depth, num_remaining_iterations, remainder, ...]

    ## Use remainder

    ### Put the remaining number of queries to generate in the appropriate stack position
    movup.8 movdn.7

    ### Load the second half of the rate portion of the state of the random coin.
    padw exec.constants::r2_ptr mem_loadw
    #=> [R2, R1, query_ptr, mask, depth, num_queries, ...]

    ### Iterate over remainder
    dup.11 sub.1 swap.12
    neq.0
    while.true
        movup.7
        u32split swap       # [r0_lo, r0_hi, R2, r3, r2, r1, ptr, mask, depth, ...]
        dup.10              # [mask, r0_lo, r0_hi, R2, r3, r2, r1, ptr, mask, depth, ...]
        u32and              # [r, r0_hi, R2, r3, r2, r1, ptr, mask, depth, ...]
        dup.11 swap         # [r, depth, r0_hi, R2, r3, r2, r1, ptr, mask, depth, ...]
        push.0 movdn.3      # [r, depth, r0_hi, 0, R2, r3, r2, r1, ptr, mask, depth, ...]

        # Store and update pointer
        dup.11 add.1 swap.12  # [ptr, r, depth, r0_hi, 0, R2, r3, r2, r1, ptr + 1, mask, depth, ...]
        mem_storew
        drop drop drop               # [x, R2, r3, r2, r1, ptr + 1, mask, depth, ...]
        dup.11 sub.1 swap.12
        push.0 neq
    end

    dropw dropw  dropw drop
end
