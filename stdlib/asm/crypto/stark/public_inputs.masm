use.std::crypto::stark::constants

#! Processes the public inputs.
#! 
#! This involves:
#!
#! 1. Loading from the advice stack the fixed-length public inputs and storing them in memory
#! starting from the address pointed to by `public_inputs_address_ptr`.
#! 2. Loading from the advice stack the variable-length public inputs, storing them temporarily
#! in memory, and then reducing them to an element in the challenge field using the auxiliary
#! randomness. This reduced value is then used to impose a boundary condition on the relevant
#! auxiliary column. 
#!
#! Note that the fixed length public inputs are stored as extension field elements while
#! the variable length ones are stored as base field elements.
#! Note also that, while loading the above, we compute the hash of the public inputs. The hashing
#! starts with capacity registers of the hash function set to `C` that is the result of hashing
#! the proof context.
#!
#! The output D, that is the digest of the above hashing, is then used in order to reseed
#! the random coin.
#!
#! It is worth noting that:
#!
#! 1. Only the fixed-length public inputs are stored for the lifetime of the verification procedure.
#!    The variable-length public inputs are stored temporarily, as this simplifies the task of
#!    reducing them using the auxiliary randomness. On the other hand, the resulting values from
#!    the aforementioned reductions are stored right after the fixed-length public inputs. These
#!    are stored in a word-aligned manner and padded with zeros if needed.
#! 2. The public inputs address is computed in such a way so as we end up with the following
#!    memory layout:
#!
#!    [..., a_0...a_{m-1}, b_0...b_{n-1}, alpha0, alpha1, beta0, beta1, OOD-evaluations-start, ...]
#!
#!    where:
#!
#!    1. [a_0...a_{m-1}] are the fixed-length public inputs stored as extension field elements. This
#!       section is double-word-aligned.
#!    2. [b_0...b_{n-1}] are the results of reducing the variable length public inputs using
#!       auxiliary randomness. This section is word-aligned.
#!    3. [alpha0, alpha1, beta0, beta1] is the auxiliary randomness.
#!    4. `OOD-evaluations-start` is the first field element of the section containing the OOD
#!       evaluations.
#! 3. Note that for each bus message in a group in the variable length public inputs, each
#!    message is expected to be padded to the next multiple of 8 and provided in reverse order.
#!    This has the benefit of making the reduction using the auxiliary randomness more efficient
#!    using `horner_eval_base`.
#!
#!
#! Input: [C, ...]
#! Output: [...]
proc.process_public_inputs
    exec.constants::get_procedure_digest_process_public_inputs_ptr dynexec
end

#! Computes the address where the public inputs are to be stored and returns it.
#!
#! In order to be able to call `eval_circuit`, we need to layout the inputs to
#! the constraint evaluation circuit in a contiguous region of memory (called `READ` section
#! in the ACE chiplet documentation) right before the region of memory storing the circuit
#! description (called `EVAL` section in the ACE chiplet documentation).
#! As the number of public inputs is a per-instance parameter, while the sizes of the OOD
#! evaluation frames and the number of auxiliary random values are fixed, we can lay out
#! the public inputs right before the auxiliary random values and OOD evaluations.
#! Hence the address where public inputs are stored is computed using a negative offset
#! from the address where the OOD are stored.
#! We compute two pointers, one to the public inputs and the other is for the portion
#! within the public inputs region storing the variable length public inputs. This will be
#! the region storing, temporarily, the variable length public inputs that are to be reduced
#! by the auxiliary randomness and, permanently, the results of the aforementioned reductions.
#!
#! Input: [num_var_len_pi_groups, num_fixed_len_pi, ...]
#! Output: [...]
proc.compute_and_store_public_inputs_address
    # 1) Get a pointer to where OOD evaluations are stored
    exec.constants::ood_evaluations_ptr
    # => [ood_evals_ptr, num_var_len_pi_groups, num_fixed_len_pi, ...]

    # 2) Compute the pointer to the reductions of the variable length public inputs
    #
    # We need to account for the number of variable-length
    # public inputs groups. For each group we allocate 2 slots and we pad with zeros so that
    # things are word aligned. As of now, we only have one group.
    # We also need to account for the auxiliary randomness i.e., 4 base field elements.
    sub.4               # 2 auxiliary random values
    swap mul.4 sub      # subtract number of variable length public input groups, with padding for word-alignment
    # => [res_var_len_pi_reductions_ptr, num_fixed_len_pi, ...]

    # 3) Compute the pointer to the public inputs
    #
    # We need to account for the fact that fixed-length public inputs are stored as extension field
    # elements. 
    dup
    movup.2
    mul.2
    sub
    # => [public_inputs_ptr, res_var_len_pi_reductions_ptr, ...]

    # 4) Store both pointers
    exec.constants::public_inputs_address_ptr mem_store
    exec.constants::variable_length_public_inputs_address_ptr mem_store
end

#! Loads 8 base field elements from the advice stack and saves them as extension field elements.
#!
#!
#! Input: [Y, Y, C, ptr, ...]
#! Output: [A1, A0, C, ptr + 16, ..]
proc.load_base_store_extension_double_word
    # 1) Load the first 4 base elements from the advice stack and save them temporarily 
    adv_loadw
    exec.constants::tmp1 mem_storew_be

    # 2) Represent the first 4 base field elements as elements in the quadratic extension field
    swapw
    exec.constants::zeroize_stack_word
    # => [0, 0, 0, 0, a3, a2, a1, a0, C, ptr, ...]
    movdn.6
    # => [0, 0, 0, a3, a2, a1, 0, a0, C, ptr, ...]
    movdn.4
    # => [0, 0, a3, a2, 0, a1, 0, a0, C, ptr, ...]
    movdn.2
    # => [0, a3, 0, a2, 0, a1, 0, a0, C, ptr, ...]

    # 3) Save the first 2 extension field elements
    swapw
    dup.12
    mem_storew_be

    # 4) Load the second 4 base elements from the advice stack and save them temporarily
    adv_loadw
    exec.constants::tmp2 mem_storew_be
    swapw
    # => [0, a3, 0, a2, a7, a6, a5, a4, C, ptr, ...]

    # 5) Save the second 2 extension field elements
    dup.12 add.4
    mem_storew_be

    
    # 6) Represent the second 4 base field elements as elements in the quadratic extension field
    exec.constants::zeroize_stack_word
    # => [0, 0, 0, 0, a7, a6, a5, a4, C, ptr, ...]
    movdn.6
    movdn.4
    movdn.2
    # => [0, a7, 0, a6, 0, a5, 0, a4, C, ptr, ...]

    # 7) Save the third 2 extension field elements
    #    We also load the first 4 base elements as a word for use by `hperm`
    swapw
    dup.12
    add.8
    mem_storew_be
    exec.constants::tmp1 mem_loadw_be
    swapw

    # 8) Save the fourth 2 extension field elements
    #    We also load the second 4 base elements as a word for use by `hperm` and update the pointer
    dup.12
    add.16 swap.13
    add.12
    mem_storew_be
    exec.constants::tmp2 mem_loadw_be
    # => [a7, a6, a5, a4, a3, a2, a1, a0, C, ptr, ...]
end
