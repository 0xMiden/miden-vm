use.std::crypto::stark::constants

#! Takes a query index and computes x := offset * domain_gen^index. It also computes the denominators
#! (x - z) and (x - gz).
#!
#! Input: [Y, Y, index, ...]
#! Output: [Z, Y, x, index, ...]  
#!
#! where:
#! - Z := [-gz1, x -gz0, -z1, x - z0]
#! - Y is a "garbage" word
#!
#! Cycles: 58
proc.compute_denominators
    # Compute x = offset * domain_gen^index
    exec.constants::get_lde_domain_info_word
    #=> [lde_size, depth, domain_gen, 0, Y, index, ...]
    movup.2
    dup.8
    exp.u32
    exec.constants::get_domain_offset mul
    #=> [x, lde_size, depth, 0, Y, index, ...]

    # Get z and gz from memory
    movdn.3
    #=> [lde_size, depth, 0, x, Y, index, ...]
    push.0
    exec.constants::tmp1 mem_loadw
    #=> [-z0, -gz0, -gz1, -z1, x, Y, index, ...]

    dup.4 add
    #=> [x-z0, -gz0, -gz1, -z1, x, Y, index, ...]
    movdn.3
    #=> [-gz0, -gz1, -z1, x-z0, x, Y, index, ...]

    movup.4 dup movdn.9
    #=> [x, -gz0, -gz1, -z1, x-z0, Y, x, index, ...]

    add swap
    #=> [-gz1, x - gz0, -z1, x-z0, Y, x, index, ...]
end

#! Computes the DEEP query.
#!
#! Input: [Z, X, Y, W, query_ptr, ...]
#! Ouput: [eval1, eval0, Y, query_ptr, ...]
#!
#! where:
#!
#! 1. X is [q_x_at_alpha_1, q_x_at_alpha_0, q_x_at_alpha_1, q_x_at_alpha_0]
#! 2. W is [q_gz_1, q_gz_0, q_z_1, q_z_0]
#!
#! Cycles: 62
proc.divide_and_add
    swapw
    #=> [X, Z, Y, W, query_ptr, ...]
    dupw.3
    #=> [W, X, Z, Y, query_ptr, ...]
    #=> [q_gz_1, q_gz_0, q_z_1, q_z_0, q_x_at_alpha_1, q_x_at_alpha_0, q_x_at_alpha_1, q_x_at_alpha_0, Z, Y, query_ptr, ...]

    movup.5 movup.5
    movup.5 movup.5
    #=> [q_z_1, q_z_0, q_x_at_alpha_1, q_x_at_alpha_0, p_gz_1, p_gz_0, q_x_at_alpha_1, q_x_at_alpha_0, Z, Y, query_ptr, ...]

    ext2add
    #=> [num0_1, num0_0, p_gz_1, p_gz_0, q_x_at_alpha_1, q_x_at_alpha_0, Z, Y, query_ptr, ...]

    movdn.9 movdn.9
    #=> [p_gz_1, p_gz_0, q_x_at_alpha_1, q_x_at_alpha_0, Z, num0_1, num0_0, Y, query_ptr, ...]

    ext2add
    #=> [num1_1, num1_0, Z, num0_1, num0_0, Y, query_ptr, ...]

    movup.3 movup.3
    ext2div
    #=> [res1_1, res1_0, z0_1, z0_0, num0_1, num0_0, Y, query_ptr, ...]
    movdn.5 movdn.5
    #=> [z0_1, z0_0, num0_1, num0_0, res1_1, res1_0, Y, query_ptr, ...]
    ext2div
    #=> [res0_1, res0_0, res1_1, res1_0, Y, query_ptr, ...]

    ext2add
    # => [eval1, eval0, Y, query_ptr, ...]
end

#! Prepares the stack for the computation of the DEEP composition polynomial FRI queries.
#!
#! It also performs some pre-computations that are common to all queries as an optimization.
#!
#! Input: [...]
#! Output: [Y, query_ptr, query_end_ptr, W, query_ptr, ...]
#!
#! where:
#!
#! 1. `Y` is a garbage word,
#! 2. `query_ptr` is a pointer to the memory region from where the query indices will be fetched
#!    and to where the computed FRI queries will be stored in a word-aligned manner,
#! 3. `query_end_ptr` is a memory pointer used to indicate the end of the memory region used in
#!    storing the computed FRI queries,
#! 4. `W` is the word `[q_z_0, q_z_1, q_gz_0, q_gz_1]` where `q_z = (q_z_0, q_z_1)` and
#!    `q_gz = (q_gz_0, q_gz_1)` represent the constant terms across all FRI queries computations.
export.prepare_stack_deep_queries_computation
    exec.constants::get_fri_queries_address
    # => [query_ptr, ...]

    padw exec.constants::ood_fixed_term_horner_evaluations_ptr mem_loadw
    # => [q_gz_1, q_gz_0, q_z_1, q_z_0, query_ptr, ...]
    # => [W, query_ptr, ...] where W is [q_gz_1, q_gz_0, q_z_1, q_z_0]

    # Get pointer to help test for the last query to be processed
    exec.constants::fri_com_ptr
    # => [query_end_ptr, W, query_ptr, ...]
    dup.5
    # => [query_ptr, query_end_ptr, W, query_ptr, ...]

    # Store pointers to alpha, memory region to store trace row for current query and a fresh
    # accumulator value i.e., (0, 0).
    push.0.0
    exec.constants::deep_rand_alpha_nd_ptr
    exec.constants::current_trace_row_ptr
    exec.constants::tmp2 mem_storew

    # Compute the negations of z and gz where z is the OOD point
    # We do it here as this computation is common to all queries.
    exec.constants::z_ptr mem_loadw
    # => [zN_1, zN_0, z1, z0, query_ptr, query_end_ptr, W, query_ptr, ...]
    drop drop
    neg swap neg  
    # => [-z0, -z1, query_ptr, query_end_ptr, W, query_ptr, ...]
    dup.1 exec.constants::get_trace_domain_generator mul
    # => [-gz1, -z0, -z1, query_ptr, query_end_ptr, W, query_ptr, ...]
    swap
    # => [-z0, -gz1, -z1, query_ptr, query_end_ptr, W, query_ptr, ...]
    dup exec.constants::get_trace_domain_generator mul
    # => [-gz0, -z0, -gz1, -z1, query_ptr, query_end_ptr, W, query_ptr, ...]
    swap
    # => [-z0, -gz0, -gz1, -z1, query_ptr, query_end_ptr, W, query_ptr, ...]
    # Save to temporary location `tmp1` for later use when computing the denominators
    exec.constants::tmp1 mem_storew
    # => [Y, query_ptr, query_end_ptr, W, query_ptr, ...]
end

#! Compute the DEEP composition polynomial FRI query at `index`.
#!
#! Input: [Y, X, index, query_ptr, query_end_ptr, W, query_ptr, ...]
#! Output: [?, Y, query_ptr+1, query_end_ptr, ...]
#!
#! where:
#! 1. `Y` is a garbage word,
#! 2. `X` is `[q_x_at_alpha_0, q_x_at_alpha_1, q_x_at_alpha_0, q_x_at_alpha_1]` where 
#!    `q_x = (q_x_0, q_x_1)` is the variable part of the query,
#! 3. `index` is the query index in the FRI domain,
#! 4. `query_ptr` is a pointer to the memory region from where the query indices will be fetched
#!    and to where the computed FRI queries will be stored in a word-aligned manner,
#! 5. `query_end_ptr` is a memory pointer used to indicate the end of the memory region used in
#!    storing the computed FRI queries,
#! 6. `W` is the word `[q_z_0, q_z_1, q_gz_0, q_gz_1]` where `q_z = (q_z_0, q_z_1)` and
#!    `q_gz = (q_gz_0, q_gz_1)` represent the constant terms across all FRI queries computations.
#! 7. `?` is a binary flag indicating if there are further queries to process.
export.compute_deep_query
        # 1) Compute x := offset * domain_gen^index and denominators (x - z) and (x - gz)
        #
        # Cycles: 58
        exec.compute_denominators
        #=> [Z, X, x, index, query_ptr, query_end_ptr, W, query_ptr, ...] where Z := [-gz1, x - gz0, -z1, x - z0]

        # 2) Compute final result
        #
        # Cycles: 62
        exec.divide_and_add
        #=> [eval1, eval0, x, index, query_ptr, query_end_ptr, W, query_ptr, ...]

        # 3) Store [poe, index, eval_1, eval_0] where poe := g^index = x / offset and prepare stack
        # for next iteration.

        ## a) Compute poe
        ##
        ## Cycles: 4
        movup.3 movup.3
        exec.constants::get_domain_offset_inv mul
        #=> [poe, index, eval1, eval0, query_ptr, query_end_ptr, W, query_ptr, ...]

        ## b) Store [eval0, eval1, index, poe]
        ##
        ## Cycles: 5
        dup.4 add.4 swap.5
        mem_storew
        #=> [poe, index, eval1, eval0, query_ptr+1, query_end_ptr, W, query_ptr, ...]

        ## c) Prepare stack for next iteration
        ##
        ## Cycles: 4
        dup.5 dup.5
        neq
        #=> [?, Y, query_ptr+1, query_end_ptr, ...]
end

#! Computes the DEEP composition polynomial FRI queries.
#!
#! Input: [...]
#! Output: [...]
proc.compute_deep_composition_polynomial_queries
    exec.constants::get_procedure_digest_compute_deep_composition_polynomial_queries_ptr dynexec
end