use.std::crypto::stark::constants

#! Takes a query index and computes x := offset * domain_gen^index. It also computes the denominators
#! (x - z) and (x - gz).
#!
#! Input: [Y, Y, index, ...]
#! Output: [Z, Y, x, index, ...]  
#!
#! where:
#! - Z := [-gz1, x -gz0, -z1, x - z0]
#! - Y is a "garbage" word
#!
#! Cycles: 58
proc.compute_denominators
    # Compute x = offset * domain_gen^index
    exec.constants::get_lde_domain_info_word
    #=> [lde_size, depth, domain_gen, 0, Y, index, ...]
    movup.2
    dup.8
    exp.u32
    exec.constants::get_domain_offset mul
    #=> [x, lde_size, depth, 0, Y, index, ...]

    # Get z and gz from memory
    movdn.3
    #=> [lde_size, depth, 0, x, Y, index, ...]
    push.0
    exec.constants::tmp1 mem_loadw
    #=> [-z0, -gz0, -gz1, -z1, x, Y, index, ...]

    dup.4 add
    #=> [x-z0, -gz0, -gz1, -z1, x, Y, index, ...]
    movdn.3
    #=> [-gz0, -gz1, -z1, x-z0, x, Y, index, ...]

    movup.4 dup movdn.9
    #=> [x, -gz0, -gz1, -z1, x-z0, Y, x, index, ...]

    add swap
    #=> [-gz1, x - gz0, -z1, x-z0, Y, x, index, ...]
end

#! Computes the DEEP query.
#!
#! Input: [Z, X, Y, W, query_ptr, ...]
#! Ouput: [eval1, eval0, Y, query_ptr, ...]
#!
#! where:
#!
#! 1. X is [q_x_at_alpha_1, q_x_at_alpha_0, q_x_at_alpha_1, q_x_at_alpha_0]
#! 2. W is [q_gz_1, q_gz_0, q_z_1, q_z_0]
#!
#! Cycles: 62
proc.divide_and_add
    swapw
    #=> [X, Z, Y, W, query_ptr, ...]
    dupw.3
    #=> [W, X, Z, Y, query_ptr, ...]
    #=> [q_gz_1, q_gz_0, q_z_1, q_z_0, q_x_at_alpha_1, q_x_at_alpha_0, q_x_at_alpha_1, q_x_at_alpha_0, Z, Y, query_ptr, ...]

    movup.5 movup.5
    movup.5 movup.5
    #=> [q_z_1, q_z_0, q_x_at_alpha_1, q_x_at_alpha_0, p_gz_1, p_gz_0, q_x_at_alpha_1, q_x_at_alpha_0, Z, Y, query_ptr, ...]

    ext2add
    #=> [num0_1, num0_0, p_gz_1, p_gz_0, q_x_at_alpha_1, q_x_at_alpha_0, Z, Y, query_ptr, ...]

    movdn.9 movdn.9
    #=> [p_gz_1, p_gz_0, q_x_at_alpha_1, q_x_at_alpha_0, Z, num0_1, num0_0, Y, query_ptr, ...]

    ext2add
    #=> [num1_1, num1_0, Z, num0_1, num0_0, Y, query_ptr, ...]

    movup.3 movup.3
    ext2div
    #=> [res1_1, res1_0, z0_1, z0_0, num0_1, num0_0, Y, query_ptr, ...]
    movdn.5 movdn.5
    #=> [z0_1, z0_0, num0_1, num0_0, res1_1, res1_0, Y, query_ptr, ...]
    ext2div
    #=> [res0_1, res0_0, res1_1, res1_0, Y, query_ptr, ...]

    ext2add
    # => [eval1, eval0, Y, query_ptr, ...]
end

#! Compute the DEEP composition polynomial FRI queries.
#!
#! Input: [...]
#! Output: [...]
proc.compute_deep_composition_polynomial_queries
    exec.constants::get_dynamic_procedure_0_ptr dynexec
end