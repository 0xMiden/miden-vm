use.std::crypto::stark::constants

#! Takes a query index and computes x := offset * domain_gen^index. It also computes the denominators
#! (x - z) and (x - gz).
#!
#! Input: [Y, Y, index, ...]
#! Output: [Z, Y, x, index, ...]  
#!
#! where:
#! - Z := [-gz1, x -gz0, -z1, x - z0]
#! - Y is a "garbage" word
#!
#! Cycles: 58
proc.compute_denominators
    # Compute x = offset * domain_gen^index
    exec.constants::get_lde_domain_info_word
    #=> [lde_size, depth, domain_gen, 0, Y, index, ...]
    movup.2
    dup.8
    exp.u32
    exec.constants::get_domain_offset mul
    #=> [x, lde_size, depth, 0, Y, index, ...]

    # Get z and gz from memory
    movdn.3
    #=> [lde_size, depth, 0, x, Y, index, ...]
    push.0
    exec.constants::tmp1 mem_loadw
    #=> [-z0, -gz0, -gz1, -z1, x, Y, index, ...]

    dup.4 add
    #=> [x-z0, -gz0, -gz1, -z1, x, Y, index, ...]
    movdn.3
    #=> [-gz0, -gz1, -z1, x-z0, x, Y, index, ...]

    movup.4 dup movdn.9
    #=> [x, -gz0, -gz1, -z1, x-z0, Y, x, index, ...]

    add swap
    #=> [-gz1, x - gz0, -z1, x-z0, Y, x, index, ...]
end

#! Computes the DEEP query.
#!
#! Input: [Z, X, Y, W, query_ptr, ...]
#! Ouput: [eval1, eval0, Y, query_ptr, ...]
#!
#! where:
#!
#! 1. X is [q_x_at_alpha_1, q_x_at_alpha_0, q_x_at_alpha_1, q_x_at_alpha_0]
#! 2. W is [q_gz_1, q_gz_0, q_z_1, q_z_0]
#!
#! Cycles: 62
proc.divide_and_add
    swapw
    #=> [X, Z, Y, W, query_ptr, ...]
    dupw.3
    #=> [W, X, Z, Y, query_ptr, ...]
    #=> [q_gz_1, q_gz_0, q_z_1, q_z_0, q_x_at_alpha_1, q_x_at_alpha_0, q_x_at_alpha_1, q_x_at_alpha_0, Z, Y, query_ptr, ...]

    movup.5 movup.5
    movup.5 movup.5
    #=> [q_z_1, q_z_0, q_x_at_alpha_1, q_x_at_alpha_0, p_gz_1, p_gz_0, q_x_at_alpha_1, q_x_at_alpha_0, Z, Y, query_ptr, ...]

    ext2add
    #=> [num0_1, num0_0, p_gz_1, p_gz_0, q_x_at_alpha_1, q_x_at_alpha_0, Z, Y, query_ptr, ...]

    movdn.9 movdn.9
    #=> [p_gz_1, p_gz_0, q_x_at_alpha_1, q_x_at_alpha_0, Z, num0_1, num0_0, Y, query_ptr, ...]

    ext2add
    #=> [num1_1, num1_0, Z, num0_1, num0_0, Y, query_ptr, ...]

    movup.3 movup.3
    ext2div
    #=> [res1_1, res1_0, z0_1, z0_0, num0_1, num0_0, Y, query_ptr, ...]
    movdn.5 movdn.5
    #=> [z0_1, z0_0, num0_1, num0_0, res1_1, res1_0, Y, query_ptr, ...]
    ext2div
    #=> [res0_1, res0_0, res1_1, res1_0, Y, query_ptr, ...]

    ext2add
    # => [eval1, eval0, Y, query_ptr, ...]
end

#! Compute the DEEP composition polynomial FRI queries.
#!
#! Input: [...]
#! Output: [...]
#! Cycles: 386 + num_queries * 414
export.compute_deep_composition_polynomial_queries

    exec.constants::get_fri_queries_address
    # => [query_ptr, ...]

    padw exec.constants::ood_fixed_term_horner_evaluations_ptr mem_loadw
    # => [q_gz_1, q_gz_0, q_z_1, q_z_0, query_ptr, ...]
    # => [W, query_ptr, ...] where W is [q_gz_1, q_gz_0, q_z_1, q_z_0]

    # Get pointer to help test for the last query to be processed
    exec.constants::fri_com_ptr
    # => [query_end_ptr, W, query_ptr, ...]
    dup.5
    # => [query_ptr, query_end_ptr, W, query_ptr, ...]

    # Store pointers to alpha, memory region to store trace row for current query and a fresh
    # accumulator value i.e., (0, 0).
    push.0.0
    exec.constants::deep_rand_alpha_nd_ptr
    exec.constants::current_trace_row_ptr
    exec.constants::tmp2 mem_storew

    # Compute the negations of z and gz where z is the OOD point
    # We do it here as this computation is common to all queries.
    exec.constants::z_ptr mem_loadw
    # => [zN_1, zN_0, z1, z0, query_ptr, query_end_ptr, W, query_ptr, ...]
    drop drop
    neg swap neg  
    # => [-z0, -z1, query_ptr, query_end_ptr, W, query_ptr, ...]
    dup.1 exec.constants::get_trace_domain_generator mul
    # => [-gz1, -z0, -z1, query_ptr, query_end_ptr, W, query_ptr, ...]
    swap
    # => [-z0, -gz1, -z1, query_ptr, query_end_ptr, W, query_ptr, ...]
    dup exec.constants::get_trace_domain_generator mul
    # => [-gz0, -z0, -gz1, -z1, query_ptr, query_end_ptr, W, query_ptr, ...]
    swap
    # => [-z0, -gz0, -gz1, -z1, query_ptr, query_end_ptr, W, query_ptr, ...]
    # Save to temporary location `tmp1` for later use when computing the denominators
    exec.constants::tmp1 mem_storew
    # => [Y, query_ptr, query_end_ptr, W, query_ptr, ...]                   # (Cycles: 28)

    push.1
    while.true
        # I)
        #
        # Load the (main, aux, constraint)-traces rows associated with the current query and get
        # the index of the query.
        #
        # Cycles: 280
        exec.load_query_row
        #=>[Y, X, index, query_ptr, query_end_ptr, W, query_ptr, ...]

        # II)
        #
        # Compute x := offset * domain_gen^index and denominators (x - z) and (x - gz)
        #
        # Cycles: 58
        exec.compute_denominators
        #=> [Z, X, x, index, query_ptr, query_end_ptr, W, query_ptr, ...] where Z := [-gz1, x - gz0, -z1, x - z0]

        # III)
        # Compute final result
        #
        # Cycles: 62
        exec.divide_and_add
        #=> [eval1, eval0, x, index, query_ptr, query_end_ptr, W, query_ptr, ...]

        # IV)
        #
        # Store [poe, index, eval_1, eval_0] where poe := g^index = x / offset and prepare stack
        # for next iteration.

        ## a) Compute poe
        ##
        ## Cycles: 4
        movup.3 movup.3
        exec.constants::get_domain_offset_inv mul
        #=> [poe, index, eval1, eval0, query_ptr, query_end_ptr, W, query_ptr, ...]

        ## b) Store [eval0, eval1, index, poe]
        ##
        ## Cycles: 5
        dup.4 add.4 swap.5
        mem_storew
        #=> [poe, index, eval1, eval0, query_ptr+1, query_end_ptr, W, query_ptr, ...]

        ## c) Prepare stack for next iteration
        ##
        ## Cycles: 4
        dup.5 dup.5
        neq
        #=> [?, Y, query_ptr+1, query_end_ptr, ...]
    end
    dropw dropw drop drop drop
end

proc.load_query_row
    exec.constants::get_dynamic_procedure_0_ptr dynexec
end