use std::crypto::stark::verifier

#! Verifies a STARK proof.
#!
#! The purpose of the following verifier is to serve as a generic core around which a specific
#! verifier can be built. It expects the following parameters on the stack from the caller:
#!
#! 1. `[D0, D1, D2, D3]` which are respectively the digests for dynamic execution of procedures
#!   i. `compute_deep_composition_polynomial_queries`
#!   ii. `execute_constraint_evaluation_check`
#!   iii. `process_row_ood_evaluations`
#!   iv. `process_public_inputs`
#! 2. `num_constraints` which is the number of constraints in the AIR
#! 3. `trace_info` which is a field element encoding the layout of the AIR
#! 4. `num_fixed_len_pi` is the number of fixed length public inputs of the AIR
#!
#! In addition to the above parameters, the verifier expects the following auxiliary proof parameters:
#!
#! 1. `log(trace_length)`, the logarithm base 2 of the trace length
#! 2. `num_queries`, the number of FRI queries
#! 3. `grinding`, the number of bits of grinding i.e., proof-of-work
#!
#! The following simplifying assumptions are currently made and hardcoded:
#!
#! - The blowup factor is set to 8.
#! - The maximal allowed degree of the remainder polynomial is 127.
#! - To boost soundness, the protocol is run on a quadratic extension field and this means that
#!   the OOD evaluation frame is composed of elements in a quadratic extension field i.e. tuples.
#!   Similarly, elements of the auxiliary trace are quadratic extension field elements. The random
#!   values for computing random linear combinations are also in this extension field.
#!
#! Inputs:  [D3, D2, D1, D0, log(trace_length), num_queries, grinding, num_constraints, trace_info, num_fixed_len_pi]
#! Outputs: []
pub use verifier::verify
