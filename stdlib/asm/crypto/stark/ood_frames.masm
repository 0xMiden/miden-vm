const.Z_PTR=4294967291
const.OOD_TRACE_CURRENT_PTR=4294965000
const.OOD_TRACE_NEXT_PTR=4294965041
const.OOD_CONSTRAINT_EVALS_PTR=4294965082

#! Loads and computes ROW_HASH which is the hash of either
#! [ood_main_trace_frame.current(), aux_trace_frame.current()]
#! or [ood_main_trace_frame.next(), aux_trace_frame.next()]
#!
#! Input: [ood_frame_ptr, ...]
#! Output: [ROW_HASH, ...]
#! Cycles: 102
export.load_ood_eval_frame
    push.1.0.0.0
    push.0.0.0.0
    push.0.0.0.0
    repeat.20
        adv_pipe
    end

    # adv_pipe the last two elements
    dropw dropw
    adv_push.1
    adv_push.1
    push.1
    push.0
    dup.8
    add.1
    swap.9
    mem_storew
    push.0.0.0.0
    hperm

    dropw
    swapw
    dropw
    movup.4
    drop
end


#! Loads OOD evaluation frame (both current and next rows) into memory and reseeds the random coin.
#!
#! Input: [...]
#! Output: [CURENT_ROW_HASH, NEXT_ROW_HASH, ...]
#! Cycles: 207
export.load_evaluation_frame
    # Read [ood_main_trace_frame.current(), aux_trace_frame.current()]
    # We have 72 main trace columns and 9 aux trace columns for a total of 162 base field elements
    # 162 = 20 * 8 + 2
    # [ood_main_trace_frame.current(), aux_trace_frame.current()] is stored in
    # OOD_TRACE_CURRENT_PTR to OOD_TRACE_CURRENT_PTR + 41 - 1.
    # They are stored from the stack as (a1_1, a1_0, a0_1, a0_0) except for the last tuple
    # OOD_TRACE_CURRENT_PTR + 40 which is stored from the stack as (a1, a0, 1, 0)

    push.OOD_TRACE_CURRENT_PTR
    exec.load_ood_eval_frame
    #=> [CURENT_ROW_HASH, ...]


    # Read [ood_main_trace_frame.next(), aux_trace_frame.next()]
    # We have 72 main trace columns and 9 aux trace columns for a total of 162 base field elements
    # 162 = 20 * 8 + 2
    # [ood_main_trace_frame.next(), aux_trace_frame.next()] is stored in OOD_TRACE_CURRENT_PTR + 41
    # to OOD_TRACE_CURRENT_PTR + 2 * 41 - 1.
    # They are stored from the stack as (a1_1, a1_0, a0_1, a0_0) except for the last tuple
    # which is stored from the stack as (a1, a0, 1, 0)

    push.OOD_TRACE_NEXT_PTR
    exec.load_ood_eval_frame

    swapw
    #=> [CURENT_ROW_HASH, NEXT_ROW_HASH, ...]
end

#! Loads OOD constraint composition polynomial evaluation columns into memory and reseeds the random
#! coin.
#!
#! Input: [...]
#! Output: [EVAL_HASH, ...]
#! Cycles: 29
export.load_constraint_evaluations
    # Read OOD constraint evaluations. These are 8 ExtFelt `value_i` such that the value of
    # constraint evaluation function at `z` `H(z)` equals `\sum_0^7 z^i value_i`.
    # The values are stored from locaddr.2334 to locaddr.2337
    push.OOD_CONSTRAINT_EVALS_PTR
    push.0.0.0.0
    push.0.0.0.0
    push.0.0.0.0
    adv_pipe
    adv_pipe
    dropw
    swapw
    dropw
    movup.4
    drop
    # => [CONSTR_EVAL_HASH, ...]
end

#! Computes the H(z) evaluation of the constraint composition polynomial at the OOD element z.
#!
#! Input: [...]
#! Output: [res1, res0, ...]
#! Cycles: 118
export.compute_Hz
    # TODO: remove this
    push.OOD_CONSTRAINT_EVALS_PTR
    add.4
    repeat.3
        push.0.0.0.0
    end

    # Compute `H(z)`
    ## Load `value_i`'s

    dup.12
    sub.4
    mem_loadw
    swapw.2

    dup.12
    sub.3
    mem_loadw
    swapw

    dup.12
    sub.2
    mem_loadw

    movup.12
    sub.1
    push.0.0.0.0
    movup.4
    mem_loadw

    ## Load z
    push.0.0.0.0
    mem_loadw.Z_PTR
    drop drop
    # => [z1, z0, value_7, ... ,value_0]

    # Horner evaluation
    # TODO: maybe can be done faster in another way
    repeat.6
        dup
        movdn.6
        dup.1
        movdn.7
        # => [z1, z0, value_7, value_6, z1, z0, value_5, ... ,value_0]

        ext2mul
        ext2add
        # => [acc1, acc0, z1, z0, value_5, ... ,value_0]

        movup.3
        movup.3
        # => [z1, z0, acc1, acc0, value_5, ... ,value_0]
    end
    ext2mul
    ext2add
end
