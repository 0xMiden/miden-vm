const.R2_PTR=4294967294
const.R1_PTR=4294967295
const.C_PTR=4294967293

const.Z_PTR=4294967291
const.TMP0=4294967287
const.LDE_SIZE_PTR=4294967292

const.ZERO_WORD_PTR=4294967278
const.ZERO_ZERO_ZERO_ONE_PTR=4294967277

const.TRACE_LENGTH_LOG_PTR=4294959999
const.TRACE_LENGTH_PTR=4294959998

#! Helper procedure to compute addition of two words component-wise.
#! Input: [b3, b2, b1, b0, a3, a2, a1, a0]
#! Output: [c3, c2, c1, c0]
#!
#! Cycles: 16
proc.add_two_words
    movup.3
    movup.7
    add
    #=> [c0, b3, b2, b1, a3, a2, a1]

    movup.3
    movup.6
    add
    #=> [c1, c0, b3, b2, a3, a2]

    movup.3
    movup.5
    add
    #=> [c2, c1, c0, b3, a3]

    movup.3
    movup.4
    add
    #=> [c3, c2, c1, c0]
end

#! Return the first half of the rate portion of the random coin state
#!
#! Input: [...]
#! Output: [R1]
export.get_rate_1
    mem_loadw.R1_PTR
end

#! Initializes the seed for randomness generation by computing the hash of the proof context using
#! the trace length, number of queries, logarithm of blowup factor and the number of bits of
#! grinding. Currently, this part, as well as the rest of the STARK verifier has the blowup factor
#! fixed to 8, number of queries to 27.
#! The ouput of this procedure is the capacity portion of the state after applying `hperm`.
#!
#! Input: [log(trace_length), num_queries, blowup, grinding, ...]
#! Output: [C]
#! Cycles: 104
export.init_seed

    # Pre-load constants used by hperm into memory and initialize the state of the random coin to zeros.
    # Since memory beyond 3 * 2^30 does not have any special meaning, we can use the memory region
    # starting from address 2^32 - 1 in decreasing order to hold constants that are used throughout
    # the `verify` procedure.
    #
    # Cycles: 22
    push.0.0.0.0
    mem_storew.ZERO_WORD_PTR
    mem_storew.C_PTR
    mem_storew.R1_PTR
    mem_storew.R2_PTR

    drop
    push.1
    swap.3
    mem_storew.ZERO_ZERO_ZERO_ONE_PTR
    dropw
    #=> [log(trace_length), num_queries, log(blowup), grinding]


    # Create the initial seed for randomness generation from proof context

    ## Compute trace_length
    ## Cycles: 20
    dup
    pow2
    u32split assertz
    #=> [trace_length, log(trace_length), num_queries, log(blowup), grinding]

    ## Save the trace length and its log to memory
    dup.0 mem_store.TRACE_LENGTH_PTR
    dup.1 mem_store.TRACE_LENGTH_LOG_PTR

    ## Assert blowup is equal to 8
    ##  Cycles: 6
    swap
    dup.3
    dup
    push.3
    assert_eq

    ## Compute log(lde_size) and lde_size and store them
    ## Cycles: 32
    add
    swap
    movup.3
    pow2
    dup
    movdn.4
    swap
    dup
    movdn.3
    mul
    push.0
    movdn.2
    push.0
    movdn.2
    mem_storew.LDE_SIZE_PTR
    #=> [lde_size, log(lde_size), 0, 0, trace_length, num_queries, blowup, grinding]

    # Construct the proof context
    # Cycles: 9
    dropw
    push.1208027408
    push.1
    push.4294967295
    push.132103
    swapw

    # Hash proof context
    # Cycles: 15
    push.1.0.0.0
    #=> [0, 0, 0, 1, B, A, ..]
    swapw.2
    swapw
    #=> [B, A, 0, 0, 0, 1, ..]
    hperm
    dropw
    dropw
    #=> [C]
end

#! Reseed the random coin with `DATA`
#!
#! Input: [DATA, ...]
#! Ouput: [...]
#! Cycles: 54
export.reseed
    push.0.0.0.0
    mem_loadw.R1_PTR
    exec.add_two_words

    push.0.0.0.0
    mem_loadw.C_PTR
    swapw

    push.0.0.0.0
    mem_loadw.R2_PTR

    hperm

    mem_storew.R2_PTR
    dropw

    mem_storew.R1_PTR
    dropw

    mem_storew.C_PTR
    dropw
end


# COEFFICIENT GENERATION
# =============================================================================================

#! Generates a `num_tuples` tuples of random field elements and stores them in memory
#! starting from address `dest_ptr`. Each memory address holds two tuples.
#! TODO: Generalize by keeping track of something similar to the `output` variable in `RpoRandomCoin`
#! so that we keep track of already used randomness and know when there is a need to apply `hperm`.
#!
#! Input: [dest_ptr, num_tuples, ...]
#! Output: [...]
#!
#! Cycles: 69 + (22 * num_tuples) / 4
proc.generate_random_coefficients

    # Compute the loop counter. We use checked division to make sure the number is a multiple of 4.
    # If we use field division and num_tuples is not a multiple of 4 then we will enter into
    # a very large loop with high probability.
    push.0 dup movup.2 movup.3
    u32checked_divmod.4
    assertz
    neg
    #=> [loop_ctr, dest_ptr, x, x, ...]
    # where loop_ctr = - num_tuples / 4; we negate the counter so that we can count up to 0


    push.0.0.0.0
    mem_loadw.R1_PTR
    dup.5 mem_storew

    push.0.0.0.0
    mem_loadw.R2_PTR
    dup.9 add.1 mem_storew
    #=> [R2, R1, loop_ctr, dest_ptr, 0, 0, ..]

    push.0.0.0.0
    mem_loadw.C_PTR
    swapdw
    swapw
    swap add.2 swap
    #=> [loop_ctr, dest_ptr, 0, 0, R1, C, R2, ..]

    add.1 dup neq.0

    while.true

        swapw.3 hperm
        #=> [R2, R1, C, loop_ctr, dest_ptr, x, x, ...]

        # save R2 to mem[dest+1]; we use dup.13 here because it takes only 1 cycle
        dup.13 add.1 mem_storew
        #=> [R2, R1, C, loop_ctr, dest_ptr, x, x, ...]

        # save R1 to mem[dest]
        swapw dup.13 mem_storew swapw
        #=> [R2, R1, C, loop_ctr, dest_ptr, x, x, ...]

        # update destination pointer and loop counter
        swapw.3
        #=> [loop_ctr, dest_ptr, x, x, R1, C, R2, ...]

        swap add.2 swap
        #=> [loop_ctr, dest_ptr+2, x, x, R1, C, R2, ...]

        add.1 dup
        #=> [loop_ctr+1, loop_ctr+1, dest_ptr+2, x, x, R1, C, R2, ...]

        neq.0
    end

    # Save the new state of the random coin
    dropw
    mem_storew.R1_PTR
    dropw
    mem_storew.C_PTR
    dropw
    mem_storew.R2_PTR
    dropw
    #=> [...]
end

#! Draw a list of random extension field elements related to the auxiliary trace and store the list
#! in memory from `aux_rand_elem_ptr` to `aux_rand_elem_ptr + 8 - 1`
#!
#! Input: [aux_rand_elem_ptr, ...]
#! Output: [...]
#! Cycles: 150
export.generate_aux_randomness

    push.16 swap
    exec.generate_random_coefficients
    #=> [...]
end

#! Draw constraint composition random coefficients and save them into memory in the region from
#! `compos_coef_ptr` `compos_coef_ptr + 235 - 1` as `(r1_1, r1_0, r0_1, r0_0)`
#!
#! Input: [compos_coef_ptr, ...]
#! Output: [...]
#! Cycles: 2609
export.generate_constraint_composition_coefficients

    push.472
    swap
    exec.generate_random_coefficients
    #=> [...]
end

#! Draw deep composition polynomial random coefficients and save them into memory in the region from
#! `deep_rand_coef_ptr` `deep_rand_coef_ptr + 86 - 1` as `(r1_1, r1_0, r0_1, r0_0)`
#! The number of equal coefficients is equal to:
#! (72 + 9) * 4 Felt for the trace.
#! 8 * 2 Felt for constraint polynomial.
#! 2 Felt for degree correction.
#! Total: 172 tuples of type (Felt, Felt)
#!
#! Input: [deep_rand_coef_ptr, ...]
#! Output: [...]
#! Cycles: 992
export.generate_deep_composition_random_coefficients

    push.172
    swap
    exec.generate_random_coefficients
    #=> [...]
end


# OOD POINT GENERATION
# =============================================================================================

#! Generate the OOD challenge point `z = (z0, z1)` and compute `z^8`. The resulting word
#! `[z^8_1, z^8_0, z1, z0]` is stored in the global memory address reserved for it.
#!
#! Input: [...]
#! Output: [...]
#! Cycles: 22
export.generate_z_z8
    # z is just the first two felts of the random coin state
    mem_loadw.R1_PTR
    drop drop

    # Store OOD challenge z and z^8 as [z^8_1, z^8_0, z1, z0]
    dup.1
    dup.1
    repeat.3
        dup.1
        dup.1
        ext2mul
    end
    mem_storew.Z_PTR
    dropw
end


# INDEX GENERATION
# =============================================================================================

# Helper function for generating a list of indices that takes a word of random felts and saves
# to memory region referenced by `ptr` 4 random integers in the range 0..=(mask+1).
# `depth` is saved next to each of the 4 integers for use in subsequent steps.
#
# Input: [R, ptr, mask, depth, ...]
# Output:[...]
#
# Cycles: 100
proc.generate_four_integers
    # Get the first random felt
    dup.3               # [r0, R1, ptr, mask, depth, ...]
    u32split swap       # [r0_lo, r0_hi, R1, ptr, mask, depth, ...]
    dup.7               # [mask, r0_lo, r0_hi, R1, ptr, mask, depth, ...]
    u32checked_and      # [r, r0_hi, R1, ptr, mask, depth, ...]
    dup.8 swap          # [r, depth, r0_hi, R1, ptr, mask, depth, ...]
    push.0 movdn.3      # [r, depth, r0_hi, 0, R1, ptr, mask, depth, ...]

    # Store and update pointer
    dup.8 add.1 swap.9  # [ptr, r, depth, r0_hi, 0, R1, ptr + 1, mask, depth, ...]
    mem_storew
    dropw               # [R1, ptr + 1, mask, depth, ...]

    # Get the second random felt
    dup.2               # [r1, R1, ptr, mask, depth, ...]
    u32split swap       # [r1_lo, r1_hi, R1, ptr, mask, depth, ...]
    dup.7               # [mask, r1_lo, r1_hi, R1, ptr, mask, depth, ...]
    u32checked_and      # [r, r1_hi, R1, ptr, mask, depth, ...]
    dup.8 swap          # [r, depth, r1_hi, R1, ptr, mask, depth, ...]
    push.0 movdn.3      # [r, depth, r1_hi, 0, R1, ptr, mask, depth, ...]

    # Store and update pointer
    dup.8 add.1 swap.9  # [ptr, r, depth, r1_hi, 0, R1, ptr + 1, mask, depth, ...]
    mem_storew
    dropw               # [R1, ptr + 1, mask, depth, ...]

    # Get the third random felt
    dup.1
    u32split swap
    dup.7
    u32checked_and
    dup.8 swap
    push.0 movdn.3

    # Store and update pointer
    dup.8 add.1 swap.9
    mem_storew
    dropw

    # Get the fourth random felt
    dup
    u32split swap
    dup.7
    u32checked_and
    dup.8 swap
    push.0 movdn.3

    # Store and update pointer
    dup.8 add.1 swap.9
    mem_storew
    dropw
end

# Helper function for generating a list of indices that takes a word of random felts and saves
# to memory region referenced by `ptr` 3 random integers in the range 0..=(mask+1).
# `depth` is saved next to each of the 3 integers for use in subsequent steps.
#
# Input: [R, ptr, mask, depth, ...]
# Output:[...]
#
# Cycles: 75
proc.generate_three_integers
    # Get the first random felt
    dup.3               # [r0, R1, ptr, mask, depth, ...]
    u32split swap       # [r0_lo, r0_hi, R1, ptr, mask, depth, ...]
    dup.7               # [mask, r0_lo, r0_hi, R1, ptr, mask, depth, ...]
    u32checked_and      # [r, r0_hi, R1, ptr, mask, depth, ...]
    dup.8 swap          # [r, depth, r0_hi, R1, ptr, mask, depth, ...]
    push.0 movdn.3      # [r, depth, r0_hi, 0, R1, ptr, mask, depth, ...]

    # Store and update pointer
    dup.8 add.1 swap.9  # [ptr, r, depth, r0_hi, 0, R1, ptr + 1, mask, depth, ...]
    mem_storew
    dropw               # [R1, ptr + 1, mask, depth, ...]

    # Get the second random felt
    dup.2               # [r1, R1, ptr, mask, depth, ...]
    u32split swap       # [r1_lo, r1_hi, R1, ptr, mask, depth, ...]
    dup.7               # [mask, r1_lo, r1_hi, R1, ptr, mask, depth, ...]
    u32checked_and      # [r, r1_hi, R1, ptr, mask, depth, ...]
    dup.8 swap          # [r, depth, r1_hi, R1, ptr, mask, depth, ...]
    push.0 movdn.3      # [r, depth, r1_hi, 0, R1, ptr, mask, depth, ...]

    # Store and update pointer
    dup.8 add.1 swap.9  # [ptr, r, depth, r1_hi, 0, R1, ptr + 1, mask, depth, ...]
    mem_storew
    dropw               # [R1, ptr + 1, mask, depth, ...]

    # Get the third random felt
    dup.1
    u32split swap
    dup.7
    u32checked_and
    dup.8 swap
    push.0 movdn.3

    # Store and update pointer
    dup.8 add.1 swap.9
    mem_storew
    dropw
end

#! Generate a list of random indices in the range [0, lde_size] and store it in memory starting
#! from `query_ptr`. The list is stored as `(r, depth, y, y)` where `depth` is
#! `log(lde_domain_size)`. `depth` is needed when computing the deep queries.
#! TODO: the case of duplicate queries
#! TODO: generalize to any number of queries
#!
#! Input: [query_ptr, ...]
#! Output: [...]
#!
#! Cycles: 797
export.generate_list_indices
    # Create mask
    push.0.0.0.0
    mem_loadw.TMP0
    movup.2 drop
    movup.2 drop
    sub.1
    #=> [mask, depth, query_ptr] where depth = log(lde_size)

    # Get address holding the integers (this will later hold the FRI queries)
    movup.2
    #=> [query_ptr, mask, depth]

    # Load the state of the random coin
    push.0.0.0.0
    mem_loadw.R1_PTR

    repeat.3
        exec.generate_four_integers
        #=> [X, query_ptr, mask, depth, ...]

        mem_loadw.R2_PTR
        exec.generate_four_integers
        #=> [X, query_ptr, mask, depth, ...]

        mem_loadw.C_PTR
        push.0.0.0.0
        mem_loadw.R1_PTR
        push.0.0.0.0
        mem_loadw.R2_PTR

        hperm

        mem_storew.R2_PTR
        dropw
        swapw
        mem_storew.C_PTR
        dropw
        mem_storew.R1_PTR

    end

    exec.generate_three_integers
    dropw drop drop drop
end


# PROOF-OF-WORK CHECK
# =============================================================================================

#! Check that the Proof-of-Work contained in the nonce is equal to the required number
#! of bits prescribed by grinding bits. The grinding factor is assumed to be less than 32.
#!
#! Input: [grinding_factor, ...]
#! Output: [...]
#! Cycles: 73
export.check_pow

    # Compute the mask.
    pow2
    u32checked_sub.1
    #=> [mask, ...]

    # Load Capacity portion
    push.0.0.0.0
    mem_loadw.C_PTR

    # Load first half of rate portion and add pow witness to first element of rate
    push.0.0.0.0
    mem_loadw.R1_PTR
    adv_push.1
    dup.4
    add
    swap.4
    drop

    # Load the second half of rate portion and apply the permutation
    push.0.0.0.0
    mem_loadw.R2_PTR
    hperm
    #=> [R2, R1, C, mask, ...]

    # Save the new random coin state
    mem_storew.R2_PTR
    dropw
    mem_storew.R1_PTR
    dropw
    mem_storew.C_PTR
    drop drop drop
    #=> [C0, mask]

    # Make sure the lower 16 bits are zero
    u32split
    drop
    u32checked_and
    assertz
    drop
    #=> [R2, R1, C]
end
