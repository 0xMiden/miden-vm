const.SEED_PTR=4294967293
const.Z_PTR=4294967291
const.TMP0=4294967287
const.FRI_QUERIES_PTR=4294966473
const.DEEP_RAND_CC_PTR=4294966338
const.AUX_RAND_ELEM_PTR=4294966000
const.LDE_SIZE_PTR=4294967292

#! Reseed the random coin with `Data`
#!
#! Input: [Data, ...]
#! Ouput: [...]
export.reseed
    push.0.0.0.0
    swapw
    push.0.0.0.0
    mem_loadw.SEED_PTR
    swapw
    hperm
    dropw
    swapw
    dropw
    mem_storew.SEED_PTR
    dropw
end

#! Generate the next tuple of extension field element (v0, v1, v0', v1') based on the current seed 
#! and counter and uses the memory pointer to store (v0, v1, v0', v1') in memory
#!
#! The counter is updated as part of the procedure.
#! Input: [Seed, 1, ptr]
#! Output: [Y, 3, ptr + 1] where Y is a "garbage" value
proc.generate_next_extfelt_tuple
    dupw
    dup.8
    # => [1, Seed, Seed, 1, ptr]   

    push.1.0.0
    push.1.0.0.0                    # [0, 0, 0, 1, 0, 0, 1, 1, Seed, Seed, 1, ptr]  
    swapw.2
    swapw                           # [0, 0, 1, 1, Seed, 0, 0, 0, 1, 1, ptr]
    hperm                           # [Y, R, Y, Seed, 1, ptr]
    dropw swapw dropw               # [y, y, r1, r0, Seed, 1, ptr]
    drop drop                       # [r1, r0, Seed, 1, ptr]
    movdn.6
    movdn.6             
    # => [ Seed, 1, r1, r0, ptr]
    
    movup.4
    dup
    add.2
    movdn.7
    add.1      
    # => [2, Seed, r1, r0, 3, ptr]

    push.1.0.0
    push.1.0.0.0          
    swapw.2
    swapw           
    hperm           
    dropw swapw dropw
    drop drop           
    # => [r1, r0, r1, r0,  3, ptr]

    dup.5
    add.1
    swap.6          
    mem_storew
    # => [r1, r0, r1, r0, 3, ptr + 1]
end

#! Generate the next integer value `r` in the range [0, mask + 1] and stores the word `(r, depth, y, y)`
#! where `depth` is `log(lde_domain_size)`. `depth` is needed when computing the deep queries.
#!
#! Input: [Seed, 1, ptr, mask, depth, ...]
#! Output: [Y, 2, ptr + 1, depth, ...]
proc.generate_next_integer
    movup.4         
    dup
    add.1
    movdn.5             
    push.1.0.0
    push.1.0.0.0
    swapw.2
    swapw               # [0, 0, 1, 1, Seed, 0, 0, 0, 1, 2, ptr]
    hperm
    dropw swapw dropw   # [y, y, r1, r0, 2, ptr, mask, depth]
    drop  drop         
    swap                # [r0, r1, 2, ptr, mask] 
    u32split            
    swap                # [r0_low, y, r1, 2, ptr, mask]
    dup.5
    u32checked_and      # [r, y, r1, 2, ptr, mask, depth]
    dup.6
    swap                # [r, depth, y, r1, 2, ptr, mask, depth]

    dup.5
    add.1
    swap.6          
    mem_storew          # [r, depth, y, r1, 2, ptr + 1, mask, depth]
end

#! Generate a list of random indices in the range [0, lde_size] and store it in memory starting
#! from `query_ptr`. The list is stored as `(r, depth, y, y)` where `depth` is
#! `log(lde_domain_size)`. `depth` is needed when computing the deep queries.
#! TODO: the case of duplicate queries
#! TODO: generalize to any number of queries
#!
#! Input: [query_ptr, ...]
#! Output: [...]
export.generate_list_indices
    # Create mask
    push.0.0.0.0
    mem_loadw.TMP0
    movup.2 drop
    movup.2 drop
    sub.1
    #=> [mask, depth]
 
    # Get address holding the integers (this will later hold the FRI queries)
    movup.2
    push.1
    #=> [1, query_ptr, mask, depth] where depth = log(lde_size)

    # Draw the random queries
    push.0.0.0.0
    repeat.27
        mem_loadw.SEED_PTR
        exec.generate_next_integer
    end
    dropw
    dropw
end

#! Draw a list of random extension field elements related to the auxiliary trace and store the list 
#! in memory from `aux_rand_elem_ptr` to `aux_rand_elem_ptr + 8 - 1`
#!
#! Input: [aux_rand_elem_ptr, ...]
#! Output: [...]
export.generate_aux_randomness
    push.1
    push.0.0.0.0
    mem_loadw.SEED_PTR       
    # => [Seed, 1, rand_cstr_coef_ptr, ...]

    repeat.8
        exec.generate_next_extfelt_tuple
        mem_loadw.SEED_PTR
    end
    drop
    drop
    dropw
    # => [...] 
end

#! Draw constraint composition random coefficients and save them into memory in the region from
#! `compos_coef_ptr` `compos_coef_ptr + 235 - 1` as `(r1_1, r1_0, r0_1, r0_0)`
#!
#! Input: [compos_coef_ptr, ...]
#! Output: [...]
export.generate_constraint_composition_coefficients
    push.1
    push.0.0.0.0
    mem_loadw.SEED_PTR
    # => [Seed, 1, compos_coef_ptr]

    repeat.235
        exec.generate_next_extfelt_tuple
        mem_loadw.SEED_PTR
    end
    dropw
    drop
    drop
end

#! Generate the OOD challenge point `z = (z0, z1)` and compute `z^8`. The resulting word
#! `[z^8_1, z^8_0, z1, z0]` is stored in the global memory address reserved for it.
#!
#! Input: [...]
#! Output: [...]
export.generate_z_z8
    # draw z 
    push.1.0.0.0
    push.0.0.0.0
    mem_loadw.SEED_PTR
    push.1.1.0.0
    hperm
    dropw
    swapw
    dropw
    drop drop

    # Store OOD challenge z and z^8 as [z^8_1, z^8_0, z1, z0]
    dup.1
    dup.1
    repeat.3
        dup.1
        dup.1
        ext2mul
    end
    mem_storew.Z_PTR
    dropw
end

#! Draw deep composition polynomial random coefficients and save them into memory in the region from
#! `deep_rand_coef_ptr` `compos_coef_ptr + 86 - 1` as `(r1_1, r1_0, r0_1, r0_0)`
#!
#! Input: [deep_rand_coef_ptr, ...]
#! Output: [...]
export.generate_deep_composition_random_coefficients
    # Load Seed and prepare for drawing
    push.1
    push.0.0.0.0
    mem_loadw.SEED_PTR
    # => [Seed, 1, ptr, ..]
    
    # Draw the random coefficients
    # The number of coefficients is equal to:
    # (72 + 9) * 4 Felt for the trace.
    # 8 * 2 Felt for constraint polynomial.
    # 2 Felt for degree correction.
    # Total: 172 tuples of type (Felt, Felt)
    repeat.86
        exec.generate_next_extfelt_tuple
        mem_loadw.SEED_PTR
        # => [Seed, 3, ptr + 1]
    end
    # => [Seed, 172, ptr + 86, ..]
    dropw
    drop
    drop
    # => [...]
end

#! Initializes the seed for randomness generation by computing the hash of the proof context using
#! the trace length, number of queries, logarithm of blowup factor and the number of bits of 
#! grinding. Currently, this part, as well as the rest of the STARK verifier has the blowup factor
#! fixed to 8, number of queries to 27.
#! The ouput of this procedure is the capacity portion of the state after applying `hperm`.
#!
#! Input: [trace_length, num_queries, blowup, grinding, ...]
#! Output: [C]
export.init_seed

    # Create the initial seed for randomness generation from proof context
    
    ## compute trace_length
    dup
    pow2
    u32split assertz
    #=> [trace_length, log(trace_length), num_queries, log(blowup), grinding]

    ## Assert blowup is equal to 8
    swap
    dup.3
    dup
    push.3
    assert_eq

    ## Compute log(lde_size) and lde_size and store them
    add
    swap
    movup.3
    pow2
    dup
    movdn.4
    swap
    dup
    movdn.3
    mul
    push.0
    movdn.2
    push.0
    movdn.2
    mem_storew.LDE_SIZE_PTR
    #=> [lde_size, log(lde_size), 0, 0, trace_length, num_queries, blowup, grinding]

    # Construct the proof context
    dropw
    push.1208027408
    push.1
    push.4294967295
    push.132103
    swapw
    
    # Hash proof context
    push.1.0.0.0
    #=> [0, 0, 0, 1, B, A, ..]
    swapw.2
    swapw
    #=> [B, A, 0, 0, 0, 1, ..]
    hperm
    dropw
    dropw
    #=> [C]
end