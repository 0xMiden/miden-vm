use.std::crypto::fri::frie2f4
use.std::crypto::fri::ext2fri
use.std::crypto::fri::helper

use.std::crypto::stark::deep_queries
use.std::crypto::stark::random_coin
use.std::crypto::stark::ood_frames
use.std::crypto::stark::public_inputs
use.std::crypto::stark::utils

# Constants
const.ROOT_UNITY=7277203076849721926

# Global memory (sorted by increasing addresses)
const.PUBLIC_INPUTS_PTR=4294960000
const.CURRENT_TRACE_ROW_PTR=4294964000    # PUBLIC_INPUTS_PTR + 4000
const.OOD_TRACE_CURRENT_PTR=4294965000    # CURRENT_TRACE_ROW_PTR + 1000
const.OOD_TRACE_NEXT_PTR=4294965041       # OOD_TRACE_CURRENT_PTR + 41
const.OOD_CONSTRAINT_EVALS_PTR=4294965082 # OOD_TRACE_NEXT_PTR + 41
const.AUX_RAND_ELEM_PTR=4294966000        # OOD_CONSTRAINT_EVALS_PTR + 918
const.COMPOSITION_COEF_PTR=4294966016     # AUX_RAND_ELEM_PTR + 16
const.DEEP_RAND_CC_PTR=4294966338         # COMPOSITION_COEF_PTR + 322
const.FRI_QUERIES_PTR=4294966473          # DEEP_RAND_CC_PTR + 135
const.FRI_COM_PTR=4294966500              # FRI_QUERIES_PTR + 27
const.PARAMETERS_PTR=4294967276           # FRI_COM_PTR + 776
const.ZERO_ZERO_ZERO_ONE_PTR=4294967277   # PARAMETERS_PTR + 1
const.ZERO_WORD_PTR=4294967278            # ZERO_ZERO_ZERO_ONE_PTR + 1
const.TMP8=4294967279                     # ZERO_WORD_PTR + 1
const.TMP7=4294967280                     # TMP8 + 1
const.TMP6=4294967281                     # TMP7 + 1
const.TMP5=4294967282                     # TMP6 + 1
const.TMP4=4294967283                     # TMP5 + 1
const.TMP3=4294967284                     # TMP4 + 1
const.TMP2=4294967285                     # TMP3 + 1
const.TMP1=4294967286                     # TMP2 + 1
const.TMP0=4294967287                     # TMP1 + 1
const.COMPOSITION_POLY_COM_PTR=4294967288 # TMP0 + 1
const.AUX_TRACE_COM_PTR=4294967289        # COMPOSITION_POLY_COM_PTR + 1
const.MAIN_TRACE_COM_PTR=4294967290       # AUX_TRACE_COM_PTR + 1
const.Z_PTR=4294967291                    # MAIN_TRACE_COM_PTR + 1
const.LDE_SIZE_PTR=4294967292             # Z_PTR + 1

#!   Verify a STARK proof attesting to the correct execution of a program in the Miden VM.
#!   The following simplifying assumptions are currently made:
#!   - The blowup is set to 8, the grinding to 16bits and number of FRI queries to 27.
#!   - The maximal allowed degree of the remainder polynomial is 7.
#!   - Only the input and output stacks, assumed of fixed size equal to 16, are handled in regards
#!   to public inputs.
#!   - The following procedure makes use of global memory address beyond 3 * 2^30. More precisely,
#!   the following is a list of pointers used by `stark::verify`:    
#!
#!   * ZERO_ZERO_ZERO_ONE_PTR. [0, 0, 0, 1] used for hmerge in case the number of elements to be hashed is not divisible by 8
#!   * ZERO_WORD_PTR. [0, 0, 0, 0] used for hmerge in case the number of elements to be hashed is divisible by 8
#!   * LDE_SIZE_PTR. [lde_size, log2(lde_size), 0, 0]
#!   * Z_PTR. [z8_1, z8_0, z1, z0] where z = (z_0, z_1) is the OOD random element
#!   * MAIN_TRACE_COM_PTR. Main trace commitment
#!   * AUX_TRACE_COM_PTR. Aux trace commitment
#!   * COMPOSITION_POLY_COM_PTR. Constraint polynomial columns trace commitment
#!   * PUBLIC_INPUTS_PTR. Points to the memory region containing the public inputs.
#!   * AUX_RAND_ELEM_PTR.    Auxiliary trace random coefficients
#!   * COMPOSITION_COEF_PTR.    Constraint composition coefficients
#!   * OOD_TRACE_CURRENT_PTR.    Current row of the OOD evaluation frame 
#!   * OOD_TRACE_NEXT_PTR.    Next row of the OOD evaluation frame 
#!   * OOD_CONSTRAINT_EVALS_PTR.    value_i for i in 0..=7 where H(z) := \sum_0^7 value_i * z^i and H is the constraint compostion polynomial
#!   * DEEP_RAND_CC_PTR.    Deep query coefficients
#!   * FRI_QUERIES_PTR.    [poe, query_index, evaluation_1, evaluation_0] for the 27 FRI queries where poe = lde_domain_generator^query_index
#!   * PARAMETERS_PTR.   [log(trace_length), num_queries, log(blowup), grinding]
#!   * TMP1.   [gz1, gz0, z1, z0]
#!   * TMP2.   [x, _, _, _] where x := offset * lde_domain_generator^query_index
#!   * TMP3.   Leaf value at index `query_index` of the commitment tree to either main, auxiliary or constraint traces.
#!   * TMP4.   [query_index, depth, _, _] where query_index is the current deep FRI query being computed.
#!   * TMP5.   [lde_size, log2(lde_size), lde_domain_generator, 0]
#!   * TMP6.   [num_fri_layers, remainder_size, lde_size, lde_domain_generator]
#!   * TMP7.   Remainder commitment
#!   * TMP8.   [ptr_remainder, remainder_size, lde_size, lde_size]
#!
#! Input: [log(trace_length), num_queries, log(blowup), grinding]
#! Output: []
#! Cycles:
#!  1- Remainder codeword size 32: 5721 + num_queries * (40 + num_fri_layers * 76 + 26 + 8445) + 83 * num_fri_layers + 1498
#!  2- Remainder codeword size 64: 5721 + num_queries * (40 + num_fri_layers * 76 + 26 + 8445) + 83 * num_fri_layers + 2792
export.verify

    #==============================================================================================
    #       I)  Hash proof context and hash-&-load public inputs
    #==============================================================================================

    # Save the parameters in memory for later use
    mem_storew.PARAMETERS_PTR

    # Initialize the seed using proof context
    #
    # Cycles: 82
    exec.random_coin::init_seed
    #=> [C]
    
    # Load public inputs
    #
    # Cycles: 93
    push.PUBLIC_INPUTS_PTR
    exec.public_inputs::load
    exec.random_coin::reseed
    #=> [...]

    #==============================================================================================
    #       II) Generate the auxiliary trace random elements
    #==============================================================================================

    # Load main trace commitment and re-seed with it
    #
    # Cycles: 61
    push.0.0.0.0
    adv_loadw          
    mem_storew.MAIN_TRACE_COM_PTR
    #=> [main_trace_commitment]
    exec.random_coin::reseed
    #=> [...]

    # Draw random ExtFelt for the auxiliary trace
    #
    # Cycles: 150
    push.AUX_RAND_ELEM_PTR
    exec.random_coin::generate_aux_randomness
    #=> [...]

    # Reseed with auxiliary trace commitment
    #
    # Cycles: 60
    push.0.0.0.0
    adv_loadw
    mem_storew.AUX_TRACE_COM_PTR
    exec.random_coin::reseed
    #=> [...]
 
    #==============================================================================================
    #       III) Draw constraint composition coefficients
    #==============================================================================================

    # Cycles: 2610
    push.COMPOSITION_COEF_PTR
    exec.random_coin::generate_constraint_composition_coefficients
    #=> [...]

    #==============================================================================================
    #       IV) Reseed with commitment to constraint composition polynomial H evaluations over LDE
    #          and generate the Out-of-Domain (OOD) challenge z 
    #==============================================================================================

    # Reseed with constraint composition polynomial commitment
    #
    # Cycles: 61
    push.0.0.0.0
    adv_loadw
    mem_storew.COMPOSITION_POLY_COM_PTR
    exec.random_coin::reseed
    exec.random_coin::generate_z_z8
    #=> [...]
   
    #==============================================================================================
    #       V) Read the OOD frames for the main trace, auxiliary trace and the trace of evaluations
    #           of H over the LDE domain.
    #==============================================================================================

    # Cycles: 207
    exec.ood_frames::load_evaluation_frame
    #=> [CURENT_ROW_HASH, NEXT_ROW_HASH, ...]

    # Cycles: 108
    exec.random_coin::reseed    
    exec.random_coin::reseed    
    
    # Cycles: 29
    exec.ood_frames::load_constraint_evaluations
    #=> [CONSTR_EVAL_HASH, ...]

    # Cycles: 54
    exec.random_coin::reseed
    
    # Compute `H(z)`
    #
    # Cycles: 118
    exec.ood_frames::compute_Hz
    #=> [res1, res0, ...]

    #==============================================================================================
    #       VI) Evaluate the constraints over the OOD frame and assert equality with H(z)
    #==============================================================================================

    # TODO: Compare with the evaluation of the constraints on the EvaluationFrame
    drop drop
    #=> [...]

    #==============================================================================================
    #       VII) FRI
    #==============================================================================================

    #============================================
    #   1) Draw random coefficients for computing
    #       DEEP composition polynomial.
    #============================================

    # Cycles: 993
    push.DEEP_RAND_CC_PTR
    exec.random_coin::generate_deep_composition_random_coefficients

    #============================================
    #   2) Compute constants needed for computing
    #       FRI queries. These are:
    #       -   LDE domain generator.
    #       -   Trace domain generator `g`.
    #       -   `gz`.
    #       -   Number of FRI layers. 
    #============================================

    # Cycles: 126
    exec.helper::generate_fri_parameters
    #=> [num_fri_layers, ...]

    #============================================
    #   3) Load and reseed with FRI layer commitments 
    #      and draw the folding challenges for 
    #      computing the degree respecting projection
    #============================================
    
    # Cycles: 22 + 83 * num_fri_layers
    push.FRI_COM_PTR
    exec.helper::load_fri_layer_commitments
    #=> [...]

    #============================================
    #   4) Remainder verification:
    #       a) Check commitment to remainder polynomial
    #            coefficients.
    #       b) Load the NTT of remainder polynomial
    #            into memory.
    #       c) Check the NTT relationship.
    #============================================

    # Cycles:
    #  1- Remainder of size 32: 1498
    #  2- Remainder of size 64: 2792
    exec.helper::load_and_verify_remainder
    #=> [...]

    #============================================
    #   5) Check PoW nonce
    #============================================

    # Cycles: 53
    push.0.0.0.0
    mem_loadw.PARAMETERS_PTR
    drop drop drop
    exec.random_coin::check_pow
    #=> [...]

    #============================================
    #   6) Compute evaluations of DEEP composition
    #   polynomial at randomly chosen query positions 
    #============================================

    # Draw random query indices
    #
    # Cycles: 798
    push.FRI_QUERIES_PTR
    exec.random_coin::generate_list_indices
    #=> [...]
    
    # Compute deep compostion polynomial queries
    #
    # Cycles: 44 + 27 * 8445 = 228059
    exec.deep_queries::compute_deep_composition_polynomial_queries
    #=> [...]

    #============================================
    #   7) Call the FRI verifier
    #============================================
    
    # Get domain generator and a pointer to the remainder codeword
    #
    # Cycles: 15
    push.0.0.0.0
    mem_loadw.TMP0
    push.0.0
    mem_loadw.TMP8
    swap.3
    drop drop drop
    #=>[ptr_remainder, g]

    # Get the pointer to the first layer commitment
    push.FRI_COM_PTR

    # Get the pointer to the first FRI query
    push.FRI_QUERIES_PTR
    #=> [ptr_query, ptr_layer, ptr_remainder, domain_gen]

    # Call FRI verifier
    #
    # Cycles: 7 + 4 + 27 * (40 + num_layers * 76 + 26)
    exec.frie2f4::verify
    #=> ()
end