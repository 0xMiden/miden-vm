

#<= [value_{i}1, value_{i}0, p1, p2, Y, Y, Acc,       Z]
#=> [value_{i}1, value_{i}0, p1, p2, Y, Y, Acc,       Z]
export.deep_query_aux_1

    

    # Get T_i(z), T_i(gz)
    swapw
    dup.6
    mem_loadw
    push.0.0
    dup.8 
    add.41
    mem_loadw
    drop drop
    #=> [T_i(gz)1, T_i(gz)0, T_i(z)1, T_i(z)0, value_{i}1, value_{i}0, p1, p2, Y, 0, 0, 0, 0,      Z ]

    ## Compute the numerator

    swapw
    dup.1
    dup.1
    movup.9
    movup.9
    ext2sub
    #=> [value_{i}1 - T_i(z)1, value_{i}0 - T_i(z)0, value_{i}1, value_{i}0, p1, p2, T_i(gz)1, T_i(gz)0, Y, 0, 0, 0, 0,      Z ]


    #=> [value_{i}1, value_{i}0, p1, p2, T3, T2, T1, T0, Y, 0, 0, 0, 0,      Z ]

    movdn.7
    movdn.7
    dup.1
    dup.1
    movup.7
    movup.7
    ext2sub
    movdn.5
    movdn.5
    #=> [value_{i}1, value_{i}0, p1, p2, value_{i}1 - T_i(gz)1, value_{i}0 - T_i(gz)0, value_{i}1 - T_i(z)1, value_{i}0 - T_i(z)0, Y, 0, 0, 0, 0,      Z ]
    #=> [value_{i}1, value_{i}0, p1, p2, T, Y, 0, 0, 0, 0,      Z ] where T := [value_{i}1 - T_i(gz)1, value_{i}0 - T_i(gz)0, value_{i}1 - T_i(z)1, value_{i}0 - T_i(z)0]


    movupw.2
    #=> [Y, value_{i}1, value_{i}0, p1, p2, T, 0, 0, 0, 0,      Z ]

    # Get [alpha1, alpha0, beta1, beta0]
    dup.7
    add.1
    swap.8
    mem_loadw
    #=> [[alpha1, alpha0, beta1, beta0], value_{i}1, value_{i}0, p1, p2, T, 0, 0, 0, 0,      Z]

    swapdw
    movupw.2
    #=> [[alpha1, alpha0, beta1, beta0], T, 0, 0, 0, 0, value_{i}1, value_{i}0, p1, p2,     Z]

  
    dup.7
    dup.7
    ext2mul
    #=> [prod1_g, prod0_g, beta1, beta0, T, 0, 0, 0, 0, value_{i}1, value_{i}0, p1, p2,      Z]
    # Where (prod0_g, prod1_g) =  (T0, T1) * alpha 

    swap
    swap.3
    swap
    swap.2    
    swapw
    #=> [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, 0, 0, 0, 0, value_{i}1, value_{i}0, p1, p2,      Z]

    dup.5
    dup.5
    ext2mul
    #=> [prod1, prod0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]
    # where (prod0, prod1) =  (value_i - T_i(z)_0, - T_i(z)_1) * beta = (T_i(x) - T_i(z)) * beta

    movup.7
    movup.7
    dupw.2
    #=> [0, 0, 0, 0, prod1_g, prod0_g, prod1, prod0, x, x, x, x, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]

    # Accumulate
    
    movup.7
    movup.7
    ext2add
    movdn.5
    movdn.5
    ext2add
    swap
    swap.3
    swap
    swap.2
    #=> [0+prod1, 0+prod0, 0+prod1_g, 0+prod0_g, x, x, x, x, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]           Acc = [Tz, Tz, Tgz, Tgz]


    #=> [Acc, Y, Y, P,      Z]

    swapw.3
    #=> [P, Y, Y, Acc,       Z]
end

#<= [value_{i}1, value_{i}0, p1, p2, Y, Y, Acc,       Z]
#=> [value_{i}1, value_{i}0, p1, p2, Y, Y, Acc,       Z]
export.deep_query_aux_2

    

    # Get T_i(z), T_i(gz)
    swapw
    dup.6
    add.1
    swap.7
    mem_loadw
    push.0.0
    dup.8 
    add.41
    mem_loadw
    drop drop
    #=> [T_i(gz)1, T_i(gz)0, T_i(z)1, T_i(z)0, value_{i}1, value_{i}0, p1, p2, Y, 0, 0, 0, 0,      Z ]

    ## Compute the numerator

    swapw
    dup.1
    dup.1
    movup.9
    movup.9
    ext2sub
    #=> [value_{i}1 - T_i(z)1, value_{i}0 - T_i(z)0, value_{i}1, value_{i}0, p1, p2, T_i(gz)1, T_i(gz)0, Y, 0, 0, 0, 0,      Z ]


    #=> [value_{i}1, value_{i}0, p1, p2, T3, T2, T1, T0, Y, 0, 0, 0, 0,      Z ]

    movdn.7
    movdn.7
    dup.1
    dup.1
    movup.7
    movup.7
    ext2sub
    movdn.5
    movdn.5
    #=> [value_{i}1, value_{i}0, p1, p2, value_{i}1 - T_i(gz)1, value_{i}0 - T_i(gz)0, value_{i}1 - T_i(z)1, value_{i}0 - T_i(z)0, Y, 0, 0, 0, 0,      Z ]
    #=> [value_{i}1, value_{i}0, p1, p2, T, Y, 0, 0, 0, 0,      Z ] where T := [value_{i}1 - T_i(gz)1, value_{i}0 - T_i(gz)0, value_{i}1 - T_i(z)1, value_{i}0 - T_i(z)0]


    movupw.2
    #=> [Y, value_{i}1, value_{i}0, p1, p2, T, 0, 0, 0, 0,      Z ]

    # Get [alpha1, alpha0, beta1, beta0]
    dup.7
    add.1
    swap.8
    mem_loadw
    #=> [[alpha1, alpha0, beta1, beta0], value_{i}1, value_{i}0, p1, p2, T, 0, 0, 0, 0,      Z]

    swapdw
    movupw.2
    #=> [[alpha1, alpha0, beta1, beta0], T, 0, 0, 0, 0, value_{i}1, value_{i}0, p1, p2,     Z]

  
    dup.7
    dup.7
    ext2mul
    #=> [prod1_g, prod0_g, beta1, beta0, T, 0, 0, 0, 0, value_{i}1, value_{i}0, p1, p2,      Z]
    # Where (prod0_g, prod1_g) =  (T0, T1) * alpha 

    swap
    swap.3
    swap
    swap.2    
    swapw
    #=> [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, 0, 0, 0, 0, value_{i}1, value_{i}0, p1, p2,      Z]

    dup.5
    dup.5
    ext2mul
    #=> [prod1, prod0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]
    # where (prod0, prod1) =  (value_i - T_i(z)_0, - T_i(z)_1) * beta = (T_i(x) - T_i(z)) * beta

    movup.7
    movup.7
    dupw.2
    #=> [0, 0, 0, 0, prod1_g, prod0_g, prod1, prod0, x, x, x, x, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]

    # Accumulate
    
    movup.7
    movup.7
    ext2add
    movdn.5
    movdn.5
    ext2add
    swap
    swap.3
    swap
    swap.2
    #=> [0+prod1, 0+prod0, 0+prod1_g, 0+prod0_g, x, x, x, x, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]           Acc = [Tz, Tz, Tgz, Tgz]


    #=> [Acc, Y, Y, P,      Z]

    swapw.3
    #=> [P, Y, Y, Acc,       Z]
end


#=> [Y, P, Y, Acc,      Z]
export.deep_query_1
    # Get value_i := T_i(x)
    dup.7
    mem_loadw
    movup.4
    #=> [Y, value_i,p1,p2,p3, Y, 0, 0, 0, 0,      Z ]
    

    # Get T_i(z), T_i(gz)
    dup.5
    mem_loadw
    push.0.0
    dup.7 add.41
    mem_loadw
    drop drop
    neg 
    swap.2
    neg
    #=> [ - T_i(z)_1, T_i(gz)_0, - T_i(gz)_1, T_i(z)_0, value_i,p1,p2,p3, Y, 0, 0, 0, 0,      Z ]

    # Compute numerator
    swapw
    dup
    movup.6
    sub
    #=> [value_i - T_i(gz)_0, value_i, p1,p2,p3, - T_i(z)_1, - T_i(gz)_1, T_i(z)_0,, Y, 0, 0, 0, 0,      Z ]
    movdn.7
    swapw
    dup.4
    movup.3
    sub
    swap
    swapw.2
    #=> [Y, value_i, p1,p2,p3, T, 0, 0, 0, 0,      Z]      where T := [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0]


    # Get [alpha1, alpha0, beta1, beta0]
    dup.6
    add.1
    swap.7
    mem_loadw
    #=> [[alpha1, alpha0, beta1, beta0], value_i, p1,p2,p3, T, 0, 0, 0, 0,      Z]

    swapdw
    movupw.2
    #=> [[alpha1, alpha0, beta1, beta0], T, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]

  
    dup.7
    dup.7
    ext2mul
    #=> [prod1_g, prod0_g, beta1, beta0, - T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]
    # Where (prod0_g, prod1_g) =  (value_i - T_i(gz)_0, - T_i(gz)_1) * alpha = (T_i(x) - T_i(gz)) * alpha

    swap
    swap.3
    swap
    swap.2    
    swapw
    #=> [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]

    dup.5
    dup.5
    ext2mul
    #=> [prod1, prod0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]
    # where (prod0, prod1) =  (value_i - T_i(z)_0, - T_i(z)_1) * beta = (T_i(x) - T_i(z)) * beta

    movup.7
    movup.7
    dupw.2
    #=> [0, 0, 0, 0, prod1_g, prod0_g, prod1, prod0, x, x, x, x, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]

    # Accumulate
    
    movup.7
    movup.7
    ext2add
    movdn.5
    movdn.5
    ext2add
    swap
    swap.3
    swap
    swap.2
    #=> [0+prod1, 0+prod0, 0+prod1_g, 0+prod0_g, x, x, x, x, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]           Acc = [Tz, Tz, Tgz, Tgz]


    #=> [Acc, Y, Y, P,      Z]

    swapw.3
    swapw
    #=> [Y, P, Y, Acc,      Z]
end


#=> [Y, P, Y, Acc,      Z]
export.deep_query_2
    # Get value_i := T_i(x)
    dup.7
    mem_loadw
    swap.2
    swap.4
    #=> [Y, value_i, p1,p2,p3, Y, 0, 0, 0, 0,      Z ]
    

    # Get T_i(z), T_i(gz)
    dup.5
    mem_loadw
    movup.3
    movup.3
    push.0.0
    dup.7 add.41
    mem_loadw
    movup.3
    movup.3
    
    drop drop
    neg 
    swap.2
    neg
    #=> [ - T_i(z)_1, T_i(gz)_0, - T_i(gz)_1, T_i(z)_0, value_i,p1,p2,p3, Y, 0, 0, 0, 0,      Z ]

    # update p1
    movup.5
    add.1
    movdn.5


    # Compute numerator
    swapw
    dup
    movup.6
    sub
    #=> [value_i - T_i(gz)_0, value_i, p1,p2,p3, - T_i(z)_1, - T_i(gz)_1, T_i(z)_0,, Y, 0, 0, 0, 0,      Z ]
    movdn.7
    swapw
    dup.4
    movup.3
    sub
    swap
    swapw.2
    #=> [Y, value_i, p1,p2,p3, T, 0, 0, 0, 0,      Z]      where T := [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0]


    # Get [alpha1, alpha0, beta1, beta0]
    dup.6
    add.1
    swap.7
    mem_loadw
    #=> [[alpha1, alpha0, beta1, beta0], value_i, p1,p2,p3, T, 0, 0, 0, 0,      Z]

    swapdw
    movupw.2
    #=> [[alpha1, alpha0, beta1, beta0], T, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]

  
    dup.7
    dup.7
    ext2mul
    #=> [prod1_g, prod0_g, beta1, beta0, - T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]
    # Where (prod0_g, prod1_g) =  (value_i - T_i(gz)_0, - T_i(gz)_1) * alpha = (T_i(x) - T_i(gz)) * alpha

    swap
    swap.3
    swap
    swap.2    
    swapw
    #=> [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]

    dup.5
    dup.5
    ext2mul
    #=> [prod1, prod0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]
    # where (prod0, prod1) =  (value_i - T_i(z)_0, - T_i(z)_1) * beta = (T_i(x) - T_i(z)) * beta

    movup.7
    movup.7
    dupw.2
    #=> [0, 0, 0, 0, prod1_g, prod0_g, prod1, prod0, x, x, x, x, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]

    # Accumulate
    
    movup.7
    movup.7
    ext2add
    movdn.5
    movdn.5
    ext2add
    swap
    swap.3
    swap
    swap.2
    #=> [0+prod1, 0+prod0, 0+prod1_g, 0+prod0_g, x, x, x, x, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]           Acc = [Tz, Tz, Tgz, Tgz]


    #=> [Acc, Y, Y, P,      Z]

    swapw.3
    swapw
    #=> [Y, P, Y, Acc,      Z]
end


#=> [Y, P, Y, Acc,      Z]
export.deep_query_3
    # Get value_i := T_i(x)
    dup.7
    mem_loadw
    #=> [x, value_i, x, x, , x,p1,p2,p3, Y, 0, 0, 0, 0,      Z ]
    swap
    swap.4
    #=> [x, x, x, x, value_i, p1,p2,p3, Y, 0, 0, 0, 0,      Z ]
    

    # Get T_i(z), T_i(gz)
    dup.5
    mem_loadw
    push.0.0
    dup.7 add.41
    mem_loadw
    drop drop
    neg 
    swap.2
    neg
    #=> [ - T_i(z)_1, T_i(gz)_0, - T_i(gz)_1, T_i(z)_0, value_i,p1,p2,p3, Y, 0, 0, 0, 0,      Z ]

    # Compute numerator
    swapw
    dup
    movup.6
    sub
    #=> [value_i - T_i(gz)_0, value_i, p1,p2,p3, - T_i(z)_1, - T_i(gz)_1, T_i(z)_0,, Y, 0, 0, 0, 0,      Z ]
    movdn.7
    swapw
    dup.4
    movup.3
    sub
    swap
    swapw.2
    #=> [Y, value_i, p1,p2,p3, T, 0, 0, 0, 0,      Z]      where T := [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0]


    # Get [alpha1, alpha0, beta1, beta0]
    dup.6
    add.1
    swap.7
    mem_loadw
    #=> [[alpha1, alpha0, beta1, beta0], value_i, p1,p2,p3, T, 0, 0, 0, 0,      Z]

    swapdw
    movupw.2
    #=> [[alpha1, alpha0, beta1, beta0], T, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]

  
    dup.7
    dup.7
    ext2mul
    #=> [prod1_g, prod0_g, beta1, beta0, - T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]
    # Where (prod0_g, prod1_g) =  (value_i - T_i(gz)_0, - T_i(gz)_1) * alpha = (T_i(x) - T_i(gz)) * alpha

    swap
    swap.3
    swap
    swap.2    
    swapw
    #=> [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]

    dup.5
    dup.5
    ext2mul
    #=> [prod1, prod0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]
    # where (prod0, prod1) =  (value_i - T_i(z)_0, - T_i(z)_1) * beta = (T_i(x) - T_i(z)) * beta

    movup.7
    movup.7
    dupw.2
    #=> [0, 0, 0, 0, prod1_g, prod0_g, prod1, prod0, x, x, x, x, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]

    # Accumulate
    
    movup.7
    movup.7
    ext2add
    movdn.5
    movdn.5
    ext2add
    swap
    swap.3
    swap
    swap.2
    #=> [0+prod1, 0+prod0, 0+prod1_g, 0+prod0_g, x, x, x, x, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]           Acc = [Tz, Tz, Tgz, Tgz]


    #=> [Acc, Y, Y, P,      Z]

    swapw.3
    swapw
    #=> [Y, P, Y, Acc,      Z]
end

#=> [Y, P, Y, Acc,      Z]
export.deep_query_4
    # Get value_i := T_i(x)
    dup.7

    # update pointer
    add.1
    swap.8

    mem_loadw
    #=> [value_i, x, x , x, x, p1,p2,p3, Y, 0, 0, 0, 0,      Z ]
    swap.4
    #=> [Y, value_i, p1,p2,p3, Y, 0, 0, 0, 0,      Z ]
    

    # Get T_i(z), T_i(gz)
    dup.5
    mem_loadw
    movup.3
    movup.3
    push.0.0
    dup.7 add.41
    mem_loadw
    movup.3
    movup.3
    
    drop drop
    neg 
    swap.2
    neg
    #=> [ - T_i(z)_1, T_i(gz)_0, - T_i(gz)_1, T_i(z)_0, value_i,p1,p2,p3, Y, 0, 0, 0, 0,      Z ]

    # update p1
    movup.5
    add.1
    movdn.5


    # Compute numerator
    swapw
    dup
    movup.6
    sub
    #=> [value_i - T_i(gz)_0, value_i, p1,p2,p3, - T_i(z)_1, - T_i(gz)_1, T_i(z)_0,, Y, 0, 0, 0, 0,      Z ]
    movdn.7
    swapw
    dup.4
    movup.3
    sub
    swap
    swapw.2
    #=> [Y, value_i, p1,p2,p3, T, 0, 0, 0, 0,      Z]      where T := [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0]


    # Get [alpha1, alpha0, beta1, beta0]
    dup.6
    add.1
    swap.7
    mem_loadw
    #=> [[alpha1, alpha0, beta1, beta0], value_i, p1,p2,p3, T, 0, 0, 0, 0,      Z]

    swapdw
    movupw.2
    #=> [[alpha1, alpha0, beta1, beta0], T, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]

  
    dup.7
    dup.7
    ext2mul
    #=> [prod1_g, prod0_g, beta1, beta0, - T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]
    # Where (prod0_g, prod1_g) =  (value_i - T_i(gz)_0, - T_i(gz)_1) * alpha = (T_i(x) - T_i(gz)) * alpha

    swap
    swap.3
    swap
    swap.2    
    swapw
    #=> [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]

    dup.5
    dup.5
    ext2mul
    #=> [prod1, prod0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]
    # where (prod0, prod1) =  (value_i - T_i(z)_0, - T_i(z)_1) * beta = (T_i(x) - T_i(z)) * beta

    movup.7
    movup.7
    dupw.2
    #=> [0, 0, 0, 0, prod1_g, prod0_g, prod1, prod0, x, x, x, x, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]

    # Accumulate
    
    movup.7
    movup.7
    ext2add
    movdn.5
    movdn.5
    ext2add
    swap
    swap.3
    swap
    swap.2
    #=> [0+prod1, 0+prod0, 0+prod1_g, 0+prod0_g, x, x, x, x, 0, 0, 0, 0, value_i, p1,p2,p3,      Z]           Acc = [Tz, Tz, Tgz, Tgz]


    #=> [Acc, Y, Y, P,      Z]

    swapw.3
    swapw
    #=> [Y, P, Y, Acc,      Z]
end


# Input: [Seed, Data]
# Ouput: [Seed_n, X, Y]
export.reseed
    push.0.0.0.0
    swapw.2
    hperm
    swapw
end

# Input: [Seed, 1, ptr] where G is the seed
# Output: [X, 2, ptr + 1]
export.generate_next_extfelt
    movup.4         # [Seed, 1, ptr]
    dup
    add.1
    movdn.5             
    push.1.0.0
    #movup.3
    push.1.0.0.0
    swapw.2
    swapw           # [0, 0, 1, 1, Seed, 0, 0, 0, 1, 2, ptr]
    hperm
    dropw swapw dropw # [r1, r0, x, x, 2, ptr]
    dup.5
    add.1
    swap.6          
    mem_storew      # [x, x, r1, r0, 2, ptr + 1]
end

# <= [log2(domain_size), ..]
# => [domain_gen, ..]
export.compute_generator
    push.32
    swap
    sub
    pow2
    push.1753635133440165772
    swap
    exp.u64
    # => [domain_gen, ..]
end

# <= [lde_size, 1, ..]
# => [remainder_size, lde_size, num_fri_layers,..]
export.get_num_fri_layers
    dup
    push.4
    u32checked_divmod

    dup.1
    push.0
    neq

    while.true
        drop
        movup.2
        add.1
        movdn.2

        push.4
        u32checked_divmod

        dup.1
        push.64
        u32unchecked_gte
    end
    drop
end

# Input: [Seed, 1, ptr] where G is the seed
# Output: [X, 3, ptr + 1]
export.generate_next_extfelt_tuple
    dupw
    dup.8
    # => [1, Seed, Seed, 1, ptr]   
    
    push.1.0.0
    push.1.0.0.0                    # [0, 0, 0, 1, 0, 0, 1, 1, Seed, Seed, 1, ptr]  
    swapw.2
    swapw                           # [0, 0, 1, 1, Seed, 0, 0, 0, 1, 1, ptr]
    hperm                           # [X, R, Y, Seed, 1, ptr]
    dropw swapw dropw               # [x, x, r1, r0, Seed, 1, ptr]
    drop drop                       # [r1, r0, Seed, 1, ptr]
    movdn.6
    movdn.6             
    # => [ Seed, 1, r1,r0, ptr]
    
    movup.4
    dup
    add.2
    movdn.7
    add.1      
    # => [ 2, Seed, r1,r0, 3, ptr]


    push.1.0.0
    push.1.0.0.0          
    swapw.2
    swapw           
    hperm           
    dropw swapw dropw
    drop drop           
    # => [r1, r0, r1, r0,  3, ptr]

    dup.5
    add.1
    swap.6          
    mem_storew
    # => [r1, r0, r1, r0, 3, ptr + 1]
end

# Input: [Seed, 1, ptr, mask, depth] where G is the seed
# Output: [X, 2, ptr + 1, depth]
export.generate_next_integer
    movup.4         
    dup
    add.1
    movdn.5             
    push.1.0.0
    #movup.3
    push.1.0.0.0
    swapw.2
    swapw               # [0, 0, 1, 1, Seed, 0, 0, 0, 1, 2, ptr]
    hperm
    dropw swapw dropw   # [x, x, r1, r0, 2, ptr, mask, depth]
    drop  drop         
    swap                # [r0, r1, 2, ptr, mask] 
    u32split            
    swap                # [r0_low, x, r1, 2, ptr, mask]
    dup.5
    u32checked_and      # [query, x, r1, 2, ptr, mask, depth]
    dup.6
    swap                # [query, depth, x, r1, 2, ptr, mask, depth]

    dup.5
    add.1
    swap.6          
    mem_storew          # [query, depth, x, r1, 2, ptr + 1, mask, depth]
end

#================================================
#   Memory layout:
#   0. Seed
#   1. [lde_size, log2(lde_size), 0, 0]
#   2. Main trace commitment
#   3. Aux trace commitment
#   4. Constraint polynomial columns trace commitment
#   5. [lde_size, log2(lde_size), lde_domain_generator, 0]
#   6. [num_fri_layers, remainder_size, lde_size, lde_domain_generator]
#   7. Remainder commitment
#   8. Intermidiate values.
#   9. [lde_size, log2(lde_size), lde_domain_generator, 0] (same as 5 but for a different purpose)
#   10.[gz1, gz0, z1, z0]
#   11.[x, _, _, _] where x := offset * lde_domain_generator^query_index
#   20. [0, 0, 0, 1] used for hmerge in case the number of elements to be hashed is not divisible by 8
#   21. [0, 0, 0, 0] used for hmerge in case the number of elements to be hashed is divisible by 8
#   22 -> 1999 Empty for now but should hold the public inputs in the future
#   2000 -> 2015    auxiliary trace random coefficients
#   2016 -> 2250    constraint composition coefficients
#   2251    [(z^8)_1, (z^8)_0, z_1, z_0] where z = (z_0, z_1) is the OOD random element
#   2252 -> 2292    current row of the OOD evaluation frame 
#   2293 -> 2333    next row of the OOD evaluation frame 
#   2334 -> 2337    value_i for i in 0..=7 where H(z) := \sum_0^7 value_i * z^i and H is the constraint compostion polynomial
#   2338 -> 2463    Deep query coefficients
#   2473 -> 2499    [0, query, evaluation_1, evaluation_0] for the 27 FRI queries
#   2500 -> ptr_remainder - 1 where ptr_remainder := 2500 + 2 * number_of_layers
#   ptr_remainder -> ptr_remainder + remainder_length / 2
#   ptr_remainder + remainder_length / 2 + 1 -> ptr_remainder + remainder_length / 2 + length_of_remainder_polynomial/2
#================================================

# Note: 
# 1. The choice of the number of locals is based on an estimate and should be updated  
# 2. In particular, once the conjugate term in the deep queries has been removed through
#   the new Winterfell release, the number of deep query coefficients should be reduced by a 1/4.
#    The current MASM implementation assumes this when computing the sums but not for the number of 
#    coefficients. This should be updated and aligned.
# 3. Once `RandomCoin` has been redesigned, the way randomness is generated should be simplified.
# 4. The periodic values for the OOD evaluation frame are not implemented. This should probably be
#   delegated to the constraint evaluator.   
export.verify.4222

    # Load the LDE domain size as well as its log2 as [lde_size, log(lde_size), 0, 0]
    # TODO: add a log2 decorator.
    push.0.0.0.0
    adv_loadw
    loc_storew.1        # Store lde_size
    adv_loadw           #=> [main_trace_commitment, Seed]
    loc_storew.2
    swapw
    exec.reseed         
    locaddr.0
    mem_storew          
    # => [Seed_n, X, Y]


    # Draw random ExtFelt for the auxiliary trace
    # From locaddr.2000 to 2015 we have the aux randomness
    locaddr.2000
    movdn.4
    push.1
    movdn.4         
    # => [Seed, 1, ptr_rand_cstr_coef]

    repeat.16
        exec.generate_next_extfelt
        loc_loadw.0
        # => [Seed, 2, ptr + 1, X, Y]
    end


    # Reseed with auxiliary trace commitment
    swapw
    adv_loadw
    loc_storew.3
    swapw               #[Seed, AuxCom, x, x, Y, Y]
    exec.reseed         #[Seed_n, Y, Y, x, x, Y, Y]
    loc_storew.0

    # TODO: make use of these
    dropw dropw dropw  
    

    # Draw constraint composition coefficients
    # From `ptr_compos_coef = locaddr.2016` to 2250 (inclusive) we have the constraint 
    # composition random coefficients.
    # They are ordered in increasing index order and when loaded into the stack ordered as
    # (r1_1, r1_0, r0_1, r0_0)
    push.0.0
    loc_loadw.0
    locaddr.2016
    movdn.4
    push.1
    movdn.4         
    # => [Seed, 1, ptr_compos_coef]

    repeat.235
        exec.generate_next_extfelt_tuple
        loc_loadw.0
        # => [Seed, 2, ptr + 1]
    end
    # => [Seed, x, x]


    # Reseed with constraint composition polynomial commitment
    swapw
    adv_loadw
    loc_storew.4
    swapw
    exec.reseed
    loc_storew.0
    #=> [Seed_n, X, Y, ]


    # Draw OOD z
    push.1.0.0.0
    loc_storew.20
    swapw
    push.1.1.0.0
    hperm

    # TODO: optimize this
    dropw
    swapw
    dropw 
    swapw
    dropw

    # Store OOD challenge z and z^8 so that when it is loaded on stack as [z^8_1, z^8_0, z1, z0]
    drop drop
    dup.1
    dup.1
    repeat.3
        dup.1
        dup.1
        ext2mul
    end
    loc_storew.2251
    # => [X, Y, x, x, 0, 0, 0, 0, 0, 0]


    # Read [ood_main_trace_frame.current(), aux_trace_frame.current()]
    # We have 72 main trace columns and 9 aux trace columns for a total of 162 base field elements
    # 162 = 20 * 8 + 2
    # [ood_main_trace_frame.current(), aux_trace_frame.current()] is stored in locaddr.2252 to locaddr.2292.
    # They are stored from the stack as (a1_1, a1_0, a0_1, a0_0) except for locaddr.2292
    # which is stored from the stack as (a1, a0, 1, 0)
    locaddr.2252
    movdn.8
    push.1.0.0.0
    swapw.2
    repeat.20
        adv_pipe
    end

    # adv_pipe the last two elements
    dropw dropw
    adv_push.1
    adv_push.1
    push.1
    push.0
    loc_storew.2292
    push.0.0.0.0
    loc_storew.21
    hperm
    # => [X, Digest_current, X, ptr]

    # Reseed
    loc_loadw.0
    exec.reseed
    loc_storew.0
    # => [Seed_n, X, X, X, ptr]
    
    # TODO: optimize this
    dropw dropw drop drop drop
    # => [X, X, ..]

    # Read [ood_main_trace_frame.next(), aux_trace_frame.next()]
    # We have 72 main trace columns and 9 aux trace columns for a total of 162 base field elements
    # 162 = 20 * 8 + 2
    # [ood_main_trace_frame.next(), aux_trace_frame.next()] is stored in locaddr.2293 to locaddr.2333.
    # They are stored from the stack as (a1_1, a1_0, a0_1, a0_0) except for locaddr.2333
    # which is stored from the stack as (a1, a0, 1, 0)
    locaddr.2293
    movdn.8
    push.1.0.0.0
    swapw.2
    repeat.20
        adv_pipe
    end

    # adv_pipe the last two elements
    dropw dropw
    adv_push.1
    adv_push.1
    push.1
    push.0
    loc_storew.2333
    push.0.0.0.0
    hperm
    # => [X, Digest_current, X, ptr]

    # Reseed
    loc_loadw.0
    exec.reseed
    loc_storew.0
    # => [Seed_n, X, X, X, ptr]


    # Read OOD constraint evaluations. These are 8 ExtFelt `value_i` such that the value of
    # constraint evaluation function at `z` `H(z)` equals `\sum_0^7 z^i value_i`.
    # The values are stored from locaddr.2334 to locaddr.2337
    locaddr.2334
    movdn.8
    push.0.0.0.0
    swapw.2
    adv_pipe
    adv_pipe

    # Reseed
    loc_loadw.0
    exec.reseed
    loc_storew.0
    # => [Seed_n, X, X, X, ptr]

    # Compute `H(z)`

    ## Load `value_i`'s
    loc_loadw.2334
    swapw.3
    loc_loadw.2335
    swapw.2
    loc_loadw.2336
    swapw
    loc_loadw.2337

    ## Load z
    push.0.0.0.0
    loc_loadw.2251
    drop drop
    # => [z1, z0, value_7, ... ,value_0]

    # Horner evaluation
    # TODO: maybe can be done faster in another way
    repeat.6
        dup
        movdn.6
        dup.1
        movdn.7
        # => [z1, z0, value_7, value_6, z1, z0, value_5, ... ,value_0]

        ext2mul
        ext2add
        # => [acc1, acc0, z1, z0, value_5, ... ,value_0]

        movup.3
        movup.3
        # => [z1, z0, acc1, acc0, value_5, ... ,value_0]
    end

    ext2mul
    ext2add
    # => [res1, res0, x, x, X, X, 0, 0, 0, 0]

    ## TODO: Compare with the evaluation of the constraints on the EvaluationFrame


    # Draw deep composition polynomial coefficients

    ## Load Seed and prepare for drawing
    loc_loadw.0
    locaddr.2338
    movdn.4
    push.1
    movdn.4

    # => [Seed, 1, ptr, X, X, 0, 0, 0, 0]

    # Draw the random coefficients
    repeat.125
        exec.generate_next_extfelt_tuple
        loc_loadw.0
        # => [Seed, 3, ptr + 1]
    end
    # => [Seed, 251, ptr + 1]
    exec.generate_next_extfelt
    # => [Seed, 252, ptr + 1, X, X, 0, 0]


    #============================================
    #       FRI verification
    #============================================
    # Load  FRI verifier data:
    # [0, 0, lde_size, log2(lde_size)]
    loc_loadw.1

    # Make sure log2 is computed correctly
    dup
    dup.2       # [lde_size, log2(lde_size), lde_size, log2(lde_size), 0, 0]
    pow2
    eq assert

    # Compute lde_domain generator
    dup.1
    exec.compute_generator
    movdn.2
    swap
    add.1
    swap
    loc_storew.5


    # Compute [gz1, gz0, z1, z0] using domain generator
    # TODO: move to somewhere else
    push.0.0.0.0
    loc_loadw.2251
    drop drop
    dup.1
    dup.1
    dup.6
    
    # Compute trace_domain_generator
    repeat.3
        dup mul
    end

    dup
    movup.3
    mul
    swap.2
    mul
    loc_storew.10
    dropw
    ##

    # TODO: remove the need for this
    loc_storew.9
    # => [lde_size, log2(lde_size), lde_generator, 0, 0]

    dup
    push.1
    swap

    # <= [lde_size, 1, ..]
    exec.get_num_fri_layers
    movup.2
    # => [num_fri_layers, remainder_size, lde_size, lde_size, log2(lde_size), domain_gen, 0, 0, X, X]
    
    # Save [num_fri_layers, remainder_size, lde_size, domain_gen] in memory
    loc_storew.6


    # Get FRI layer commitments and reseed to draw folding challenges

    # Address containing the first layer commitment
    locaddr.2500
    swap.2 drop  # [num_layers, ptr_layer, x, x, X, X, X,       x, x]
    
    dup
    push.0
    neq
    
    while.true
        swapw               # [X, num_layers, ptr_layer, x, x, X, X]
        adv_loadw           # [Com, num_layers, ptr_layer, x, x, X, X]

        # Save commitment
        dup.5
        add.1
        swap.6
        mem_storew

        # Reseed
        movupw.2
        loc_loadw.0         # [Seed, Com, num_layers, ptr_layer + 1, x, x, X]
        exec.reseed
        loc_storew.0
        # => [Seed_n, X, Y, num_layers, ptr_layer + 1, x, x, X]

        # TODO: save the padding of hperm and use X, Y just above to loc_loadw on top of them
        swapw.2
        dropw dropw
        push.1.0.0.0
        swapw
        push.1.1.0.0


        # [0, 0, 1, 1, Seed, 0, 0, 0, 1, num_layers, ptr_layer + 1, x, x, X]
        hperm                  #[X, Res, Y,  num_layers, ptr_layer + 1, x, x, X]
        #dropw swapw
        drop drop
        loc_loadw.5
        # => [lde_size, log2(lde_size), lde_generator, 0, a1, a0, Y, num_layers, ptr_layer + 1, x, x, X]

        # Compute new lde_size and its new log
        div.4
        swap
        sub.2
        swap
        loc_storew.5

        # Move the pointer higher 
        movup.2 drop
        movup.2 drop
        swapw
        movdnw.2
        # => [lde_size, log2(lde_size), a1, a0, num_layers, ptr_layer + 1, x, x, Y, X]

        # Save [lde_size, log2(lde_size), a1, a0] in memory next to the layer commitment
        dup.5
        add.1
        swap.6
        mem_storew
        swapw
        # => [num_layers, ptr_layer + 1, x, x, lde_size, log2(lde_size), a1, a0, Y, X]

        # Decrement the FRI layer counter
        sub.1
        dup
        push.0
        neq
    end
    # => [0, ptr_layer + 2*num_layers, X, X, X, X]

    #repeat.4 dropw end

    # Shuffle the stack 
    swap
    swapw.3
    # => [x, x, x, x, X, X, ptr_layer + 2*num_layers, 0, x, x,     x, x]

    # Load remainder commitment and save it at locaddr.7
    # TODO: remove the part related to remainder commitment after the next Winterfell release
    adv_loadw
    loc_storew.7

    # Reseed with remainder commitment
    swapw
    loc_loadw.0
    exec.reseed
    loc_storew.0
    # => [Seed_n, X, X, X, ptr_layer + 2*num_layers, 0, x, x,     x, x]

    # adv_pipe the remainder codeword
    
    # Get the length of remainder
    loc_loadw.6
    locaddr.2500
    swap
    mul.2
    add
    loc_storew.8
    # => [ptr_layer + 2*num_layers, remainder_size, x, x, X, X, X, ptr_layer + 2*num_layers, 0, x, x,     x, x]
    
    dup.1
    push.32
    eq
    if.true
        # Remainder length equal to 32
        swapw.3
        loc_loadw.21    # load [0, 0, 0, 0] from memory
        swapw.2
        # => [X, X, 0, 0, 0, 0 ptr_layer + 2*num_layers, remainder_size, x, x, ptr_layer + 2*num_layers, 0, x, x,     x, x]
        
        # adv_pipe remainder codeword
        repeat.8
            adv_pipe
        end
        # => [X, Remainder_com, Y, ptr_layer + 2*num_layers + rem_len/2, remainder_size, x, x, ptr_layer + 2*num_layers, 0, x, x,     x, x]

        # Compare Remainder_com with the read commitment
        loc_loadw.7
        movup.4
        assert_eq
        movup.3
        assert_eq
        movup.2
        assert_eq
        assert_eq
        # => [Y, ptr_layer + 2*num_layers + rem_len/2, remainder_size, x, x, ptr_layer + 2*num_layers, 0, x, x, x, x, 0, 0]
        swapdw
        adv_pipe
    else
        # Remainder length equal to 64
        swapw.3
        loc_loadw.21    # load [0, 0, 0, 0] from memory
        swapw.2
        # => [X, X, 0, 0, 0, 0 ptr_layer + 2*num_layers, remainder_size, x, x, ptr_layer + 2*num_layers, 0, x, x,     x, x]
        
        # adv_pipe remainder codeword
        repeat.16
            adv_pipe
        end

        # TODO: finish
    end
    # => [X, R, Y, X] where R = [x, x, tau1, tau0]
    
    # Prepare for remainder verification procedure
    drop drop
    loc_loadw.8
    # => [ptr_layer + 2*num_layers, remainder_size, x, x, tau1, tau0, X, X]

    # Call the correct remainder verification procedure
    swap
    push.32
    eq
    if.true
        #TODO. For now:
        drop dropw
    else

    end



    # Check PoW nonce

    ## Load Seed
    loc_loadw.0
    push.1.0.0.0
    swapw
    adv_push.1
    push.1.0.0
    hperm
    swapw
    loc_storew.0

    ## Get the leading field element of the digest
    swap.3

    ## Make sure the lower 16 bits are zero
    u32split
    swap
    push.0xFFFF
    u32checked_and
    assertz

    # Draw random query indices

    # Put the pointer to the integers on the stack
    drop 
    locaddr.2473
    swap.3
    swapw.3
    push.0
    
    # Create mask
    loc_loadw.9
    sub.1
    # => [mask, log(lde_size), x, x, X, X, X]

    # Address holding the integers
    locaddr.2473
    push.1
    swapw
    loc_loadw.0
    # => [Seed, 1, ptr_integers, mask, depth, x, X, X,    x, x] where depth = log(lde_size)


    # Draw the random queries
    # TODO: the case of duplicate queries 
    exec.generate_next_integer
    repeat.26
        loc_loadw.0
        exec.generate_next_integer
    end
    # => [X, X, X, X, x, x]


    # Note: Y and y denote now garbage values instead of X and x.
    
    locaddr.2473
    repeat.27

        # Test Merkle path authentication        
        mem_loadw
        swapw
        loc_loadw.2
        swapw
        # TODO later
        #movup.2 drop
        #movup.2 drop
        #swap
        ##=> [d, query, Com, Y, Y]
        #mtree_get


        #=> [pos, depth, 0 , 0, Y, Y, Y,     y, y]

        swap.2 drop
        locaddr.2800
        swapw.3
        #=> [Y, Y, Y, ptr, depth, pos, 0,     y, y]

        loc_loadw.21
        swapw.2
        #=> [Y, Y, 0, 0, 0, 0, ptr, depth, pos, 0,     y, y]

        repeat.9
            adv_pipe
        end
        #=> [Y, L, Y, ptr, depth, pos, 0,     y, y]

        # use mtree_get using pos, depth and main trace commitment
        loc_loadw.2     # Main trace commitment
        dupw.3
        drop
        movup.2 drop
        #=> [depth, pos, C, L, Y, ptr, pos, depth, 0,     y, y]

        #mtree_get
        ##=> [V, R, L, Y, ptr, pos, depth, 0,     y, y]

        ## Check correctness of unhashing procedure
        #swapw
        #swapw.2
        #movup.4
        #assert_eq
        #movup.3
        #assert_eq
        #movup.2
        #assert_eq
        #assert_eq
        ##=> [R, Y, ptr, pos, depth, 0,     y, y]

        # TODO: remove this
        drop drop dropw

        # Aux trace part
        # Prepare for adv_pipe aux trace row
        push.1.0.0.0
        swapw.2
        adv_pipe
        adv_pipe
        dropw
        adv_push.1
        adv_push.1
        push.1
        push.0
        loc_storew.2822
        swapw #dropw
        loc_loadw.21
        #push.1.0.0.0
        hperm
        swapw.3
        add.1
        swapw.2
        #=> [Y, L, ptr, pos, depth, 0, Y,     y, y]

        # use mtree_get using pos, depth and aux trace commitment
        loc_loadw.3    # Main trace commitment
        dup.10
        dup.10

        #mtree_get
        ##=> [L, L, R, ptr, pos, depth, 0, Y,     y, y]

        ## Check correctness of unhashing procedure
        #swapw
        #swapw.2
        #movup.4
        #assert_eq
        #movup.3
        #assert_eq
        #movup.2
        #assert_eq
        #assert_eq
        ##=> [R, ptr, pos, depth, 0, Y,    y, y]

        # TODO: remove this
        drop drop dropw

        # Constraint composition trace part
        # Prepare for adv_pipe aux trace row
        swapw
        swapw.2
        #=> [Y, R, ptr, pos, depth, 0,    y, y]

        push.0.0.0.0
        swapw.2
        adv_pipe
        adv_pipe
        #=> [Y, L, Y, ptr, pos, depth, 0,       y, y]
        swapw.3
        swapw.2
        #=> [Y, L, ptr, pos, depth, 0, Y,     y, y]

        # use mtree_get using pos, depth and composition constraint trace commitment
        loc_loadw.4    # Main trace commitment
        dup.10
        dup.10
        #mtree_get

        ## Check correctness of unhashing procedure
        #swapw
        #swapw.2
        #movup.4
        #assert_eq
        #movup.3
        #assert_eq
        #movup.2
        #assert_eq
        #assert_eq
        ##=> [R, Y, ptr, depth, pos, 0,     y, y]

        # TODO: remove this once the Merkle paths are checked
        drop drop dropw

        #=> [Y, ptr, depth, pos, y, Y, y, y, 0, 0] 

        ## Inside loop over all queries but before loop over all constraints, get the three pointers:
        ## 1) ptr_coef: pointer to the deep composition polynomial coefficients 
        ## 2) ptr_ood_frame: pointer to the first word of the ood frame. ood_main_trace_frame.current and next
        ##  have a fixed offset and therefore only one pointer is needed.
        ## 3) ptr_trace: pointer to the values of the trace at the query index currently being processed.


        locaddr.2800    # p3 := ptr_trace
        locaddr.2338    # p2 := ptr_coef
        locaddr.2252    # p1 := ptr_ood_frame current. Next is 2293 i.e. 41 words offset
        push.0
        movdnw.3
        #=> [Y, ptr, depth, pos, y, Y, P, y, y, 0, 0]

        # Compute x = offset * domain_gen^pos 

        # Load domain_gen
        swapw
        push.0.0
        loc_loadw.9
        #=> [lde_size, depth, domain_gen, 0, pos, y, y, y, Y, y, y, 0, p1,       p2, p3]
        #=> [x, lde_size, depth, 0, pos, y, y, y, Y, y, y, 0, p1,       p2, p3]

        movup.2
        dup.4
        exp.u32
        mul.7
        loc_storew.11       # Store x for much later use
        swap.4
        swap.5
        #=> [y, lde_size, depth, 0, x, pos, y, y, Y, y, y, 0, p1,       p2, p3] with x := offset * domain_gen^pos 

        # Load [gz1, gz0, z1, z0] and compute [z1 - x, z0 - x, gz1 - x, gz0 - x]

        loc_loadw.10
        #=> [gz1, gz0, z1, z0, x, pos, y, y, Y, y, y, 0, p1,       p2, p3]

        neg
        dup.4
        movup.2
        sub
        movdn.4
        movdn.3
        #=> [z1, z0, x, -gz1, x -gz0, pos, y, y, Y, y, y, 0, p1,       p2, p3]

        # Compute Z := [-z1, x - z0, -gz1, x -gz0] 
        neg
        movdn.2
        sub
        swap
        movup.4
        drop
        #=> [Z, Y, Y, P] where Z := [-z1, x - z0, -gz1, x -gz0], P := [0, p1, p2, p3] 
        # and where:
        # p3:= locaddr.2800  is ptr_trace
        # p2:= locaddr.2338  is ptr_coef
        # p1:= locaddr.2293  is ptr_ood_frame

        # Prepare to compute the sum \sum_{i=0}^k{\left(\alpha_i \cdot \frac{T_i(x) - T_i(z)}{x - z} +\beta_i \cdot \frac{T_i(x) - T_i(z \cdot g)}{x - z \cdot g}
        # We can factorize (x - z) and (x - gz) and divide the two sums only once at the end.
        # The two sums are stored in [Acc3, Acc2] and [Acc1, Acc0] respectively.
        swapw
        swapdw
        push.0.0.0.0
        movdnw.3
        #=> [Y, P, Y, 0, 0, 0, 0,      Z ]
        #=> [Y, P, Y, Acc,       Z] where Acc =: [Acc3, Acc2, Acc1, Acc0]

        # Loop over i (constraints) for the currently fixed x 
        # There are 72 columns in the main trace. In each iteration of the following loop we are treating 
        # 4 columns and thus need 18 iterations.
        # The reason for having 4 different (almost) identical implementations for `proc.deep_query`
        # is due to the fact that T_i(x) is a base field element and can be in 1 of 4 possible
        # locations at a memory location. To avoid expensive pointer arithmetic we opted to have
        # one implementation for each of the 4 possiblities.
        repeat.18
        exec.deep_query_1
        exec.deep_query_2
        exec.deep_query_3
        exec.deep_query_4
        end


        # Next is the auxiliary columns. Since the aux trace has elements in the extension field we need
        # to give up one of the pointers in order to fit everything on the stack. Since the trace-row
        # currently being processed is always held in the temporary contiguous memory region pointed to
        # by locaddr.2800, we can just drop p1 and unroll the loop into as many aux trace columns.
        # Currently, we have 9 such columns and thus the following 9 similar code-blocks.

        #<= [Y, 0, p1, p2, p3, Y, Acc,      Z ]
        swapw
        movup.3
        #=> [p3, 0, p2, p3, Y, Y, Acc,      Z ]

        #=> [y, y, p2, p3, Y, Y, Acc,      Z]

        # 1073744113, 1073744235

        push.0.0
        loc_loadw.2818
        #=> [value_{i+1}1, value_{i+1}0, value_{i}1, value_{i}0, p1, p2, Y, Y, Acc,      Z ]
        drop drop
        #=> [value_{i}1, value_{i}0, p1, p2, Y, Y, Acc,      Z ]
        exec.deep_query_aux_1

        push.0.0
        loc_loadw.2818
        #=> [value_{i+1}1, value_{i+1}0, value_{i}1, value_{i}0, p1, p2, Y, Y, Acc,      Z ]
        movup.2 drop
        movup.2 drop
        #=> [value_{i+1}1, value_{i+1}0, p1, p2, Y, Y, Acc,      Z ]
        exec.deep_query_aux_2

        push.0.0
        loc_loadw.2819
        drop drop
        exec.deep_query_aux_1

        push.0.0
        loc_loadw.2819
        movup.2 drop
        movup.2 drop
        exec.deep_query_aux_2

        push.0.0
        loc_loadw.2820
        drop drop
        exec.deep_query_aux_1

        push.0.0
        loc_loadw.2820
        movup.2 drop
        movup.2 drop
        exec.deep_query_aux_2

        push.0.0
        loc_loadw.2821
        drop drop
        exec.deep_query_aux_1

        push.0.0
        loc_loadw.2821
        movup.2 drop
        movup.2 drop
        exec.deep_query_aux_2

        push.0.0
        loc_loadw.2822
        drop drop
        exec.deep_query_aux_1
        #=> [value_{i}1, value_{i}0, p1, p2, Y, Y, Acc,      Z ]

        # Move p2, the pointer to constraint random coefficients, further up the stack and prepare 
        # for loading the composition constraint polynomial part by getting the next two H_i(x) 
        # i.e. the constraint composition trace row i.e. H_i(x) and H_{i+1}(x) for current x 
        swapw.2
        loc_loadw.2823    
        #=> [H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i}(x)_1, H_{i}(x)_0, Y, value_{i}1, value_{i}0, p2, p1, Acc,      Z ]

        # Get OOD constraint evaluation frame
        swapw
        loc_loadw.2334
        #=> [H_{i+1}(z)_1, H_{i+1}(z)_0, H_{i}(z)_1, H_{i}(z)_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i}(x)_1, H_{i}(x)_0, value_{i}1, value_{i}0, p2, p1, Acc,      Z ]


        # Compute H_i(x) - H_i(z) and H_{i+1}(x) - H_{i+1}(z)
        movup.5
        movup.5
        swapw
        #=> [H_{i}(z)_1, H_{i}(z)_0, H_{i}(x)_1, H_{i}(x)_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i+1}(z)_1, H_{i+1}(z)_0, value_{i}1, value_{i}0, p2, p1, Acc,      Z ]
        ext2sub
        #=> [H_{i}_1, H_{i}_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i+1}(z)_1, H_{i+1}(z)_0, value_{i}1, value_{i}0, p2, p1, Acc,      Z ]
        # where (H_{i}_0, H_{i}_1) = (H_{i}(x)_0 - H_{i}(z)_0, H_{i}(x)_1 - H_{i}(z)_1)

        movdn.5
        movdn.5
        ext2sub
        neg
        swap
        neg
        swap
        #=> [H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, value_{i}1, value_{i}0, p2, p1, Acc,      Z ]
        # where (H_{i+1}_0, H_{i+1}_1) = (H_{i+1}(x)_0 - H_{i+1}(z)_0, H_{i+1}(x)_1 - H_{i+1}(z)_1)

        # Load the random coefficients and compute the two products for i and i+1
        swapw
        push.0.0.0.0
        dup.6
        add.1
        swap.7
        mem_loadw
        #=> [delta_{i+1}_1, delta_{i+1}_0, delta_{i}_1, delta_{i}_0, value_{i}1, value_{i}0, p2, p1, H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, Acc,      Z ]

        movupw.2
        movup.5
        movup.5
        #=> [delta_{i+1}_1, delta_{i+1}_0, H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, value_{i}1, value_{i}0, p2, p1, Acc,      Z ]
        ext2mul
        #=> [prod_{i+1}_0, prod_{i+1}_1, H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, value_{i}1, value_{i}0, p2, p1, Acc,      Z ]
        # where (prod_{i+1}_0, prod_{i+1}_1) = (H_{i+1}_0, H_{i+1}_1) * delta_{i+1}

        movdn.5
        movdn.5
        #=> [H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, prod_{i+1}_1, prod_{i+1}_0, value_{i}1, value_{i}0, p2, p1, Acc,      Z ]
        ext2mul
        movdn.3
        movdn.3
        #=> [prod_{i+1}_1, prod_{i+1}_0, prod_i_1, prod_i_0, value_{i}1, value_{i}0, p2, p1, Acc,      Z ]
        # where (prod_{i}_0, prod_{i}_1) = (H_{i}_0, H_{i}_1) * delta_{i}



        ext2add
        #=> [prod_{i+1}_1 + prod_i_1, prod_{i+1}_0 + prod_i_0, value_{i}1, value_{i}0, p2, p1, Acc,      Z ]
        #=> [accH_1, accH_0, value_{i}1, value_{i}0, p2, p1, Acc,      Z ]
        # where (accH_0, accH_1) = (prod_{i+1}_0 + prod_i_0, prod_{i+1}_1 + prod_i_1)

        # load next H_i(x) and H_{i+1}(x) for current x 
        movup.3
        movup.3
        push.0.0
        loc_loadw.2824
        #=> [H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i}(x)_1, H_{i}(x)_0, accH_1, accH_0, p2, p1, Acc,      Z ]

        # load next H_i(z) and H_{i+1}(z)
        push.0.0.0.0
        loc_loadw.2335
        #=> [H_{i+1}(z)_1, H_{i+1}(z)_0, H_{i}(z)_1, H_{i}(z)_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i}(x)_1, H_{i}(x)_0, accH_1, accH_0, p2, p1, Acc,      Z ]

        # Compute H_i(x) - H_i(z) and H_{i+1}(x) - H_{i+1}(z)
        movup.5
        movup.5
        swapw
        #=> [H_{i}(z)_1, H_{i}(z)_0, H_{i}(x)_1, H_{i}(x)_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i+1}(z)_1, H_{i+1}(z)_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        ext2sub
        #=> [H_{i}_1, H_{i}_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i+1}(z)_1, H_{i+1}(z)_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (H_{i}_0, H_{i}_1) = (H_{i}(x)_0 - H_{i}(z)_0, H_{i}(x)_1 - H_{i}(z)_1)

        movdn.5
        movdn.5
        ext2sub
        neg
        swap
        neg
        swap
        #=> [H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (H_{i+1}_0, H_{i+1}_1) = (H_{i+1}(x)_0 - H_{i+1}(z)_0, H_{i+1}(x)_1 - H_{i+1}(z)_1)


        # Load the random coefficients and compute the two products for i and i+1
        swapw
        push.0.0.0.0
        dup.6
        add.1
        swap.7
        mem_loadw
        #=> [delta_{i+1}_1, delta_{i+1}_0, delta_{i}_1, delta_{i}_0, accH_1, accH_0, p2, p1, H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, Acc,      Z ]

        movupw.2
        movup.5
        movup.5
        #=> [delta_{i+1}_1, delta_{i+1}_0, H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        ext2mul
        #=> [prod_{i+1}_0, prod_{i+1}_1, H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (prod_{i+1}_0, prod_{i+1}_1) = (H_{i+1}_0, H_{i+1}_1) * delta_{i+1}

        movdn.5
        movdn.5
        #=> [H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, prod_{i+1}_1, prod_{i+1}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        ext2mul
        movdn.3
        movdn.3
        #=> [prod_{i+1}_1, prod_{i+1}_0, prod_i_1, prod_i_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (prod_{i}_0, prod_{i}_1) = (H_{i}_0, H_{i}_1) * delta_{i}



        ext2add
        #=> [prod_{i+1}_1 + prod_i_1, prod_{i+1}_0 + prod_i_0, accH_1, accH_0, p2, p1, Acc,      Z ]

        ext2add
        #=> [accH_1, accH_0, p2, p1, Acc,      Z ]


        ## 3/4

        # load next H_i(x) and H_{i+1}(x) for current x 
        push.0.0.0.0
        loc_loadw.2825
        #=> [H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i}(x)_1, H_{i}(x)_0, accH_1, accH_0, p2, p1, Acc,      Z ]

        # load next H_i(z) and H_{i+1}(z)
        push.0.0.0.0
        loc_loadw.2336
        #=> [H_{i+1}(z)_1, H_{i+1}(z)_0, H_{i}(z)_1, H_{i}(z)_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i}(x)_1, H_{i}(x)_0, accH_1, accH_0, p2, p1, Acc,      Z ]

        # Compute H_i(x) - H_i(z) and H_{i+1}(x) - H_{i+1}(z)
        movup.5
        movup.5
        swapw
        #=> [H_{i}(z)_1, H_{i}(z)_0, H_{i}(x)_1, H_{i}(x)_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i+1}(z)_1, H_{i+1}(z)_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        ext2sub
        #=> [H_{i}_1, H_{i}_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i+1}(z)_1, H_{i+1}(z)_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (H_{i}_0, H_{i}_1) = (H_{i}(x)_0 - H_{i}(z)_0, H_{i}(x)_1 - H_{i}(z)_1)

        movdn.5
        movdn.5
        ext2sub
        neg
        swap
        neg
        swap
        #=> [H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (H_{i+1}_0, H_{i+1}_1) = (H_{i+1}(x)_0 - H_{i+1}(z)_0, H_{i+1}(x)_1 - H_{i+1}(z)_1)


        # Load the random coefficients and compute the two products for i and i+1
        swapw
        push.0.0.0.0
        dup.6
        add.1
        swap.7
        mem_loadw
        #=> [delta_{i+1}_1, delta_{i+1}_0, delta_{i}_1, delta_{i}_0, accH_1, accH_0, p2, p1, H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, Acc,      Z ]

        movupw.2
        movup.5
        movup.5
        #=> [delta_{i+1}_1, delta_{i+1}_0, H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        ext2mul
        #=> [prod_{i+1}_0, prod_{i+1}_1, H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (prod_{i+1}_0, prod_{i+1}_1) = (H_{i+1}_0, H_{i+1}_1) * delta_{i+1}

        movdn.5
        movdn.5
        #=> [H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, prod_{i+1}_1, prod_{i+1}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        ext2mul
        movdn.3
        movdn.3
        #=> [prod_{i+1}_1, prod_{i+1}_0, prod_i_1, prod_i_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (prod_{i}_0, prod_{i}_1) = (H_{i}_0, H_{i}_1) * delta_{i}

        ext2add
        #=> [prod_{i+1}_1 + prod_i_1, prod_{i+1}_0 + prod_i_0, accH_1, accH_0, p2, p1, Acc,      Z ]

        ext2add
        #=> [accH_1, accH_0, p2, p1, Acc,      Z ]

        ##4/4

        # load next H_i(x) and H_{i+1}(x) for current x 
        push.0.0.0.0
        loc_loadw.2826
        #=> [H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i}(x)_1, H_{i}(x)_0, accH_1, accH_0, p2, p1, Acc,      Z ]

        # load next H_i(z) and H_{i+1}(z)
        push.0.0.0.0
        loc_loadw.2337
        #=> [H_{i+1}(z)_1, H_{i+1}(z)_0, H_{i}(z)_1, H_{i}(z)_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i}(x)_1, H_{i}(x)_0, accH_1, accH_0, p2, p1, Acc,      Z ]

        # Compute H_i(x) - H_i(z) and H_{i+1}(x) - H_{i+1}(z)
        movup.5
        movup.5
        swapw
        #=> [H_{i}(z)_1, H_{i}(z)_0, H_{i}(x)_1, H_{i}(x)_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i+1}(z)_1, H_{i+1}(z)_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        ext2sub
        #=> [H_{i}_1, H_{i}_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i+1}(z)_1, H_{i+1}(z)_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (H_{i}_0, H_{i}_1) = (H_{i}(x)_0 - H_{i}(z)_0, H_{i}(x)_1 - H_{i}(z)_1)

        movdn.5
        movdn.5
        ext2sub
        neg
        swap
        neg
        swap
        #=> [H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (H_{i+1}_0, H_{i+1}_1) = (H_{i+1}(x)_0 - H_{i+1}(z)_0, H_{i+1}(x)_1 - H_{i+1}(z)_1)


        # Load the random coefficients and compute the two products for i and i+1
        swapw
        push.0.0.0.0
        dup.6
        add.1
        swap.7
        mem_loadw
        #=> [delta_{i+1}_1, delta_{i+1}_0, delta_{i}_1, delta_{i}_0, accH_1, accH_0, p2, p1, H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, Acc,      Z ]

        movupw.2
        movup.5
        movup.5
        #=> [delta_{i+1}_1, delta_{i+1}_0, H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        ext2mul
        #=> [prod_{i+1}_0, prod_{i+1}_1, H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (prod_{i+1}_0, prod_{i+1}_1) = (H_{i+1}_0, H_{i+1}_1) * delta_{i+1}

        movdn.5
        movdn.5
        #=> [H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, prod_{i+1}_1, prod_{i+1}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        ext2mul
        movdn.3
        movdn.3
        #=> [prod_{i+1}_1, prod_{i+1}_0, prod_i_1, prod_i_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (prod_{i}_0, prod_{i}_1) = (H_{i}_0, H_{i}_1) * delta_{i}



        ext2add
        #=> [prod_{i+1}_1 + prod_i_1, prod_{i+1}_0 + prod_i_0, accH_1, accH_0, p2, p1, Acc,      Z ]

        ext2add
        #=> [accH_1, accH_0, p2, p1, Acc,      Z ]


        #<= [accH_1, accH_0, p2, p1, acc_z_1, acc_z_0, acc_gz_1, acc_gz_0,      Z ]
        # Divide by (x - z), (x - gz)
        swapw.2
        swapw
        #=> [acc_z_1, acc_z_0, acc_gz_1, acc_gz_0, (x - z)_1, (x - z)_0, (x - gz)_1, (x - gz)_0, accH_1, accH_0, p2, p1, y, y, ]

        movup.5
        movup.5
        ext2div
        #=> [query_z_1, query_z_0, acc_gz_1, acc_gz_0, (x - gz)_1, (x - gz)_0, accH_1, accH_0, p2, p1, y, y, ]
        # where (query_z_0, query_z_1) = (acc_z_0, acc_z_1)/(x - z)

        movdn.5
        movdn.5
        #=> [acc_gz_1, acc_gz_0, (x - gz)_1, (x - gz)_0, query_z_1, query_z_0, accH_1, accH_0, p2, p1, y, y, ]

        movup.3
        movup.3
        ext2div
        #=> [query_gz_1, query_gz_0, query_z_1, query_z_0, accH_1, accH_0, p2, p1, y, y, ]


        # Sum the two accumulators to get the part of the query comming from the traces
        ext2add
        #=> [query_trace_1, query_trace_0, accH_1, accH_0, p2, p1, y, y, ]

        # Divide the constraint composition polynomial accumulator by (x - z^8)

        ## Get x 
        push.0.0.0.0
        loc_loadw.11
        movdn.3
        push.0
        loc_loadw.2251
        #=> [z^8_1, z^8_0, z1, z0, x, query_trace_1, query_trace_0, accH_1, accH_0, p2, p1, y, y, ]


        # Compute the denominator
        neg
        swap
        movup.4
        swap
        sub
        swap
        #=> [-z^8_1, x - z^8_0, z1, z0, query_trace_1, query_trace_0, accH_1, accH_0, p2, p1, y, y, ]

        # Divide by the computed denominator

        movdn.5
        movdn.5
        swapw
        #=> [-z^8_1, x - z^8_0, accH_1, accH_0, z1, z0, query_trace_1, query_trace_0, p2, p1, y, y,  ]
        ext2div
        #=> [query_constr_1, query_constr_0, z1, z0, query_trace_1, query_trace_0, p2, p1, y, y,  ]

        # Sum the two parts to get the deep evaluation query value for current x
        movup.5
        movup.5
        ext2add
        #=> [eval_tmp_1, eval_tmp_0, y, y, p2, p1, y, y, ]


        # Multiply the evaluation by the degree adj factor (alpha + x * beta)
        movup.3
        movup.3
        #=> [y, y, eval_tmp_1, eval_tmp_0, ptr_query, p2, p1, y, y, ]
        swapw
        #=> [p2, p1, y, y, y, y, eval_tmp_1, eval_tmp_0, ptr_query, ]

        # Load the next two random coefficients
        # Maybe we need to increment p2
        mem_loadw
        #=> [alpha1, alpha0, beta1, beta0, y, eval_tmp_1, eval_tmp_0, ptr_query, ]


        # Load x
        push.0.0.0.0
        loc_loadw.11
        #=> [x, y, y, y, alpha1, alpha0, beta1, beta0, y, eval_tmp_1, eval_tmp_0, ptr_query, ]

        # Compute (alpha * x + beta)
        swapw
        swap
        movup.4
        #=> [x, alpha0, alpha1, beta1, beta0, y, y, y, y, eval_tmp_1, eval_tmp_0, ptr_query, ]
        mul
        movup.3
        add
        #=> [beta0 + x* alpha0, alpha1, beta1, y, y, y, y, eval_tmp_1, eval_tmp_0, ptr_query, ]
        movdn.3
        add
        #=> [alpha1 + beta1, beta0 + x* alpha0, y, y, y, y, eval_tmp_1, eval_tmp_0, ptr_query, ]
        
        # Compute deep evaluation for the current x
        movup.7
        movup.7
        #=> [eval_tmp_1, eval_tmp_0, alpha1 + beta1, beta0 + x* alpha0, y, y, y, y, ptr_query, ]
        ext2mul
        #=> [eval_1, eval_0, y, y, y, y, ptr_query, ]

        # Store [depth, index, eval_1, eval_0] 
        # Note that depth is probably not needed for FRI
        movdn.5
        movdn.5
        dup.6
        mem_loadw
        movup.2 drop
        movup.2 drop
        #=> [depth, index, eval_1, eval_0, ptr_query]

        dup.4
        add.1
        swap.5
        mem_storew
        #=> [depth, index, eval_1, eval_0, ptr_query_n]

        dup.4
        push.0.0.0
        repeat.2
            push.0.0.0.0
        end
        swapw.2
        push.0.0
        swap.5
        push.0
        swap
    end

    repeat.4 dropw end

    # Prepare for calling the FRI verifier
    # Note that the following assumes that the FRI verifier has been modified following
    # the comment in https://github.com/0xPolygonMiden/miden-vm/pull/720
    # Also, the remainder verification responsibility has been moved to the STARK verifier
    # instead of the FRI verifier as is done further up.

    # Get the pointer to the remainder codeword
    loc_loadw.8
    swap.3
    drop drop drop
    #=>[ptr_remainder]

    # Get the pointer to the first layer commitment
    locaddr.2500

    # Get the pointer to the first FRI query
    locaddr.2473
    #=> [ptr_query, ptr_layer, ptr_remainder]

    # Call FRI verifier
    # TODO: Fix the FRI verifier and call it to conclude STARK verification

end