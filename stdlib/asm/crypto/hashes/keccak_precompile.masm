
use.std::mem
use.std::crypto::hashes::rpo

# Constants
# ================================================================================================

const.KECCAK_MEM_EVENT=event("miden_stdlib::hash::keccak::hash_mem")
const.KECCAK_STACK_EVENT=event("miden_stdlib::hash::keccak::merge_stack")

# PROCEDURES
# ================================================================================================

#! Computes Keccak256 hash of memory data.
#!
#! Input: [ptr, len_bytes, ...]
#! Output: [keccak_lo, keccak_hi, ...]
#!
#! Where:
#! - ptr: starting memory address (must be word-aligned)  
#! - len_bytes: number of bytes to hash
#! - keccak_lo, keccak_hi: 256-bit digest as two words
export.hash_mem
    exec.hash_mem_impl
    # => [commitment, keccak_lo, keccak_hi, ...]
    
    dropw
    # => [keccak_lo, keccak_hi, ...]
end

#! Internal implementation of memory-based Keccak256 computation via deferred computation.
#!
#! Emits event to populate advice stack with digest, computes commitment for tracking
#! deferred computations, and stores witness in advice map for later proof generation.
#!
#! Input: [ptr, len_bytes, ...]
#! Output: [commitment, keccak_lo, keccak_hi, ...]  
#!
#! Where:
#! - ptr: starting memory address (must be word-aligned)
#! - len_bytes: number of bytes to hash
#! - commitment: RPO(RPO(input) || RPO(hash)) for kernel tracking
#! - keccak_lo, keccak_hi: 256-bit digest as two words
export.hash_mem_impl
    emit.KECCAK_MEM_EVENT
    # => [ptr, len_bytes, ...]

    # compute len_u32 = ceil(len_bytes / 4)
    swap add.3 u32shr.2 swap
    # => [ptr, len_u32, ...]

    exec.rpo::hash_memory
    # => [RPO(input), ...]

    exec.build_commitment_from_digest
    # => [commitment, keccak_lo, keccak_hi]
end

#! Merges two 256-bit digests via Keccak256 hash.
#!
#! Input: [digest_left_lo, digest_left_hi, digest_right_lo, digest_right_hi, ...]
#! Output: [keccak_lo, keccak_hi, ...]
#!
#! Where:
#! - digest_left_lo/hi, digest_right_lo/hi: two digests to merge (as four words)
#! - keccak_lo, keccak_hi: Keccak256(left || right) as two words
export.merge_stack
    exec.merge_stack_impl
    # => [commitment, keccak_lo, keccak_hi, ...]
    
    dropw
    # => [keccak_lo, keccak_hi, ...]
end

#! Internal implementation of digest merging via deferred Keccak256 computation.
#!
#! Emits event to populate advice stack with digest, computes commitment for tracking
#! deferred computations, and stores witness in advice map for later proof generation.
#!
#! Input: [digest_left_lo, digest_left_hi, digest_right_lo, digest_right_hi, ...]
#! Output: [commitment, keccak_lo, keccak_hi, ...]
#!
#! Where:
#! - digest_left_lo/hi, digest_right_lo/hi: two digests to merge (as four words)  
#! - commitment: RPO(RPO(input) || RPO(hash)) for kernel tracking
#! - keccak_lo, keccak_hi: Keccak256(left || right) as two words
export.merge_stack_impl
    emit.KECCAK_STACK_EVENT

    # compute RPO hash of input digests
    padw swapw.2
    # => [digest_left_hi, digest_left_lo, 0, digest_right_lo, digest_right_hi, ...]

    hperm dropw dropw
    # => [capacity_left, digest_right_lo, digest_right_hi, ...]

    swapw.2
    # => [digest_right_hi, digest_right_lo, capacity_left, ...]

    hperm exec.rpo::squeeze_digest
    # => [RPO(digests), ...]

    exec.build_commitment_from_digest
    # => [commitment, keccak_lo, keccak_hi]
end

#! Common helper that builds commitment from RPO(input) and advice stack digest.
#!
#! Input: [RPO(input), ...]
#! Output: [commitment, keccak_lo, keccak_hi, ...]
#!
#! Where commitment = RPO(RPO(input) || RPO(keccak))
proc.build_commitment_from_digest
    # load digest from advice stack
    padw adv_loadw
    padw adv_loadw
    # => [keccak_lo, keccak_hi, RPO(input), ...]

    # compute commitment = RPO(RPO(input) || RPO(keccak))
    dupw.1 dupw.1 swapw hmerge
    # => [RPO(keccak), keccak_lo, keccak_hi, RPO(input), ...]

    movupw.3 swapw
    # => [RPO(keccak), RPO(input), keccak_lo, keccak_hi, ...]

    hmerge
    # => [commitment, keccak_lo, keccak_hi]
end