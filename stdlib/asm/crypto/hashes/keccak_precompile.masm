#! Keccak256 precompile wrapper using event handling for efficient computation.
#!
#! This module provides a wrapper function around the keccak precompile event handler,
#! allowing efficient keccak256 computation by deferring to the native verifier.

use.std::mem
use.std::crypto::hashes::rpo

# Constants
# ================================================================================================

#! Compute keccak256 hash using precompile event handler.
#!
#! This function takes a memory slice as input, computes its keccak256 hash using the
#! precompile event handler, writes the hash to the specified output location, and
#! returns a cryptographic commitment to the precompile call on the stack.
#!
#! The commitment is computed as RPO([RPO(input), RPO(keccak256(input))]) and can be
#! used for proof verification and precompile call validation.
#!
#! Expected stack state:
#! [ptr_in, len, ptr_out, ...]
#!
#! Final stack state:
#! [commitment, ...]
#!
#! Where:
#! - ptr_in:     memory address where input bytes start
#! - len:        number of bytes to hash
#! - ptr_out:    memory address where to write the 32-byte hash (as 8 u32s)
#! - commitment: RPO hash of [RPO(input), RPO(keccak256(input))]
export.keccak256_precompile
    # Emit keccak precompile event - this triggers the event handler which:
    # 1. Reads input bytes from memory [ptr_in, ptr_in+len)
    # 2. Computes keccak256 hash
    # 3. Pushes hash as 8 u32 values to advice stack
    # 4. Stores commitment in advice map for prover recovery
    # => [ptr_in, len, ptr_out, ...]
    emit.event("miden_stdlib::hash::keccak")

    # Compute RPO hash of the input memory range
    exec.rpo::hash_memory
    # => [RPO(input), ptr_out, ...]
    movup.4
    # => [ptr_out, RPO(input), ...]

    # Process the keccak hash from advice stack:
    # - Load 8 u32 values from advice stack using adv_pipe
    # - Write each word to memory at ptr_out
    # - Simultaneously compute RPO hash of the keccak hash
    exec.rpo::init_no_padding
    # => [R0, R1, C, ptr_out, RPO(input), ...]

    # Load 2 words (8 u32s) from advice and write them to the output region
    # and absorb them in running digest
    adv_pipe hperm

    exec.rpo::squeeze_digest
    # => [RPO(keccak_hash), ptr_out, RPO(input), ...]
    movup.4 drop
    # => [RPO(keccak_hash), RPO(input), ...]

    # Merge the two RPO hashes to create the final commitment
    # This commitment serves as fingerprint of the precompile computation.
    hmerge
    # => [commitment, ...] where commitment = RPO([RPO(input), RPO(keccak_hash)])
end