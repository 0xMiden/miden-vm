#! Keccak256 precompile wrapper using event handling for efficient computation.
#!
#! This module provides a wrapper function around the keccak precompile event handler,
#! allowing efficient keccak256 computation by deferring to the native verifier.

use.std::mem
use.std::crypto::hashes::rpo

# Constants
# ================================================================================================

const.KECCAK_EVENT=event("miden_stdlib::hash::keccak")

#! Compute keccak256 hash using precompile event handler.
#!
#! This function takes a memory slice as input, computes its keccak256 hash using the
#! precompile event handler, writes the hash to the specified output location, and
#! returns a cryptographic commitment to the precompile call on the stack.
#!
#! The commitment is computed as RPO([RPO(input), RPO(keccak256(input))]) and can be
#! used for proof verification and precompile call validation.
#!
#! Expected stack state:
#! [ptr, len, ...]
#!
#! Final stack state:
#! [commitment, keccak_hi, keccak_lo, ...]
#!
#! Where:
#! - ptr:             memory address where input bytes start
#! - len:             number of bytes to hash
#! - commitment:      RPO hash of [RPO(input), RPO(keccak256(input))]
#! - keccak_{hi, lo}: words todo
export.keccak256_precompile
    # Emit keccak precompile event - this triggers the event handler which:
    # 1. Reads input bytes from memory
    # 2. Computes keccak256 hash
    # 3. Pushes hash as 8 u32 values to advice stack
    # 4. Stores commitment in advice map for prover recovery
    # => [ptr, len, ...]
    emit.KECCAK_EVENT

    # compute len_u32 = (len+3)/4, i.e. the number of u32 elements to read from memory
    swap add.3 u32shr.2 swap
    # => [ptr, len_u32, ...]

    # Compute RPO hash of the hash input stored in the memory range [ptr, ptr + len)
    exec.rpo::hash_memory
    # => [RPO(input), ...]

    # Load hash from advice
    padw adv_loadw
    padw adv_loadw
    # => [keccak_hi, keccak_lo, RPO(input), ...]
    dupw.1 dupw.1 hmerge
    # => [RPO(keccak), keccak_hi, keccak_lo, RPO(input), ...]
    movupw.3 swapw
    # => [RPO(keccak), RPO(input), keccak_hi, keccak_lo, ...]
    hmerge
    # => [commitment, keccak_hi, keccak_lo]
    #    where commitment = RPO([RPO(input), RPO(keccak)])
end