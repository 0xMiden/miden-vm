#! Keccak256 precompile wrapper using event handling for efficient computation.
#!
#! This module provides a wrapper function around the keccak precompile event handler,
#! allowing efficient keccak256 computation by deferring to the native verifier.

use.std::mem
use.std::crypto::hashes::rpo

# Constants
# ================================================================================================


#! Size of keccak256 hash output in bytes
const.KECCAK_HASH_SIZE=32

#! Compute keccak256 hash using precompile event handler.
#!
#! This function takes a memory slice as input, computes its keccak256 hash using the
#! precompile event handler, writes the hash to the specified output location, and
#! returns a cryptographic commitment to the precompile call on the stack.
#!
#! The commitment is computed as RPO([RPO(input), RPO(keccak256(input))]) and can be
#! used for proof verification and precompile call validation.
#!
#! Expected stack state:
#! [ptr_in, len, ptr_out, ...]
#!
#! Final stack state:
#! [commitment, ...]
#!
#! Where:
#! - ptr_in:    memory address where input bytes start
#! - len:       number of bytes to hash
#! - ptr_out:   memory address where to write the 32-byte hash
#! - commitment: RPO hash of [RPO(input), RPO(keccak256(input))]
export.keccak256_precompile
    # Emit keccak precompile event - this triggers the event handler which:
    # 1. Reads input bytes from memory [ptr_in, ptr_in+len)
    # 2. Computes keccak256 hash
    # 3. Pushes hash bytes to advice stack (reversed for MASM compatibility)
    # 4. Stores commitment in advice map for prover recovery
    # => [ptr_in, len, ptr_out, ...]
    emit.event("miden_stdlib::hash::keccak")

    # Compute RPO hash of the input memory range
    exec.rpo::hash_memory
    # => [RPO(input), ptr_out, ...]
    movup.4
    # => [ptr_out, RPO(input), ...]

    # Process the keccak hash from advice stack:
    # - Load KECCAK_HASH_SIZE bytes from advice stack using adv_pipe
    # - Write each word to memory at ptr_out
    # - Simultaneously compute RPO hash of the keccak hash
    exec.rpo::init_no_padding
    # => [R0, R1, C, ptr_out, RPO(input), ...]
    repeat.4  # Process 4 double-words (32 bytes total)
        adv_pipe  # Load 2 words from advice + apply hperm
        hperm     # Apply Rescue Prime Optimized permutation
    end
    exec.rpo::squeeze_digest
    # => [RPO(keccak_hash), ptr_out, RPO(input), ...]
    movup.4 drop
    # => [RPO(keccak_hash), RPO(input), ...]

    # Merge the two RPO hashes to create the final commitment
    # This commitment proves the relationship between input and output
    hmerge
    # => [commitment, ...] where commitment = RPO([RPO(input), RPO(keccak_hash)])
end