use.std::mem
use.std::sys
use.std::word
use.std::crypto::hashes::rpo

# ENCODING CONVENTIONS
# ================================================================================================
#
# - Input bytes are stored in memory as packed u32 values in little-endian format
# - DIGEST_U32[16] = [d_0, ..., d_15] with d_i = u32::from_le_bytes([b_{4i}, ..., b_{4i+3}])
# - SHA2-512 digest is represented as 16 u32 limbs

# CONSTANTS
# ================================================================================================

const.SHA2_512_HASH_MEMORY_EVENT=event("stdlib::hash::sha2::sha512::hash_memory")

# PROCEDURES
# ================================================================================================

#! Computes SHA2-512 hash of data stored in memory.
#!
#! Input:  [ptr, len_bytes, ...]
#! Output: [DIGEST_U32[16], ...]
export.hash_memory
    exec.hash_memory_impl
    # => [COMM, TAG, DIGEST_U32[16], ...]

    exec.sys::log_precompile_request
    # => [DIGEST_U32[16], ...]
end

# INTERNAL PROCEDURES
# ================================================================================================

#! Internal implementation of memory-based SHA2-512 computation via deferred computation.
#!
#! Emits an event to populate the advice stack with the digest and store the preimage for deferred
#! verification. Returns the commitment to the calldata and its tag.
#!
#! Input:  [ptr, len_bytes, ...]
#! Output: [COMM, TAG, DIGEST_U32[16], ...]
export.hash_memory_impl.24
    emit.SHA2_512_HASH_MEMORY_EVENT
    # => [ptr, len_bytes, ...]

    # Compute len_u32 = ceil(len_bytes / 4)
    dup.1 add.3 u32shr.2 swap
    # => [ptr, len_u32, len_bytes, ...]

    exec.rpo::hash_memory
    # => [COMM_INPUT, len_bytes, ...]

    # Prepare TAG = [SHA2_512_HASH_MEMORY_EVENT, len_bytes, 0, 0]
    push.SHA2_512_HASH_MEMORY_EVENT movup.5 push.0.0 swapw
    # => [COMM_INPUT, TAG, ...]

    # Load digest from advice stack (16 u32 limbs)
    locaddr.0
    exec.rpo::init_no_padding
    debug.adv_stack
    # => [ZERO, ZERO, ZERO, digest_ptr, COMM_INPUT, TAG, ...]
    repeat.2
        adv_pipe
        debug.stack.8
        debug.mem
        hperm
    end
    exec.rpo::squeeze_digest
    # => [COMM_DIGEST, digest_ptr, COMM_INPUT, TAG, ...]
    movup.4 drop
    # => [COMM_DIGEST, COMM_INPUT, TAG, ...]
    debug.stack

    # Merge COMM_INPUT and COMM_DIGEST to compute COMM = RPO(COMM_INPUT | COMM_DIGEST)
    hmerge
    # => [COMM, TAG, ...]

    # Reload digest limbs from locals, placing them after COMM and TAG
    padw loc_loadw.12 reversew
    movdnw.2
    padw loc_loadw.8 reversew
    movdnw.2
    padw loc_loadw.4 reversew
    movdnw.2
    padw loc_loadw.0 reversew
    movdnw.2
end
