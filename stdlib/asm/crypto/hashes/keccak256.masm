# if stack top has [d, c, b, a], after completion of execution of
# this procedure stack top should look like [a, b, c, d]
proc.rev_4_elements
    swap
    movup.2
    movup.3
end

# given four elements of from each of a, b sets, following procedure computes a[i] ^ b[i] ∀ i = [0, 3]
proc.xor_4_elements
    movup.7
    u32checked_xor

    swap

    movup.6
    u32checked_xor

    movup.2
    movup.5
    u32checked_xor

    movup.4
    movup.4
    u32checked_xor
end

# Keccak-p[1600, 24] permutation's θ step mapping function, which is implemented 
# in terms of 32 -bit word size ( bit interleaved representation )
#
# See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/sha3.hpp#L55-L98 for original implementation
#
# Expected stack state :
#
# [state_addr, ...]
#
# Final stack state :
#
# [ ... ]
#
# Whole keccak-p[1600, 24] state can be represented using fifty u32 elements i.e. 13 absolute memory addresses
# s.t. last two elements of 12 -th ( when indexed from zero ) memory address are zeroed.
#
# Consecutive memory addresses can be computed by repeated application of `sub.1`.
proc.theta.3
    dup
    push.env.locaddr.0
    pop.mem

    # compute (S[0] ^ S[10] ^ S[20] ^ S[30] ^ S[40], S[1] ^ S[11] ^ S[21] ^ S[31] ^ S[41])

    # bring S[0], S[1]
    dup
    pushw.mem

    movup.2
    drop
    movup.2
    drop

    movup.2
    sub.2

    # bring S[10], S[11]
    dup
    pushw.mem

    drop
    drop

    movup.3
    u32checked_xor

    swap

    movup.3
    u32checked_xor

    swap

    movup.2
    sub.3

    # bring S[20], S[21]
    dup
    pushw.mem

    movup.2
    drop
    movup.2
    drop

    movup.3
    u32checked_xor

    swap

    movup.3
    u32checked_xor

    swap

    movup.2
    sub.2

    # bring S[30], S[31]
    dup
    pushw.mem

    drop
    drop

    movup.3
    u32checked_xor

    swap

    movup.3
    u32checked_xor

    swap

    movup.2
    sub.3

    # bring S[40], S[41]
    pushw.mem

    movup.2
    drop
    movup.2
    drop

    movup.2
    u32checked_xor

    swap

    movup.2
    u32checked_xor

    swap

    # stack = [c0, c1]
    # compute (S[2] ^ S[12] ^ S[22] ^ S[32] ^ S[42], S[3] ^ S[13] ^ S[23] ^ S[33] ^ S[43])

    push.env.locaddr.0
    push.mem
    
    # bring S[2], S[3]
    dup
    pushw.mem

    drop
    drop

    movup.2
    sub.3

    # bring S[12], S[13]
    dup
    pushw.mem

    movup.2
    drop
    movup.2
    drop

    movup.3
    u32checked_xor

    swap

    movup.3
    u32checked_xor

    swap

    movup.2
    sub.2

    # bring S[22], S[23]
    dup
    pushw.mem

    drop
    drop

    movup.3
    u32checked_xor

    swap

    movup.3
    u32checked_xor

    swap

    movup.2
    sub.3

    # bring S[32], S[33]
    dup
    pushw.mem

    movup.2
    drop
    movup.2
    drop

    movup.3
    u32checked_xor

    swap

    movup.3
    u32checked_xor

    swap

    movup.2
    sub.2

    # bring S[42], S[43]
    pushw.mem

    drop
    drop

    movup.2
    u32checked_xor

    swap

    movup.2
    u32checked_xor

    swap

    movup.3
    movup.3

    # stack = [c0, c1, c2, c3]

    push.env.locaddr.1
    popw.mem

    # compute (S[4] ^ S[14] ^ S[24] ^ S[34] ^ S[44], S[5] ^ S[15] ^ S[25] ^ S[35] ^ S[45])

    push.env.locaddr.0
    push.mem
    sub.1

    # bring S[4], S[5]
    dup
    pushw.mem

    movup.2
    drop
    movup.2
    drop

    movup.2
    sub.2

    # bring S[14], S[15]
    dup
    pushw.mem

    drop
    drop

    movup.3
    u32checked_xor

    swap

    movup.3
    u32checked_xor

    swap

    movup.2
    sub.3

    # bring S[24], S[25]
    dup
    pushw.mem

    movup.2
    drop
    movup.2
    drop

    movup.3
    u32checked_xor

    swap

    movup.3
    u32checked_xor

    swap

    movup.2
    sub.2

    # bring S[34], S[35]
    dup
    pushw.mem

    drop
    drop

    movup.3
    u32checked_xor

    swap

    movup.3
    u32checked_xor

    swap

    movup.2
    sub.3

    # bring S[44], S[45]
    pushw.mem

    movup.2
    drop
    movup.2
    drop

    movup.2
    u32checked_xor

    swap

    movup.2
    u32checked_xor

    swap

    # stack = [c4, c5]
    # compute (S[6] ^ S[16] ^ S[26] ^ S[36] ^ S[46], S[7] ^ S[17] ^ S[27] ^ S[37] ^ S[47])

    push.env.locaddr.0
    push.mem
    sub.1
    
    # bring S[6], S[7]
    dup
    pushw.mem

    drop
    drop

    movup.2
    sub.3

    # bring S[16], S[17]
    dup
    pushw.mem

    movup.2
    drop
    movup.2
    drop

    movup.3
    u32checked_xor

    swap

    movup.3
    u32checked_xor

    swap

    movup.2
    sub.2

    # bring S[26], S[27]
    dup
    pushw.mem

    drop
    drop

    movup.3
    u32checked_xor

    swap

    movup.3
    u32checked_xor

    swap

    movup.2
    sub.3

    # bring S[36], S[37]
    dup
    pushw.mem

    movup.2
    drop
    movup.2
    drop

    movup.3
    u32checked_xor

    swap

    movup.3
    u32checked_xor

    swap

    movup.2
    sub.2

    # bring S[46], S[47]
    pushw.mem

    drop
    drop

    movup.2
    u32checked_xor

    swap

    movup.2
    u32checked_xor

    swap

    movup.3
    movup.3

    # stack = [c4, c5, c6, c7]

    push.env.locaddr.2
    popw.mem

    # compute (S[8] ^ S[18] ^ S[28] ^ S[38] ^ S[48], S[9] ^ S[19] ^ S[29] ^ S[39] ^ S[49])

    push.env.locaddr.0
    push.mem
    sub.2

    # bring S[8], S[9]
    dup
    pushw.mem

    movup.2
    drop
    movup.2
    drop

    movup.2
    sub.2

    # bring S[18], S[19]
    dup
    pushw.mem

    drop
    drop

    movup.3
    u32checked_xor

    swap

    movup.3
    u32checked_xor

    swap

    movup.2
    sub.3

    # bring S[28], S[29]
    dup
    pushw.mem

    movup.2
    drop
    movup.2
    drop

    movup.3
    u32checked_xor

    swap

    movup.3
    u32checked_xor

    swap

    movup.2
    sub.2

    # bring S[38], S[39]
    dup
    pushw.mem

    drop
    drop

    movup.3
    u32checked_xor

    swap

    movup.3
    u32checked_xor

    swap

    movup.2
    sub.3

    # bring S[48], S[49]
    pushw.mem

    movup.2
    drop
    movup.2
    drop

    movup.2
    u32checked_xor

    swap

    movup.2
    u32checked_xor

    swap

    # stack = [c8, c9]

    push.env.locaddr.2
    pushw.mem
    push.env.locaddr.1
    pushw.mem

    # stack = [c0, c1, c2, c3, c4, c5, c6, c7, c8, c9]

    dup.8
    dup.4
    u32unchecked_rotl.1
    u32checked_xor

    dup.10
    dup.4
    u32checked_xor

    dup.2
    dup.8
    u32unchecked_rotl.1
    u32checked_xor

    dup.4
    dup.8
    u32checked_xor

    movup.6
    dup.11
    u32unchecked_rotl.1
    u32checked_xor

    movup.7
    dup.10
    u32checked_xor

    movup.8
    movup.13
    u32unchecked_rotl.1
    u32checked_xor

    movup.9
    movup.12
    u32checked_xor

    movup.10
    movup.10
    u32unchecked_rotl.1
    u32checked_xor

    movup.10
    movup.10
    u32checked_xor

    # stack = [d9, d8, d7, d6, d5, d4, d3, d2, d1, d0]

    swap
    movup.2
    movup.3
    movup.4
    movup.5
    movup.6
    movup.7
    movup.8
    movup.9

    # stack = [d0, d1, d2, d3, d4, d5, d6, d7, d8, d9]

    push.env.locaddr.0
    push.mem

    # compute state[0..4)

    dup
    pushw.mem

    dup.5
    u32checked_xor

    swap
    dup.6
    u32checked_xor
    swap

    movup.2
    dup.7
    u32checked_xor
    movdn.2

    movup.3
    dup.8
    u32checked_xor
    movdn.3

    dup.4
    popw.mem

    sub.1

    # compute state[4..8)

    dup
    pushw.mem

    dup.9
    u32checked_xor

    swap
    dup.10
    u32checked_xor
    swap

    movup.2
    dup.11
    u32checked_xor
    movdn.2

    movup.3
    dup.12
    u32checked_xor
    movdn.3

    dup.4
    popw.mem

    sub.1

    # compute state[8..12)

    dup
    pushw.mem

    dup.13
    u32checked_xor

    swap
    dup.14
    u32checked_xor
    swap

    movup.2
    dup.5
    u32checked_xor
    movdn.2

    movup.3
    dup.6
    u32checked_xor
    movdn.3

    dup.4
    popw.mem

    sub.1

    # compute state[12..16)

    dup
    pushw.mem

    dup.7
    u32checked_xor

    swap
    dup.8
    u32checked_xor
    swap

    movup.2
    dup.9
    u32checked_xor
    movdn.2

    movup.3
    dup.10
    u32checked_xor
    movdn.3

    dup.4
    popw.mem

    sub.1

    # compute state[16..20)

    dup
    pushw.mem

    dup.11
    u32checked_xor

    swap
    dup.12
    u32checked_xor
    swap

    movup.2
    dup.13
    u32checked_xor
    movdn.2

    movup.3
    dup.14
    u32checked_xor
    movdn.3

    dup.4
    popw.mem

    sub.1

    # compute state[20..24)

    dup
    pushw.mem

    dup.5
    u32checked_xor

    swap
    dup.6
    u32checked_xor
    swap

    movup.2
    dup.7
    u32checked_xor
    movdn.2

    movup.3
    dup.8
    u32checked_xor
    movdn.3

    dup.4
    popw.mem

    sub.1

    # compute state[24..28)

    dup
    pushw.mem

    dup.9
    u32checked_xor

    swap
    dup.10
    u32checked_xor
    swap

    movup.2
    dup.11
    u32checked_xor
    movdn.2

    movup.3
    dup.12
    u32checked_xor
    movdn.3

    dup.4
    popw.mem

    sub.1

    # compute state[28..32)

    dup
    pushw.mem

    dup.13
    u32checked_xor

    swap
    dup.14
    u32checked_xor
    swap

    movup.2
    dup.5
    u32checked_xor
    movdn.2

    movup.3
    dup.6
    u32checked_xor
    movdn.3

    dup.4
    popw.mem

    sub.1

    # compute state[32..36)

    dup
    pushw.mem

    dup.7
    u32checked_xor

    swap
    dup.8
    u32checked_xor
    swap

    movup.2
    dup.9
    u32checked_xor
    movdn.2

    movup.3
    dup.10
    u32checked_xor
    movdn.3

    dup.4
    popw.mem

    sub.1

    # compute state[36..40)

    dup
    pushw.mem

    dup.11
    u32checked_xor

    swap
    dup.12
    u32checked_xor
    swap

    movup.2
    dup.13
    u32checked_xor
    movdn.2

    movup.3
    dup.14
    u32checked_xor
    movdn.3

    dup.4
    popw.mem

    sub.1

    # compute state[40..44)

    dup
    pushw.mem

    movup.5
    u32checked_xor

    swap
    movup.5
    u32checked_xor
    swap

    movup.2
    movup.5
    u32checked_xor
    movdn.2

    movup.3
    movup.5
    u32checked_xor
    movdn.3

    dup.4
    popw.mem

    sub.1

    # compute state[44..48)

    dup
    pushw.mem

    movup.5
    u32checked_xor

    swap
    movup.5
    u32checked_xor
    swap

    movup.2
    movup.5
    u32checked_xor
    movdn.2

    movup.3
    movup.5
    u32checked_xor
    movdn.3

    dup.4
    popw.mem

    sub.1

    # compute state[48..50)

    dup
    pushw.mem

    movup.5
    u32checked_xor

    swap
    movup.5
    u32checked_xor
    swap

    movup.4
    popw.mem
end

# Keccak-p[1600, 24] permutation's ρ step mapping function, which is implemented 
# in terms of 32 -bit word size ( bit interleaved representation )
#
# See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/sha3.hpp#L115-L147 for original implementation
#
# Expected stack state :
#
# [state_addr, ...]
#
# Final stack state :
#
# [ ... ]
#
# Whole keccak-p[1600, 24] state can be represented using fifty u32 elements i.e. 13 absolute memory addresses
# s.t. last two elements of 12 -th ( when indexed from zero ) memory address are zeroed.
#
# Consecutive memory addresses can be computed by repeated application of `sub.1`.
proc.rho.1
    dup
    push.env.locaddr.0
    pop.mem

    # rotate state[0..4)
    push.0.0.0.0
    dup.4
    loadw.mem

    movup.3
    u32unchecked_rotl.1
    movdn.2

    movup.4
    dup
    sub.1
    movdn.5
    storew.mem

    # rotate state[4..8)
    dup.4
    loadw.mem

    u32unchecked_rotl.31
    swap
    u32unchecked_rotl.31
    swap

    movup.2
    u32unchecked_rotl.14
    movdn.2
    movup.3
    u32unchecked_rotl.14
    movdn.3

    movup.4
    dup
    sub.1
    movdn.5
    storew.mem

    # rotate state[8..12)
    dup.4
    loadw.mem

    u32unchecked_rotl.13
    swap
    u32unchecked_rotl.14

    movup.2
    u32unchecked_rotl.18
    movdn.2
    movup.3
    u32unchecked_rotl.18
    movdn.3

    movup.4
    dup
    sub.1
    movdn.5
    storew.mem

    # rotate state[12..16)
    dup.4
    loadw.mem

    u32unchecked_rotl.22
    swap
    u32unchecked_rotl.22
    swap

    movup.2
    u32unchecked_rotl.3
    movdn.2
    movup.3
    u32unchecked_rotl.3
    movdn.3

    movup.4
    dup
    sub.1
    movdn.5
    storew.mem

    # rotate state[16..20)
    dup.4
    loadw.mem

    u32unchecked_rotl.27
    swap
    u32unchecked_rotl.28

    movup.2
    u32unchecked_rotl.10
    movdn.2
    movup.3
    u32unchecked_rotl.10
    movdn.3

    movup.4
    dup
    sub.1
    movdn.5
    storew.mem

    # rotate state[20..24)
    dup.4
    loadw.mem

    u32unchecked_rotl.1
    swap
    u32unchecked_rotl.2

    movup.2
    u32unchecked_rotl.5
    movdn.2
    movup.3
    u32unchecked_rotl.5
    movdn.3

    movup.4
    dup
    sub.1
    movdn.5
    storew.mem

    # rotate state[24..28)
    dup.4
    loadw.mem

    u32unchecked_rotl.21
    swap
    u32unchecked_rotl.22

    movup.2
    u32unchecked_rotl.12
    movdn.3
    movup.2
    u32unchecked_rotl.13
    movdn.2

    movup.4
    dup
    sub.1
    movdn.5
    storew.mem

    # rotate state[28..32)
    dup.4
    loadw.mem

    u32unchecked_rotl.19
    swap
    u32unchecked_rotl.20

    movup.2
    u32unchecked_rotl.20
    movdn.3
    movup.2
    u32unchecked_rotl.21
    movdn.2

    movup.4
    dup
    sub.1
    movdn.5
    storew.mem
     
    # rotate state[32..36)
    dup.4
    loadw.mem

    u32unchecked_rotl.22
    swap
    u32unchecked_rotl.23

    movup.2
    u32unchecked_rotl.7
    movdn.3
    movup.2
    u32unchecked_rotl.8
    movdn.2

    movup.4
    dup
    sub.1
    movdn.5
    storew.mem

    # rotate state[36..40)
    dup.4
    loadw.mem

    u32unchecked_rotl.10
    swap
    u32unchecked_rotl.11

    movup.2
    u32unchecked_rotl.4
    movdn.2
    movup.3
    u32unchecked_rotl.4
    movdn.3

    movup.4
    dup
    sub.1
    movdn.5
    storew.mem

    # rotate state[40..44)
    dup.4
    loadw.mem
    
    u32unchecked_rotl.9
    swap
    u32unchecked_rotl.9
    swap

    movup.2
    u32unchecked_rotl.1
    movdn.2
    movup.3
    u32unchecked_rotl.1
    movdn.3

    movup.4
    dup
    sub.1
    movdn.5
    storew.mem

    # rotate state[44..48)
    dup.4
    loadw.mem

    u32unchecked_rotl.30
    swap
    u32unchecked_rotl.31

    movup.2
    u32unchecked_rotl.28
    movdn.2
    movup.3
    u32unchecked_rotl.28
    movdn.3

    movup.4
    dup
    sub.1
    movdn.5
    storew.mem

    # rotate state[48..50)
    dup.4
    loadw.mem

    u32unchecked_rotl.7
    swap
    u32unchecked_rotl.7
    swap

    movup.4
    popw.mem
end

# Keccak-p[1600, 24] permutation's π step mapping function, which is implemented 
# in terms of 32 -bit word size ( bit interleaved representation )
#
# See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/sha3.hpp#L169-L207 for original implementation
#
# Expected stack state :
#
# [state_addr, ...]
#
# Final stack state :
#
# [ ... ]
#
# Whole keccak-p[1600, 24] state can be represented using fifty u32 elements i.e. 13 absolute memory addresses
# s.t. last two elements of 12 -th ( when indexed from zero ) memory address are zeroed.
#
# Consecutive memory addresses can be computed by repeated application of `sub.1`.
proc.pi.14
    dup
    push.env.locaddr.0
    pop.mem

    push.env.locaddr.1
    swap
    push.0.0.0.0

    # place state[0..4) to desired location(s)
    dup.4
    loadw.mem

    push.0.0
    movdn.3
    movdn.3

    dup.7
    storew.mem

    drop
    drop
    movdn.3
    movdn.3

    dup.5
    sub.5
    storew.mem

    # place state[4..8) to desired location(s)
    movup.4
    sub.1
    movdn.4

    dup.4
    loadw.mem

    push.0.0
    movdn.3
    movdn.3

    dup.7
    sub.10
    storew.mem

    drop
    drop

    dup.5
    sub.2
    storew.mem

    # place state[8..12) to desired location(s)
    movup.4
    sub.1
    movdn.4

    dup.4
    loadw.mem

    push.0.0

    dup.7
    sub.7
    storew.mem

    movup.2
    drop
    movup.2
    drop

    movdn.3
    movdn.3

    dup.5
    sub.8
    storew.mem

    # place state[12..16) to desired location(s)
    movup.4
    sub.1
    movdn.4

    dup.4
    loadw.mem

    dup.5
    pushw.mem

    movup.2
    drop
    movup.2
    drop

    dup.7
    storew.mem

    dup.7
    sub.5
    loadw.mem

    movup.2
    drop
    movup.2
    drop

    dup.5
    sub.5
    storew.mem

    # place state[16..20) to desired location(s)
    movup.4
    sub.1
    movdn.4

    dup.4
    loadw.mem

    dup.5
    sub.10
    pushw.mem

    movup.2
    drop
    movup.2
    drop

    dup.7
    sub.10
    storew.mem

    drop
    drop
    drop
    drop

    push.0.0
    movdn.3
    movdn.3

    dup.5
    sub.3
    storew.mem

    # place state[20..24) to desired location(s)
    movup.4
    sub.1
    movdn.4

    dup.4
    loadw.mem

    dup.5
    sub.3
    pushw.mem

    movup.2
    drop
    movup.2
    drop

    dup.7
    sub.3
    storew.mem

    dup.7
    sub.8
    loadw.mem

    movup.2
    drop
    movup.2
    drop

    dup.5
    sub.8
    storew.mem

    # place state[24..28) to desired location(s)
    movup.4
    sub.1
    movdn.4

    dup.4
    loadw.mem

    push.0.0
    movdn.3
    movdn.3

    dup.7
    sub.1
    storew.mem

    drop
    drop
    movdn.3
    movdn.3

    dup.5
    sub.6
    storew.mem

    # place state[28..32) to desired location(s)
    movup.4
    sub.1
    movdn.4

    dup.4
    loadw.mem

    dup.5
    sub.11
    storew.mem

    # place state[32..36) to desired location(s)
    movup.4
    sub.1
    movdn.4

    dup.4
    loadw.mem

    push.0.0
    movdn.3
    movdn.3

    dup.7
    sub.4
    storew.mem

    drop
    drop
    movdn.3
    movdn.3

    dup.5
    sub.9
    storew.mem

    # place state[36..40) to desired location(s)
    movup.4
    sub.1
    movdn.4

    dup.4
    loadw.mem

    dup.5
    sub.1
    pushw.mem

    movup.2
    drop
    movup.2
    drop

    dup.7
    sub.1
    storew.mem

    dup.7
    sub.6
    loadw.mem

    movup.2
    drop
    movup.2
    drop

    dup.5
    sub.6
    storew.mem

    # place state[40..44) to desired location(s)
    movup.4
    sub.1
    movdn.4

    dup.4
    loadw.mem

    dup.5
    sub.7
    pushw.mem

    drop
    drop
    movup.3
    movup.3

    dup.7
    sub.7
    storew.mem

    drop
    drop
    drop
    drop

    push.0.0
    movdn.3
    movdn.3

    dup.5
    sub.12
    storew.mem

    # place state[44..48) to desired location(s)
    movup.4
    sub.1
    movdn.4

    dup.4
    loadw.mem

    dup.5
    sub.4
    pushw.mem

    movup.2
    drop
    movup.2
    drop

    dup.7
    sub.4
    storew.mem

    dup.7
    sub.9
    loadw.mem

    movup.2
    drop
    movup.2
    drop

    dup.5
    sub.9
    storew.mem

    # place state[48..50) to desired location(s)
    movup.4
    sub.1
    movdn.4

    dup.4
    loadw.mem

    dup.5
    sub.2
    pushw.mem

    drop
    drop
    movdn.3
    movdn.3

    dup.7
    sub.2
    storew.mem

    drop
    drop

    # memcpy
    movup.4
    drop
    push.env.locaddr.0
    push.mem
    movdn.4

    repeat.13
        dup.5
        loadw.mem

        dup.4
        storew.mem

        movup.4
        sub.1
        movdn.4

        movup.5
        sub.1
        movdn.5
    end

    dropw
    drop
    drop
end

# keccak-p[b, n_r] | b = 1600, n_r = 24, permutation's χ function, which is
# implemented in terms of 32 -bit word size; see https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/sha3.hpp#L233-L271
proc.chi.7
    popw.local.0
    popw.local.1
    popw.local.2
    popw.local.3

    pushw.local.0

    exec.rev_4_elements

    drop
    drop

    pushw.mem

    exec.rev_4_elements

    drop
    drop
    swap

    movup.2

    pushw.mem

    drop
    drop

    u32checked_not
    swap
    u32checked_not
    swap

    movup.2
    u32checked_and

    swap
    movup.2
    u32checked_and
    swap

    pushw.local.0

    drop
    repeat.2
        swap
        drop
    end

    pushw.mem

    u32checked_not
    swap
    u32checked_not
    swap

    movup.2
    u32checked_and

    swap
    movup.2
    u32checked_and

    exec.rev_4_elements
    swap

    popw.local.4 # write to c[0..4]

    pushw.local.0

    drop
    movup.2
    drop

    swap

    pushw.mem

    exec.rev_4_elements

    drop
    drop
    swap

    movup.2

    pushw.mem

    drop
    drop

    u32checked_not
    swap
    u32checked_not
    swap

    movup.2
    u32checked_and

    swap
    movup.2
    u32checked_and

    pushw.local.0

    swap
    drop
    movup.2
    drop
    swap

    pushw.mem

    exec.rev_4_elements

    drop
    drop

    u32checked_not
    swap
    u32checked_not

    movup.2
    pushw.mem

    exec.rev_4_elements

    drop
    drop

    movup.3
    u32checked_and

    swap
    movup.2
    u32checked_and

    swap
    exec.rev_4_elements

    popw.local.5 # write to c[4..8]

    pushw.local.0

    repeat.3
        swap
        drop
    end

    pushw.mem

    u32checked_not
    swap
    u32checked_not
    swap

    movup.2
    u32checked_and

    swap
    movup.2
    u32checked_and

    push.0.0
    exec.rev_4_elements

    popw.local.6 # write to c[8..10]

    pushw.local.0

    movup.3
    drop

    dup
    pushw.mem
    pushw.local.4

    exec.rev_4_elements
    exec.xor_4_elements

    movup.4

    popw.mem # write to state[0..4]

    dup
    pushw.mem
    pushw.local.5

    exec.rev_4_elements
    exec.xor_4_elements

    movup.4

    popw.mem # write to state[4..8]

    dup
    pushw.mem
    pushw.local.6

    exec.rev_4_elements
    exec.xor_4_elements

    movup.4

    popw.mem # write to state[8..10]

    pushw.local.0

    drop
    drop
    drop

    pushw.mem

    u32checked_not
    swap
    u32checked_not
    swap

    movup.2
    u32checked_and

    swap
    movup.2
    u32checked_and

    swap
    push.0.0

    popw.local.4 # write to c[0..2]

    pushw.local.1

    repeat.3
        swap
        drop
    end

    pushw.mem

    exec.rev_4_elements

    drop
    drop

    pushw.local.0

    drop
    drop
    drop

    pushw.mem

    drop
    drop

    u32checked_not
    swap
    u32checked_not
    swap

    movup.3
    u32checked_and

    swap
    movup.2
    u32checked_and

    pushw.local.1

    repeat.3
        swap
        drop
    end

    pushw.mem

    u32checked_not
    swap
    u32checked_not
    swap

    movup.2
    u32checked_and

    swap
    movup.2
    u32checked_and

    exec.rev_4_elements
    popw.local.5 # write to c[2..6]

    pushw.local.1

    repeat.3
        swap
        drop
    end

    pushw.mem

    drop
    drop

    u32checked_not
    swap
    u32checked_not
    swap

    pushw.local.0

    drop
    drop
    swap
    drop

    pushw.mem

    drop
    drop

    movup.2
    u32checked_and

    swap
    movup.2
    u32checked_and

    pushw.local.0

    drop
    drop

    pushw.mem

    drop
    drop

    u32checked_not
    swap
    u32checked_not
    swap

    movup.2

    pushw.mem

    exec.rev_4_elements

    drop
    drop

    movup.3
    u32checked_and

    swap
    movup.2
    u32checked_and
    swap

    exec.rev_4_elements
    popw.local.6 # write to c[6..10]

    pushw.local.0

    drop
    drop

    dup
    pushw.mem

    pushw.local.4

    exec.rev_4_elements
    exec.xor_4_elements

    movup.4
    popw.mem # write to state[10..12]

    dup
    pushw.mem

    pushw.local.5

    exec.rev_4_elements
    exec.xor_4_elements

    movup.4
    popw.mem # write to state[12..16]

    pushw.local.1

    repeat.3
        swap
        drop
    end

    dup
    pushw.mem

    pushw.local.6

    exec.rev_4_elements
    exec.xor_4_elements

    movup.4
    popw.mem # write to state[16..20]

    pushw.local.1

    drop
    movup.2
    drop

    pushw.mem

    drop
    drop

    u32checked_not
    swap
    u32checked_not
    swap

    movup.2

    pushw.mem

    exec.rev_4_elements

    drop
    drop

    movup.3
    u32checked_and

    swap
    movup.2
    u32checked_and
    swap

    pushw.local.1

    drop
    drop
    swap
    drop

    pushw.mem

    u32checked_not
    swap
    u32checked_not
    swap

    movup.2
    u32checked_and

    swap
    movup.2
    u32checked_and

    exec.rev_4_elements
    popw.local.4 # write to c[0..4]

    pushw.local.1

    drop
    drop

    pushw.mem

    drop
    drop

    u32checked_not
    swap
    u32checked_not
    swap

    movup.2

    pushw.mem

    exec.rev_4_elements

    drop
    drop

    movup.3
    u32checked_and

    swap
    movup.2
    u32checked_and
    swap

    pushw.local.1

    drop
    drop
    drop

    pushw.mem

    exec.rev_4_elements

    drop
    drop

    u32checked_not
    swap
    u32checked_not

    pushw.local.1

    drop
    repeat.2
        swap
        drop
    end

    pushw.mem

    exec.rev_4_elements

    drop
    drop

    movup.3
    u32checked_and

    swap
    movup.2
    u32checked_and
    swap

    exec.rev_4_elements
    popw.local.5 # write to c[4..8]

    pushw.local.1

    drop
    repeat.2
        swap
        drop
    end

    pushw.mem

    u32checked_not
    swap
    u32checked_not
    swap

    movup.2
    u32checked_and

    swap
    movup.2
    u32checked_and

    push.0.0
    exec.rev_4_elements

    popw.local.6 # write to c[8..10]

    pushw.local.1

    drop

    dup
    pushw.mem

    pushw.local.4

    exec.rev_4_elements
    exec.xor_4_elements

    movup.4
    popw.mem # write to state[20..24]

    dup
    pushw.mem

    pushw.local.5

    exec.rev_4_elements
    exec.xor_4_elements

    movup.4
    popw.mem # write to state[24..28]

    dup
    pushw.mem

    pushw.local.6

    exec.rev_4_elements
    exec.xor_4_elements

    movup.4
    popw.mem # write to state[28..30]

    pushw.local.2

    repeat.3
        swap
        drop
    end

    pushw.mem

    u32checked_not
    swap
    u32checked_not
    swap

    movup.2
    u32checked_and

    swap
    movup.2
    u32checked_and
    swap

    push.0.0
    popw.local.4 # write to c[0..2]

    pushw.local.2
    movup.2
    drop
    movup.2
    drop

    pushw.mem

    drop
    drop

    u32checked_not
    swap
    u32checked_not
    swap

    dup.2

    pushw.mem

    exec.rev_4_elements

    drop
    drop

    movup.3
    u32checked_and

    swap
    movup.2
    u32checked_and
    swap

    movup.2
    pushw.mem

    u32checked_not
    swap
    u32checked_not
    swap

    movup.2
    u32checked_and

    swap
    movup.2
    u32checked_and

    exec.rev_4_elements
    popw.local.5 # write to c[2..6]

    pushw.local.2

    drop
    repeat.2
        swap
        drop
    end

    pushw.mem

    drop
    drop

    u32checked_not
    swap
    u32checked_not
    swap

    pushw.local.1

    drop
    drop
    drop

    pushw.mem

    drop
    drop

    movup.2
    u32checked_and

    swap
    movup.2
    u32checked_and

    pushw.local.1

    drop
    drop
    drop

    pushw.mem

    drop
    drop

    u32checked_not
    swap
    u32checked_not
    swap

    pushw.local.2

    repeat.3
        swap
        drop
    end

    pushw.mem

    exec.rev_4_elements

    drop
    drop

    movup.3
    u32checked_and

    swap
    movup.2
    u32checked_and
    swap

    exec.rev_4_elements
    popw.local.6 # write to c[6..10]

    pushw.local.1

    drop
    drop
    drop

    dup

    pushw.mem

    pushw.local.4

    exec.rev_4_elements
    exec.xor_4_elements

    movup.4
    popw.mem # write to state[30..32]

    pushw.local.2

    exec.rev_4_elements

    drop
    drop
    swap

    dup
    pushw.mem

    pushw.local.5

    exec.rev_4_elements
    exec.xor_4_elements

    movup.4
    popw.mem # write to state[32..36]

    dup
    pushw.mem

    pushw.local.6

    exec.rev_4_elements
    exec.xor_4_elements

    movup.4
    popw.mem # write to state[36..40]

    pushw.local.2

    drop
    drop

    pushw.mem

    drop
    drop

    u32checked_not
    swap
    u32checked_not
    swap

    movup.2

    pushw.mem

    exec.rev_4_elements

    drop
    drop

    movup.3
    u32checked_and

    swap
    movup.2
    u32checked_and
    swap

    pushw.local.2

    drop
    drop
    drop

    pushw.mem

    u32checked_not
    swap
    u32checked_not
    swap

    movup.2
    u32checked_and

    swap
    movup.2
    u32checked_and

    exec.rev_4_elements
    popw.local.4 # write to c[0..4]

    pushw.local.2

    drop
    drop
    drop

    pushw.mem

    drop
    drop

    u32checked_not
    swap
    u32checked_not
    swap

    pushw.local.3

    repeat.3
        swap
        drop
    end

    pushw.mem

    exec.rev_4_elements

    drop
    drop

    movup.3
    u32checked_and

    swap
    movup.2
    u32checked_and
    swap

    pushw.local.3

    repeat.3
        swap
        drop
    end

    pushw.mem

    exec.rev_4_elements

    drop
    drop

    u32checked_not
    swap
    u32checked_not

    pushw.local.2

    drop
    drop
    swap
    drop

    pushw.mem

    exec.rev_4_elements

    drop
    drop

    movup.3
    u32checked_and

    swap
    movup.2
    u32checked_and
    swap

    exec.rev_4_elements
    popw.local.5 # write to c[4..8]

    pushw.local.2

    drop
    drop
    swap
    drop

    pushw.mem

    u32checked_not
    swap
    u32checked_not
    swap

    movup.2
    u32checked_and

    swap
    movup.2
    u32checked_and

    push.0.0

    exec.rev_4_elements
    popw.local.6 # write to c[8..10]

    pushw.local.2

    drop
    drop

    dup
    pushw.mem

    pushw.local.4

    exec.rev_4_elements
    exec.xor_4_elements

    movup.4
    popw.mem # write to state[40..44]

    dup
    pushw.mem

    pushw.local.5

    exec.rev_4_elements
    exec.xor_4_elements

    movup.4
    popw.mem # write to state[44..48]

    pushw.local.3

    repeat.3
        swap
        drop
    end

    dup
    pushw.mem

    pushw.local.6

    exec.rev_4_elements
    exec.xor_4_elements

    movup.4
    popw.mem # write to state[48..50]
end

# Keccak-p[1600, 24] permutation's ι ( iota ) function, which is
# implemented in terms of 32 -bit word size ( bit interleaved form ); 
# imagine https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/sha3.hpp#L288-L306
# invoked with (c0, c1) as template arguments
#
# Expected stack state :
#
# [state_addr, c0, c1, ...]
#
# Final stack state :
#
# [ ... ]
#
# All this routine does is
#
# state[0] ^= c0
# state[1] ^= c1
proc.iota
    dup
    pushw.mem

    movup.5
    u32checked_xor

    swap

    movup.5
    u32checked_xor

    swap

    movup.4
    popw.mem
end

# keccak-p[b, n_r] permutation round, without `iota` function
# ( all other functions i.e. `theta`, `rho`, `pi`, `chi` are applied in order ) | b = 1600, n_r = 24
#
# As `iota` function involves xoring constant factors with first lane of state array ( read state[0, 0] ),
# specialised implementations are maintained; see above; required to be invoked seperately after completion of
# this procedure's execution.
#
# See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/sha3.hpp#L325-L340
proc.round.4
    storew.local.0
    swapw
    storew.local.1
    movupw.2
    storew.local.2
    movupw.3
    storew.local.3

    dropw
    dropw
    dropw

    repeat.3
        swap
        drop
    end

    exec.theta

    pushw.local.0
    repeat.3
        swap
        drop
    end

    exec.rho

    pushw.local.0
    repeat.3
        swap
        drop
    end

    exec.pi

    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.chi
end

# keccak-p[1600, 24] permutation, which applies 24 rounds on state array of size  5 x 5 x 64, where each
# 64 -bit lane is represented in bit interleaved form ( in terms of two 32 -bit words ).
#
# See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/sha3.hpp#L379-L427
proc.keccak_p.5
    popw.local.0
    popw.local.1
    popw.local.2
    popw.local.3

    pushw.local.0
    repeat.3
        swap
        drop
    end
    push.env.locaddr.4
    pop.mem

    # permutation round 1
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.0.1
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 2
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.137.0
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 3
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.2147483787.0
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 4
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.2147516544.0
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 5
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.139.1
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 6
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.32768.1
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 7
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.2147516552.1
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 8
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.2147483778.1
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 9
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.11.0
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 10
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.10.0
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 11
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.32898.1
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 12
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.32771.0
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 13
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.32907.1
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 14
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.2147483659.1
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 15
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.2147483786.1
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 16
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.2147483777.1
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 17
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.2147483777.0
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 18
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.2147483656.0
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 19
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.131.0
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 20
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.2147516419.0
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 21
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.2147516552.1
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 22
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.2147483784.0
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 23
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.32768.1
    push.env.locaddr.4
    push.mem
    exec.iota

    # permutation round 24
    pushw.local.3
    pushw.local.2
    pushw.local.1
    pushw.local.0

    exec.round

    push.2147516546.0
    push.env.locaddr.4
    push.mem
    exec.iota
end

# Given two 32 -bit unsigned integers ( standard form ), representing upper and lower
# bits of a 64 -bit unsigned integer ( actually a keccak-[1600, 24] lane ),
# this function converts them into bit interleaved representation, where two 32 -bit
# unsigned integers ( even portion & then odd portion ) hold bits in even and odd
# indices of 64 -bit unsigned integer ( remember it's represented in terms of
# two 32 -bit elements )
#
# Input stack state :
#
# [hi, lo, ...]
#
# After application of bit interleaving, stack looks like
#
# [even, odd, ...]
#
# Read more about bit interleaved representation in section 2.1 of https://keccak.team/files/Keccak-implementation-3.2.pdf
#
# See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/utils.hpp#L123-L149
# for reference implementation in higher level language.
export.to_bit_interleaved
    push.0.0

    repeat.16
        u32unchecked_shr.1
        swap
        u32unchecked_shr.1
        swap

        # ---

        dup.3
        dup.3

        push.1
        u32checked_and
        swap
        push.1
        u32checked_and
        swap

        u32unchecked_shl.31
        swap
        u32unchecked_shl.15
        swap

        u32checked_xor
        u32checked_xor

        # ---

        dup.3
        dup.3

        push.2
        u32checked_and
        swap
        push.2
        u32checked_and
        swap

        u32unchecked_shl.30
        swap
        u32unchecked_shl.14
        swap

        movup.3
        u32checked_xor
        u32checked_xor
        swap

        # ---

        movup.2
        u32unchecked_shr.2
        movdn.2

        movup.3
        u32unchecked_shr.2
        movdn.3
    end

    movup.2
    drop
    movup.2
    drop
end

# Given two 32 -bit unsigned integers ( in bit interleaved form ), representing even and odd
# positioned bits of a 64 -bit unsigned integer ( actually a keccak-[1600, 24] lane ),
# this function converts them into standard representation, where two 32 -bit
# unsigned integers hold higher ( 32 -bit ) and lower ( 32 -bit ) bits of standard
# representation of 64 -bit unsigned integer
#
# Input stack state :
#
# [even, odd, ...]
#
# After application of logic, stack looks like
#
# [hi, lo, ...]
#
# This function reverts the action done by `to_bit_interleaved` function implemented above.
#
# Read more about bit interleaved representation in section 2.1 of https://keccak.team/files/Keccak-implementation-3.2.pdf
#
# See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/utils.hpp#L151-L175
# for reference implementation in higher level language.
export.from_bit_interleaved
    push.0.0

    repeat.16
        u32unchecked_shr.2
        swap
        u32unchecked_shr.2
        swap

        # ---

        dup.3
        dup.3

        push.1
        u32checked_and
        swap
        push.1
        u32checked_and
        
        u32unchecked_shl.31
        swap
        u32unchecked_shl.30
        u32checked_xor

        movup.2
        u32checked_xor
        swap

        # ---

        dup.3
        dup.3

        push.65536
        u32checked_and
        swap
        push.65536
        u32checked_and

        u32unchecked_shl.15
        swap
        u32unchecked_shl.14
        u32checked_xor

        u32checked_xor

        # ---

        movup.2
        u32unchecked_shr.1
        movdn.2

        movup.3
        u32unchecked_shr.1
        movdn.3
    end

    movup.2
    drop
    movup.2
    drop
end

# Given 64 -bytes input ( in terms of sixteen u32 elements on stack top ) to 2-to-1
# keccak256 hash function, this function prepares 5 x 5 x 64 keccak-p[1600, 24] state
# bit array such that each of twenty five 64 -bit wide lane is represented in bit
# interleaved form, using two 32 -bit integers. After completion of execution of
# this function, state array should live in allocated memory ( total fifty u32 elements, stored in
# 13 consecutive memory addresses s.t. starting absolute address is provided ).
#
# Input stack state :
#
# [state_addr, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, ...]
#
# Note, state_addr is the starting absolute memory address where keccak-p[1600, 24] state
# is kept. Consecutive addresses can be computed by repeated application of `sub.1` instruction.
#
# Final stack state :
#
# [...]
#
# See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/keccak_256.hpp#L73-L153
proc.to_state_array
    repeat.4
        movdn.4
        exec.to_bit_interleaved

        movup.3
        movup.3

        exec.to_bit_interleaved

        movup.3
        movup.3

        dup.4
        popw.mem

        sub.1
    end

    push.0.0.0.1
    dup.4
    popw.mem

    sub.1

    push.0.0.0.0
    dup.4
    popw.mem

    sub.1

    push.0.0.0.0
    dup.4
    popw.mem

    sub.1

    push.0.0.0.0
    dup.4
    popw.mem

    sub.1

    push.0.0.2147483648.0
    dup.4
    popw.mem

    sub.1

    push.0.0.0.0
    dup.4
    popw.mem

    sub.1

    push.0.0.0.0
    dup.4
    popw.mem

    sub.1

    push.0.0.0.0
    dup.4
    popw.mem

    sub.1

    push.0.0.0.0
    movup.4
    popw.mem
end

# Given 32 -bytes digest ( in terms of eight u32 elements on stack top ) in bit interleaved form,
# this function attempts to convert those into standard representation, where eight u32 elements
# live on stack top, each pair of them hold higher and lower bits of 64 -bit unsigned
# integer ( lane of keccak-p[1600, 24] state array )
#
# Input stack state :
#
# [lane0_even, lane0_odd, lane1_even, lane1_odd, lane2_even, lane2_odd, lane3_even, lane3_odd, ...]
#
# Output stack state :
#
# [dig0_hi, dig0_lo, dig1_hi, dig1_lo, dig2_hi, dig2_lo, dig3_hi, dig3_lo, ...]
#
# See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/keccak_256.hpp#L180-L209
proc.to_digest
    repeat.4
        movup.7
        movup.7

        exec.from_bit_interleaved
    end
end

# given 64 -bytes input, in terms of sixteen 32 -bit unsigned integers, where each pair
# of them holding higher & lower 32 -bits of 64 -bit unsigned integer ( reinterpreted on
# host CPU from little endian byte array ) respectively, this function computes 32 -bytes
# keccak256 digest, held on stack top, represented in terms of eight 32 -bit unsigned integers,
# where each pair of them keeps higher and lower 32 -bits of 64 -bit unsigned integer respectively
#
# See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/keccak_256.hpp#L232-L257
export.hash.13
    push.env.locaddr.0
    exec.to_state_array

    push.0.0.0
    push.env.locaddr.12

    push.env.locaddr.11
    push.env.locaddr.10
    push.env.locaddr.9
    push.env.locaddr.8

    push.env.locaddr.7
    push.env.locaddr.6
    push.env.locaddr.5
    push.env.locaddr.4

    push.env.locaddr.3
    push.env.locaddr.2
    push.env.locaddr.1
    push.env.locaddr.0

    exec.keccak_p

    pushw.local.1
    pushw.local.0

    exec.to_digest
end
