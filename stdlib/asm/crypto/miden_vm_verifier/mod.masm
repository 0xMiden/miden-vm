use.std::crypto::hashes::rpo

use.std::crypto::miden_vm_verifier::deep_queries
use.std::crypto::miden_vm_verifier::constraints_eval
use.std::crypto::miden_vm_verifier::ood_frames
use.std::crypto::miden_vm_verifier::public_inputs

use.std::crypto::stark::verifier

# Main segment width is 80 (0x50) and there are 1 (0x01) auxiliary segments
# of width 8 (0x08) using 16 (0x10) random extension field elements
const.TRACE_INFO=0x50010810

#!   Verify a STARK proof attesting to the correct execution of a program in the Miden VM.
#!   - The public inputs are composed of the input and output stacks, of fixed size equal to 16, as
#!     well as the program and the kernel procedures digests.
#!   - There are two trace segments, main and auxiliary. It is assumed that the main trace segment
#!     is 73 columns wide while the auxiliary trace segment is 8 columns wide. Note that we pad the main
#!     trace to the next multiple of 8.
#!   - The OOD evaluation frame is composed of two concatenated rows, current and next, each composed
#!     of 73 elements representing the main trace portion and 8 elements for the auxiliary trace one.
#!     Note that, due to the padding of the main trace columns, the number of OOD evaluations per row
#!     is 80 for the main trace.
#!
#! Input: [log(trace_length), num_queries, grinding,  ...]
#! Output: [...]
#!
#! Cycles:
#!  1- Remainder polynomial size 64:
#!   2515 + num_queries * (512 + num_fri_layers * 83) + 108 * num_fri_layers + 10 * log(trace_length)
#!  2- Remainder polynomial size 128:
#!   2540 + num_queries * (541 + num_fri_layers * 83) + 108 * num_fri_layers + 10 * log(trace_length)
#!
#!  where num_fri_layers is computed as:
#!
#!  1- If log(trace_length) is even, then num_fri_layers = (log(trace_length) - 6) / 2, where 6 = log2(64),
#!  2- If log(trace_length) is odd, then num_fri_layers = (log(trace_length) - 7) / 2, where 7 = log2(128).
export.verify
    # 1) Get constants

    ## a) Number of fixed length public inputs
    exec.public_inputs::get_num_fixed_len_public_inputs movdn.3
    # => [log(trace_length), num_queries, grinding, num_fixed_len_pi, ...]

    ## b) Trace info as one field element
    push.TRACE_INFO movdn.3
    # => [log(trace_length), num_queries, grinding, trace_info, num_fixed_len_pi, ...]

    ## c) Number of constraints
    exec.constraints_eval::get_num_constraints movdn.3
    # => [log(trace_length), num_queries, grinding, num_constraints, trace_info, num_fixed_len_pi, ...]

    # 2) Load the digests of all dynamically invoked procedures
    procref.deep_queries::compute_deep_composition_polynomial_queries
    procref.constraints_eval::execute_constraint_evaluation_check
    procref.ood_frames::process_row_ood_evaluations
    procref.public_inputs::process_public_inputs
    # =>[D3, D2, D1, D0, log(trace_length), num_queries, grinding, num_constraints, trace_info, num_fixed_len_pi, ...]

    # 3) Call the core verification procedure from `stdlib`
    exec.verifier::verify
    # => [...]
end