#! AEAD (Authenticated Encryption with Associated Data) implementation using RPO hash.
#!
#! This implementation uses the `crypto_stream` instruction for optimal performance.
#! The scheme follows the MonkeySpongeWrap construction:
#! 1. Initialize RPO sponge state with key and nonce
#! 2. Absorb associated data padding (currently [1,0,0,0,0,0,0,0])
#! 3. Process plaintext blocks using `crypto_stream` + `hperm`
#! 4. Generate authentication tag from final sponge state

use.std::crypto::hashes::rpo

# Constants
# ================================================================================================

const.AEAD_DECRYPT_EVENT=event("stdlib::crypto::aead::decrypt")

#! Initializes the AEAD state with a key and nonce.
#!
#! This procedure sets up the RPO sponge for AEAD operations. The key and nonce
#! are absorbed into the capacity and rate portions of the sponge.
#!
#! Input: [nonce(4), key(4), ...]
#! Output: [rate(8), capacity(4), ...]
#!
#! Where:
#! - nonce is a 4-element (1 word) nonce/IV value
#! - key is a 4-element (1 word) key
#! - rate(8) will contain the initial keystream
#! - capacity(4) maintains the sponge state
export.init_state
    # Stack: [nonce(4), key(4), ...]

    # Initialize capacity with all zeros (no domain separator for now)
    push.0.0.0.0
    # => [cap(4), nonce(4), key(4), ...]

    movdnw.2
    # => [nonce(4), key(4), cap(4), ...]

    # Apply initial permutation to mix key and nonce
    hperm
    # => [rate(8), capacity(4), ...]
end

proc.process_ad
    # Replace rate with AD padding [0,0,0,0,1,0,0,0] (empty AD with padding)
    # Note: AD is currently not supported, so we only add the padding block
    dropw dropw
    movup.3 add.1 movdn.3
    push.1.0.0.0
    padw
    # => [AD_padding(8), capacity(4), ...]
end

#! Encrypts multiple blocks from memory using the crypto_stream instruction.
#!
#! This is the main encryption procedure that processes an entire message.
#! The message must include proper padding as the last block.
#!
#! Input: [nonce(4), key(4), src_ptr, dst_ptr, num_blocks, ...]
#! Output: [tag(4), ...]
#!
#! Where:
#! - nonce is the initialization vector (4 elements)
#! - key is the encryption key (4 elements)
#! - src_ptr points to plaintext in memory (must be word-aligned, divisible by 4)
#! - dst_ptr points to where ciphertext should be written (must be word-aligned)
#! - num_blocks is the number of 8-element blocks including padding
#! - tag is the authentication tag (4 elements from first rate word)
#!
#! Memory Requirements:
#! - Plaintext must be at word-aligned addresses (addr % 4 == 0)
#! - Each block is 8 field elements (2 words)
#! - Blocks must be stored contiguously in memory
#! - src_ptr and dst_ptr MUST be different (in-place encryption not supported)
#!   This is because crypto_stream reads and writes in the same clock cycle
#!
#! Padding Requirements:
#! - Plaintext must always be padded with [1, 0, 0, ...] to make length multiple of 8
#! - The padding block must be included in num_blocks
#! - Empty plaintext requires a single padding block [1,0,0,0,0,0,0,0]
export.encrypt
    # Stack: [nonce(4), key(4), src_ptr, dst_ptr, num_blocks, ...]

    exec.init_state
    # => [rate(8), capacity(4), src_ptr, dst_ptr, num_blocks, ...]

    exec.process_ad

    # Move num_blocks to accessible position
    movup.14
    # => [num_blocks, rate(8), capacity(4), src_ptr, dst_ptr, ...]

    # Encrypt each block using crypto_stream
    dup neq.0
    while.true

        # Decrement the counter
        push.1 sub
        # => [num_blocks-1, rate(8), capacity(4), src_ptr, dst_ptr, ...]

        # Move counter out of the way
        movdn.14
        # => [rate(8), capacity(4), src_ptr, dst_ptr, num_blocks-1, ...]

        # Apply permutation to refresh keystream
        hperm
        # => [rate'(8), capacity'(4), src_ptr, dst_ptr, num_blocks-1, ...]

        # Call crypto_stream instruction
        crypto_stream
        # => [ciphertext(8), capacity'(4), src_ptr+8, dst_ptr+8, num_blocks-1, ...]

        # Check if more blocks remain
        movup.14 dup neq.0
        # => [continue?, num_blocks-1, ciphertext(8), capacity'(4), src_ptr', dst_ptr', ...]
    end

    # Drop counter
    drop
    # => [rate(8), capacity(4), src_ptr_final, dst_ptr_final, ...]

    # Generate authentication tag from current sponge state
    # Apply final permutation
    hperm
    # => [rate_final(8), capacity_final(4), src_ptr_final, dst_ptr_final, ...]

    # Extract the authentication tag (first word of rate)
    # dropw removes rate[7..4], swapw swaps rate[3..0] with capacity, dropw removes capacity
    dropw swapw dropw
    # => [rate[3], rate[2], rate[1], rate[0], src_ptr_final, dst_ptr_final, ...]

    # Clean up stack - drop the two pointers (at positions 4 and 5)
    movup.4 drop movup.4 drop
    # => [rate[3], rate[2], rate[1], rate[0], ...]
end

#! Decrypts ciphertext using non-deterministic advice and verifies authenticity.
#!
#! This procedure implements decryption through a verification approach:
#! 1. Emits event for host to decrypt ciphertext and provide plaintext via advice
#! 2. Loads claimed plaintext from advice into dst_ptr
#! 3. Re-encrypts plaintext to compute authentication tag
#! 4. Returns computed tag for caller to verify against expected tag
#!
#! The security relies on the tag being a cryptographic commitment to both plaintext
#! and ciphertext. For a fixed (key, nonce) pair, the deterministic keystream creates
#! a bijection between plaintext and ciphertext, so the tag uniquely commits to both.
#!
#! Input: [nonce(4), key(4), src_ptr, dst_ptr, num_blocks, ...]
#! Output: [tag(4), ...]
#!
#! Where:
#! - nonce is the initialization vector (4 elements)
#! - key is the decryption key (4 elements)
#! - src_ptr points to ciphertext in memory (must be word-aligned)
#! - dst_ptr points to where plaintext will be written (must be word-aligned)
#! - num_blocks is the number of 8-element blocks including padding
#! - tag is the computed authentication tag (4 elements)
#!
#! Event: Emits AEAD_DECRYPT event with (nonce, key, src_ptr, dst_ptr, num_blocks)
#! The host event handler must:
#! - Read ciphertext from memory at src_ptr
#! - Decrypt using reference implementation
#! - Insert plaintext into advice map (keyed by nonce)
#!
#! Memory Requirements:
#! - Same as encrypt: word-aligned addresses, contiguous blocks
#! - src_ptr and dst_ptr MUST be different (in-place operation not supported)
#!
#! Verification:
#! Caller must compare returned tag with expected tag. If they match, the plaintext
#! at dst_ptr is authentic. If they don't match, decryption has failed.
#!
#! Note: This procedure does NOT remove padding. The caller must handle padding removal.
export.decrypt
    # Stack: [nonce(4), key(4), src_ptr, dst_ptr, num_blocks, ...]

    # Emit event to trigger host-side decryption
    emit.AEAD_DECRYPT_EVENT
    # => [nonce(4), key(4), src_ptr, dst_ptr, num_blocks, ...]

    # Push nonce onto advice stack to use as map key for loading plaintext
    adv.push_mapval
    # This pushes the plaintext elements from advice map onto advice stack
    # => [nonce(4), key(4), src_ptr, dst_ptr, num_blocks, ...]

    # Get dst_ptr and num_words
    dup.8  # dst_ptr
    dup.11 # num_blocks
    swap
    # => [dst_ptr, num_blocks, nonce(4), key(4), src_ptr, dst_ptr, num_blocks, ...]
  
    padw padw padw

    dup.13 neq.0

    while.true
        adv_pipe
        movup.13 sub.1
        movdn.13 dup.13
        neq.0
    end
    dropw dropw dropw
    # => [dst_ptr + num_blocks, 0, nonce(4), key(4), src_ptr, dst_ptr, num_blocks, ...]
    drop drop
    # => [nonce(4), key(4), src_ptr, dst_ptr, num_blocks, ...]

    # Now swap src_ptr and dst_ptr to call encrypt on the plaintext
    movup.9 movup.9 swap movdn.8 movdn.8
    # => [nonce(4), key(4), dst_ptr, src_ptr, num_blocks, ...]

    # Call encrypt to compute tag
    exec.encrypt
    # => [tag(4), ...]
end
