#! AEAD (Authenticated Encryption with Associated Data) implementation using RPO hash.
#!
#! This implementation uses the `crypto_stream` instruction for optimal performance.
#! The scheme follows the MonkeySpongeWrap construction:
#! 1. Initialize RPO sponge state with key and nonce
#! 2. Absorb associated data padding (currently [1,0,0,0,0,0,0,0])
#! 3. Process plaintext blocks using `crypto_stream` + `hperm`
#! 4. Generate authentication tag from final sponge state

use.std::crypto::hashes::rpo

#! Initializes the AEAD state with a key and nonce.
#!
#! This procedure sets up the RPO sponge for AEAD operations. The key and nonce
#! are absorbed into the capacity and rate portions of the sponge.
#!
#! Input: [nonce(4), key(4), ...]
#! Output: [rate(8), capacity(4), ...]
#!
#! Where:
#! - nonce is a 4-element (1 word) nonce/IV value
#! - key is a 4-element (1 word) key
#! - rate(8) will contain the initial keystream
#! - capacity(4) maintains the sponge state
export.init_state
    # Stack: [nonce(4), key(4), ...]

    # Initialize capacity with all zeros (no domain separator for now)
    push.0.0.0.0
    # => [cap(4), nonce(4), key(4), ...]

    movdnw.2
    # => [nonce(4), key(4), cap(4), ...]

    # Apply initial permutation to mix key and nonce
    hperm
    # => [rate(8), capacity(4), ...]
end

proc.process_ad
    # Replace rate with AD padding [0,0,0,0,1,0,0,0] (empty AD with padding)
    # Note: AD is currently not supported, so we only add the padding block
    dropw dropw
    movup.3 add.1 movdn.3
    push.1.0.0.0
    padw
    # => [AD_padding(8), capacity(4), ...]
end

#! Encrypts multiple blocks from memory using the crypto_stream instruction.
#!
#! This is the main encryption procedure that processes an entire message.
#! The message must include proper padding as the last block.
#!
#! Input: [nonce(4), key(4), src_ptr, dst_ptr, num_blocks, ...]
#! Output: [tag(4), ...]
#!
#! Where:
#! - nonce is the initialization vector (4 elements)
#! - key is the encryption key (4 elements)
#! - src_ptr points to plaintext in memory (must be word-aligned, divisible by 4)
#! - dst_ptr points to where ciphertext should be written (must be word-aligned)
#! - num_blocks is the number of 8-element blocks including padding
#! - tag is the authentication tag (4 elements from first rate word)
#!
#! Memory Requirements:
#! - Plaintext must be at word-aligned addresses (addr % 4 == 0)
#! - Each block is 8 field elements (2 words)
#! - Blocks must be stored contiguously in memory
#! - src_ptr and dst_ptr MUST be different (in-place encryption not supported)
#!   This is because crypto_stream reads and writes in the same clock cycle
#!
#! Padding Requirements:
#! - Plaintext must always be padded with [1, 0, 0, ...] to make length multiple of 8
#! - The padding block must be included in num_blocks
#! - Empty plaintext requires a single padding block [1,0,0,0,0,0,0,0]
export.encrypt
    # Stack: [nonce(4), key(4), src_ptr, dst_ptr, num_blocks, ...]

    exec.init_state
    # => [rate(8), capacity(4), src_ptr, dst_ptr, num_blocks, ...]

    exec.process_ad

    # Move num_blocks to accessible position
    movup.14
    # => [num_blocks, rate(8), capacity(4), src_ptr, dst_ptr, ...]

    # Encrypt each block using crypto_stream
    dup neq.0
    while.true

        # Decrement the counter
        push.1 sub
        # => [num_blocks-1, rate(8), capacity(4), src_ptr, dst_ptr, ...]

        # Move counter out of the way
        movdn.14
        # => [rate(8), capacity(4), src_ptr, dst_ptr, num_blocks-1, ...]

        # Apply permutation to refresh keystream
        hperm
        # => [rate'(8), capacity'(4), src_ptr, dst_ptr, num_blocks-1, ...]

        # Call crypto_stream instruction
        crypto_stream
        # => [ciphertext(8), capacity'(4), src_ptr+8, dst_ptr+8, num_blocks-1, ...]

        # Check if more blocks remain
        movup.14 dup neq.0
        # => [continue?, num_blocks-1, ciphertext(8), capacity'(4), src_ptr', dst_ptr', ...]
    end

    # Drop counter
    drop
    # => [rate(8), capacity(4), src_ptr_final, dst_ptr_final, ...]

    # Generate authentication tag from current sponge state
    # Apply final permutation
    hperm
    # => [rate_final(8), capacity_final(4), src_ptr_final, dst_ptr_final, ...]

    # Extract the authentication tag (first word of rate)
    # dropw removes rate[7..4], swapw swaps rate[3..0] with capacity, dropw removes capacity
    dropw swapw dropw
    # => [rate[3], rate[2], rate[1], rate[0], src_ptr_final, dst_ptr_final, ...]

    # Clean up stack - drop the two pointers (at positions 4 and 5)
    movup.4 drop movup.4 drop
    # => [rate[3], rate[2], rate[1], rate[0], ...]
end
