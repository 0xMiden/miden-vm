#! AEAD (Authenticated Encryption with Associated Data) implementation using RPO hash.
#!
#! This implementation uses the `crypto_stream` instruction for optimal performance.
#! The scheme follows the MonkeySpongeWrap construction:
#! 1. Initialize RPO sponge state with key and nonce
#! 2. Absorb associated data padding (currently [1,0,0,0,0,0,0,0])
#! 3. Process plaintext blocks using `crypto_stream` + `hperm`
#! 4. Generate authentication tag from final sponge state

use.std::crypto::hashes::rpo

# Constants
# ================================================================================================

const.AEAD_DECRYPT_EVENT=event("stdlib::crypto::aead::decrypt")

# Procedures
# ================================================================================================

#! Initializes the AEAD state with a key and nonce.
#!
#! This procedure sets up the RPO sponge for AEAD operations. The key and nonce
#! are absorbed into the capacity and rate portions of the sponge.
#!
#! Input: [nonce(4), key(4), ...]
#! Output: [rate(8), capacity(4), ...]
#!
#! Where:
#! - nonce is a 4-element (1 word) nonce/IV value
#! - key is a 4-element (1 word) key
#! - rate(8) will contain the initial keystream
#! - capacity(4) maintains the sponge state
export.init_state
    # Stack: [nonce(4), key(4), ...]

    # Initialize capacity with all zeros (no domain separator for now)
    push.0.0.0.0
    # => [cap(4), nonce(4), key(4), ...]

    movdnw.2
    # => [nonce(4), key(4), cap(4), ...]

    # Apply initial permutation to mix key and nonce
    hperm
    # => [rate(8), capacity(4), ...]
end

proc.process_ad
    # Replace rate with AD padding [0,0,0,0,1,0,0,0] (empty AD with padding)
    # Note: AD is currently not supported, so we only add the padding block
    dropw dropw
    movup.3 add.1 movdn.3
    push.1.0.0.0
    padw
    # => [AD_padding(8), capacity(4), ...]
end

#! Encrypts multiple blocks from memory using the crypto_stream instruction.
#!
#! This is the main encryption procedure that processes an entire message.
#! The message must include proper padding as the last block.
#!
#! Input: [nonce(4), key(4), src_ptr, dst_ptr, num_blocks, ...]
#! Output: [tag(4), ...]
#!
#! Where:
#! - nonce is the initialization vector (4 elements)
#! - key is the encryption key (4 elements)
#! - src_ptr points to plaintext in memory (must be word-aligned, divisible by 4)
#! - dst_ptr points to where ciphertext will be written (must be word-aligned)
#! - num_blocks is the number of 8-element data blocks (including padding, excluding tag)
#! - tag is the authentication tag returned on stack (4 elements)
#!
#! Memory Layout:
#! - Input at src_ptr: [plaintext_block_0(8), plaintext_block_1(8), ..., plaintext_block_n(8)]
#! - Output at dst_ptr: [ciphertext_block_0(8), ciphertext_block_1(8), ..., ciphertext_block_n(8)]
#! - Note: Caller should write the returned tag to memory at dst_ptr + (num_blocks * 8)
#!   to create standard AEAD ciphertext format: [ciphertext_blocks..., tag(4)]
#!
#! Memory Requirements:
#! - Plaintext must be at word-aligned addresses (addr % 4 == 0)
#! - Each block is 8 field elements (2 words)
#! - Blocks must be stored contiguously in memory
#! - src_ptr and dst_ptr MUST be different (in-place encryption not supported)
#!   This is because crypto_stream reads and writes in the same clock cycle
#!
#! Padding Requirements:
#! - Plaintext must always be padded with [1, 0, 0, ...] to make length multiple of 8
#! - The padding block must be included in num_blocks
#! - Empty plaintext requires a single padding block [1,0,0,0,0,0,0,0]
export.encrypt
    # Stack: [nonce(4), key(4), src_ptr, dst_ptr, num_blocks, ...]

    # Input validation note: This procedure does not validate num_blocks or alignment.
    # Alignment errors are caught by the VM memory subsystem. Incorrect num_blocks
    # will cause the procedure to encrypt the wrong amount of data, but this is safe -
    # the resulting tag will authenticate whatever was actually encrypted.

    exec.init_state
    # => [rate(8), capacity(4), src_ptr, dst_ptr, num_blocks, ...]

    exec.process_ad

    # Move num_blocks to accessible position
    movup.14
    # => [num_blocks, rate(8), capacity(4), src_ptr, dst_ptr, ...]

    # Encrypt each block using crypto_stream
    dup neq.0
    while.true

        # Decrement the counter
        push.1 sub
        # => [num_blocks-1, rate(8), capacity(4), src_ptr, dst_ptr, ...]

        # Move counter out of the way
        movdn.14
        # => [rate(8), capacity(4), src_ptr, dst_ptr, num_blocks-1, ...]

        # Apply permutation to refresh keystream
        hperm
        # => [rate'(8), capacity'(4), src_ptr, dst_ptr, num_blocks-1, ...]

        # Call crypto_stream instruction
        crypto_stream
        # => [ciphertext(8), capacity'(4), src_ptr+8, dst_ptr+8, num_blocks-1, ...]

        # Check if more blocks remain
        movup.14 dup neq.0
        # => [continue?, num_blocks-1, ciphertext(8), capacity'(4), src_ptr', dst_ptr', ...]
    end

    # Drop counter
    drop
    # => [rate(8), capacity(4), src_ptr_final, dst_ptr_final, ...]

    # Generate authentication tag from current sponge state
    # Apply final permutation
    hperm
    # => [rate_final(8), capacity_final(4), src_ptr_final, dst_ptr_final, ...]

    # Extract the authentication tag (first word of rate)
    # dropw removes rate[7..4], swapw swaps rate[3..0] with capacity, dropw removes capacity
    dropw swapw dropw
    # => [rate[3], rate[2], rate[1], rate[0], src_ptr_final, dst_ptr_final, ...]

    # Clean up stack - drop the two pointers (at positions 4 and 5)
    movup.4 drop movup.4 drop
    # => [rate[3], rate[2], rate[1], rate[0], ...]
end

#! Decrypts and authenticates ciphertext using non-deterministic advice.
#!
#! This procedure implements AEAD decryption with automatic tag verification:
#! 1. Reads authentication tag from memory at src_ptr + (num_blocks * 8)
#! 2. Emits event for host to decrypt ciphertext and provide plaintext via advice
#! 3. Loads claimed plaintext from advice into dst_ptr
#! 4. Re-encrypts plaintext to compute authentication tag
#! 5. Compares computed tag with tag from ciphertext
#! 6. Halts execution with assertion failure if tags don't match
#!
#! The security relies on the tag being a cryptographic commitment to both plaintext
#! and ciphertext. For a fixed (key, nonce) pair, the deterministic keystream creates
#! a bijection between plaintext and ciphertext, so the tag uniquely commits to both.
#!
#! Input: [nonce(4), key(4), src_ptr, dst_ptr, num_blocks, ...]
#! Output: [] (empty stack on success, halts on failure)
#!
#! Where:
#! - nonce is the initialization vector (4 elements)
#! - key is the decryption key (4 elements)
#! - src_ptr points to ciphertext + tag in memory (must be word-aligned)
#! - dst_ptr points to where plaintext will be written (must be word-aligned)
#! - num_blocks is the number of 8-element data blocks (including padding, excluding tag)
#!
#! Memory Layout:
#! - Input at src_ptr: [ciphertext_block_0(8), ..., ciphertext_block_n(8), tag(4)]
#!   The tag word is located at address: src_ptr + (num_blocks * 8)
#! - Output at dst_ptr: [plaintext_block_0(8), ..., plaintext_block_n(8)]
#!   Note: Plaintext includes padding; caller must remove if needed
#!
#! Event: Emits AEAD_DECRYPT event with (nonce, key, src_ptr, dst_ptr, num_blocks)
#! The host event handler must:
#! - Read ciphertext from memory at src_ptr (num_blocks * 8 elements)
#! - Decrypt using reference implementation
#! - Insert plaintext into advice map (keyed by nonce)
#!
#! Memory Requirements:
#! - Same as encrypt: word-aligned addresses, contiguous blocks
#! - src_ptr and dst_ptr MUST be different (in-place operation not supported)
#!
#! Security:
#! - Tag verification is performed automatically within this procedure
#! - Execution halts with assertion failure if tags don't match
#! - If execution completes successfully, the plaintext at dst_ptr is authenticated
#! - This design ensures that unauthenticated plaintext cannot be used
#!
#! Non-Determinism Soundness:
#! This procedure uses non-deterministic advice to obtain the plaintext, which is sound
#! because:
#! 1. The prover provides claimed plaintext via advice (untrusted input)
#! 2. The procedure re-encrypts the claimed plaintext with the same (key, nonce)
#! 3. Due to deterministic encryption, the same plaintext produces the same ciphertext
#! 4. The computed tag cryptographically commits to both plaintext and ciphertext
#! 5. Comparing tags verifies that the claimed plaintext is the unique plaintext that
#!    encrypts to the given ciphertext under the given (key, nonce)
#! 6. A malicious prover cannot provide incorrect plaintext without causing tag mismatch
#!
#! This approach is secure because the tag acts as a cryptographic commitment, and the
#! deterministic keystream creates a bijection between plaintext and ciphertext spaces.
#! The prover cannot cheat: any deviation from the correct plaintext results in a
#! different tag, causing the assertion to fail and halting execution.
#!
#! Note: This procedure does NOT remove padding. The caller must handle padding removal.
export.decrypt
    # Stack: [nonce(4), key(4), src_ptr, dst_ptr, num_blocks, ...]

    # Input validation note: This procedure does not validate num_blocks or alignment.
    # Alignment errors are caught by the VM memory subsystem. Incorrect num_blocks
    # values are caught by tag verification - if num_blocks doesn't match what was
    # used during encryption, the tag comparison will fail and execution will halt.

    # Compute the pointer to the tag for later use
    dup.10 mul.8
    dup.9
    add
    movdn.11
    # => [nonce(4), key(4), src_ptr, dst_ptr, num_blocks, tag_ptr, ...]

    # Emit event to trigger host-side decryption
    emit.AEAD_DECRYPT_EVENT
    # => [nonce(4), key(4), src_ptr, dst_ptr, num_blocks, tag_ptr, ...]

    # Push nonce onto advice stack to use as map key for loading plaintext
    adv.push_mapval
    # This pushes the plaintext elements from advice map onto advice stack
    # => [nonce(4), key(4), src_ptr, dst_ptr, num_blocks, tag_ptr, ...]

    # Get dst_ptr
    dup.9  # dst_ptr
    dup.11 # num_blocks
    swap
    # => [dst_ptr, num_blocks, nonce(4), key(4), src_ptr, dst_ptr, num_blocks, tag_ptr, ...]

    padw padw padw

    dup.13 neq.0

    while.true
        adv_pipe
        movup.13 sub.1
        movdn.13 dup.13
        neq.0
    end

    dropw dropw dropw
    # => [dst_ptr + num_blocks, 0, nonce(4), key(4), src_ptr, dst_ptr, num_blocks, tag_ptr, ...]
    drop drop
    # => [nonce(4), key(4), src_ptr, dst_ptr, num_blocks, tag_ptr, ...]

    # Now swap src_ptr and dst_ptr to call encrypt on the plaintext
    movup.9 movup.9 swap movdn.9 movdn.9
    # => [nonce(4), key(4), dst_ptr, src_ptr, num_blocks, tag_ptr, ...]

    # Call encrypt to compute tag
    exec.encrypt
    # => [tag(4), tag_ptr, ...]

    # Compare with the authentication tag that is attached to the ciphertext
    padw movup.8 mem_loadw_be
    eqw assert
    dropw dropw
end
