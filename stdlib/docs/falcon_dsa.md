
## std::crypto::dsa::falcon
| Procedure | Description |
| ----------- | ------------- |
| normalize_poly512.128 |  Given a degree 512 polynomial on stack, using its starting (absolute) memory address, <br /> this routine normalizes each coefficient of the polynomial, using above defined <br /> `normalize()` routine<br /><br /> Imagine, f is the given polynomial of degree 512. It can be normalized using<br /><br /> g = [normalize(f[i]) for i in range(512)]<br /><br /> Expected stack state :<br /><br /> [f_start_addr, ...] \| next 127 absolute addresses can be computed using `INCR` instruction<br /><br /> Post normalization stack state looks like<br /><br /> [g_start_addr, ...] \| next 127 absolute addresses can be computed using `INCR` instruction<br /><br /> Note, input polynomial which is provided using memory addresses, is not mutated. |
| squared_norm_poly512 |  Given a degree 512 polynomial in coefficient form, as absolute memory addresses on stack,<br /> this routine computes squared norm of that vector, using following formula<br /><br /> Say, f = [a0, a1, a2, ..., a510, a511]<br />      g = sq_norm(f) = a0 ^ 2 + a1 ^ 2 + ... + a510 ^ 2 + a511 ^ 2<br /><br /> Expected input stack state :<br /><br /> [f_addr0, f_addr1, ..., f_add126, f_addr127, ...] \| f_addr`i` holds f[(i << 2) .. ((i+1) << 2)]<br /><br /> Final stack state :<br /><br /> [g, ...] \| g = sq_norm(f) |
| verify.129 |  Falcon-512 Digital Signature Verification routine<br /><br /> Given four degree-512 polynomials, using absolute memory addresses on stack ( i.e. <br /> 512 memory addresses will be placed on stack ), this routine checks whether it's a valid<br /> Falcon signature or not.<br /><br /> Four degree-512 polynomials, which are provided ( in order )<br /><br /> f = [f0, f1, ..., f510, f511] -> decompressed Falcon-512 signature<br /> g = [g0, g1, ..., g510, g511] -> public key used for signing input message<br /> h = [h0, h1, ..., h510, h511] -> input message hashed using SHAKE256 XOF and converted to polynomial<br /> k = [k0, k1, ..., k510, k511] -> [abs(i) for i in f] \| abs(a) = a < 0 ? 0 - a : a<br /><br /> Each of these polynomials are represented using 128 absolute memory addresses, each holding<br /> four consecutive coefficients such as<br /><br /> f`i` holds f[(i << 2) .. ((i+1) << 2)] \| i âˆˆ [0..128)<br /><br /> Expected stack state :<br /><br /> [f_addr0, f_addr1, ..., f_addr126, f_addr127, g_addr0, g_addr1, ..., g_addr126, g_addr127, <br />  h_addr0, h_addr1, ..., h_addr126, h_addr127, k_addr0, k_addr1, ..., k_addr126, k_addr127, ...] \| 512 absolute memory addresses<br /><br /> After execution of verification routine, stack looks like<br /><br /> [ ... ]<br /><br /> If verification fails, program execution just stops, due to asserting failure !<br /><br /> Note, none of these input memory addresses ( 512 of them ) are mutated during execution of verification routine. |
