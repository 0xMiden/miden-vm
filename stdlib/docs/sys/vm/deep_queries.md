
## std::sys::vm::deep_queries
| Procedure | Description |
| ----------- | ------------- |
| compute_deep_composition_polynomial_queries | Computes the DEEP composition polynomial FRI queries.<br /><br />This procedures iterates over all FRI query indices stored in memory at `query_ptr` in<br />a word-aligned and overwrites each word with `[eval0, eval1, index, poe]` where:<br /><br />1. `index` is the FRI query index,<br />2. `poe := g^index`, with `g` being the evaluation domain generator,<br />3. `eval := (eval0, eval1)` is the computed DEEP composition polynomial query.<br /><br />Inputs:  [Y, query_ptr, query_end_ptr, W, query_ptr]<br />Outputs: []<br /><br />where:<br /><br />1. `Y` is a garbage word,<br />2. `query_ptr` is a pointer to the memory region from where the query indices will be fetched<br />and to where the computed FRI queries will be stored in a word-aligned manner,<br />3. `query_end_ptr` is a memory pointer used to indicate the end of the memory region used in<br />storing the computed FRI queries,<br />4. `W` is the word `[q_z_0, q_z_1, q_gz_0, q_gz_1]` where `q_z = (q_z_0, q_z_1)` and<br />`q_gz = (q_gz_0, q_gz_1)` represent the constant terms across all FRI queries computations.<br /> |
| load_query_row | Loads the next query rows in the main, auxiliary and constraint composition polynomials traces<br />and computes the values of the DEEP code word at the index corresponding to the query.<br /><br />It takes a pointer to the current random query index and returns that index, together with<br />the value<br /><br />Q^x(alpha) = (q_x_at_alpha_0, q_x_at_alpha_1) = \sum_{i=0}^{n+m+l} T_i * alpha^i<br /><br />where:<br /><br />1. n, m and l are the widths of the main segment, auxiliary segment and constraint composition<br />traces, respectively.<br />2. T_i are the values of columns in the main segment, auxiliary segment and constraint<br />composition traces, for the query.<br />3. alpha is the randomness used in order to build the DEEP polynomial.<br /><br />Inputs:  [Y, query_ptr]<br />Outputs: [Y, q_x_at_alpha_1, q_x_at_alpha_0, q_x_at_alpha_1, q_x_at_alpha_0, index, query_ptr]<br /><br />where:<br />- Y is a "garbage" word.<br /> |
| process_main_segment_execution_trace | Handles the logic for processing the main segment of the execution trace.<br /><br />Inputs: [Y, query_ptr]<br />Output: [Y, ptr_x, ptr_alpha_inv, acc1, acc0, depth, index, query_ptr]<br /> |
| load_main_segment_execution_trace | Loads the portion of the query associated to the main segment of the execution trace.<br /><br />Inputs:  [Y, Y, 0, 0, 0, 0, ptr]<br />Outputs: [Y, D, C, ptr]<br /><br />Cycles: 30<br /> |
| process_aux_segment_execution_trace | Handles the logic for processing the auxiliary segment of the execution trace, if such a trace<br />exists.<br /><br />Inputs: [Y, ptr_x, ptr_alpha_inv, acc1, acc0, depth, index, query_ptr]<br />Output: [Y, ptr_x, ptr_alpha_inv, acc1, acc0, depth, index, query_ptr]<br /> |
| load_aux_segment_execution_trace | Loads the portion of the query associated to the auxiliary segment of the execution trace.<br /><br />Inputs:  [Y, Y, 0, 0, 0, 0, ptr]<br />Outputs: [Y, D, C, ptr]<br /><br />Cycles: 6<br /> |
| process_constraints_composition_poly_trace | Handles the logic for processing the constraints composition polynomials trace.<br /><br />Inputs: [Y, ptr_x, ptr_alpha_inv, acc1, acc0, depth, index, query_ptr]<br />Output: [Y, q_x_at_alpha_1, q_x_at_alpha_0, q_x_at_alpha_1, q_x_at_alpha_0, index, query_ptr]<br /> |
| load_constraints_composition_polys_trace | Loads the portion of the query associated to the constraints composition polynomials trace.<br /><br />Inputs:  [Y, Y, 0, 0, 0, 0, ptr]<br />Outputs: [Y, D, C, ptr]<br /><br />Cycles: 6<br /> |
