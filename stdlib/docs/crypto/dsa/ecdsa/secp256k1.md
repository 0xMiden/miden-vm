
## std::crypto::dsa::ecdsa::secp256k1
| Procedure | Description |
| ----------- | ------------- |
| verify | Verifies an ECDSA signature over the secp256k1 curve.<br /><br />This procedure uses deferred verification via a precompile. The actual cryptographic<br />verification is performed by the host, and the result is provided via the advice stack.<br /><br />Input: `[ptr_pk, ptr_digest, ptr_sig, ...]`<br />Output: `[result, ...]`<br /><br />Where:<br />- `ptr_pk`: word-aligned memory address containing the 33-byte compressed secp256k1 public key<br />- `ptr_digest`: word-aligned memory address containing the 32-byte message digest<br />- `ptr_sig`: word-aligned memory address containing the 66-byte signature<br />- `result`: 1 if the signature is valid, 0 if invalid<br /><br />All data must be stored in memory as packed u32 values (little-endian), with unused bytes<br />in the final u32 set to zero.<br /> |
| verify_impl | Internal implementation of ECDSA signature verification via deferred computation.<br /><br />Emits an event to trigger the precompile handler, reads the verification result from<br />the advice stack, and computes the commitment and tag for tracking deferred verification.<br /><br />Input: `[ptr_pk, ptr_digest, ptr_sig, ...]`<br />Output: `[COMM, TAG, result, ...]`<br /><br />Where:<br />- `ptr_pk`: word-aligned memory address containing 33-byte public key<br />- `ptr_digest`: word-aligned memory address containing 32-byte digest<br />- `ptr_sig`: word-aligned memory address containing 66-byte signature<br />- `COMM`: commitment to calldata computed as<br />`Rpo256(Rpo256(Rpo256(pk) \|\| Rpo256(digest)) \|\| Rpo256(sig))`<br />- `TAG`: `[ECDSA_VERIFY_EVENT, result, 0, 0]`<br />- `result`: 1 if signature is valid, 0 if invalid<br /> |
| verify_deprecated | Given an ECDSA public key ( in projective coordinate system i.e. each secp256k1 curve point<br />is represented in terms of X, Y, Z coordinates ), hashed message h ( a 256 -bit element represented<br />in Montgomery form ) and an ECDSA signature, represented in terms of (r, s) s.t. each of them are<br />represented in Montgomery form, this routine attempts to verify the ECDSA signature.<br /><br />Expected stack state<br /><br />[X, Y, Z, h, r, s, ...] i.e. total 48 elements on stack top<br /><br />X -> x0, x1, x2, x3, x4, x5, x6, x7 ( secp256k1 base field element, in Montgomery form )<br />Y -> y0, y1, y2, y3, y4, y5, y6, y7 ( secp256k1 base field element, in Montgomery form )<br />Z -> z0, z1, z2, z3, z4, z5, z6, z7 ( secp256k1 base field element, in Montgomery form )<br />h -> h0, h1, h2, h3, h4, h5, h6, h7 ( secp256k1 scalar field element, in Montgomery form )<br />r -> r0, r1, r2, r3, r4, r5, r6, r7 ( secp256k1 scalar field element, in Montgomery form )<br />s -> s0, s1, s2, s3, s4, s5, s6, s7 ( secp256k1 scalar field element, in Montgomery form )<br /><br />Final stack state<br /><br />[ ... ]<br /><br />If verification fails, program execution will be aborted.<br /><br />See https://github.com/itzmeanjan/secp256k1/blob/37b339db3e03d24c2977399eb8896ef515ebb09b/ecdsa/verify.py#L11-L45<br /> |
