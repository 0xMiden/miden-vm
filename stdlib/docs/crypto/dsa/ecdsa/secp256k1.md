
## std::crypto::dsa::ecdsa::secp256k1
| Procedure | Description |
| ----------- | ------------- |
| verify | Verifies an ECDSA signature over the secp256k1 curve.<br /><br />This procedure uses deferred verification via a precompile. The actual cryptographic<br />verification is performed by the host, and the result is provided via the advice stack.<br /><br />Input: `[pk_ptr, digest_ptr, sig_ptr, ...]`<br />Output: `[result, ...]`<br /><br />Where:<br />- `pk_ptr`: word-aligned memory address containing the 33-byte compressed secp256k1 public key<br />- `digest_ptr`: word-aligned memory address containing the 32-byte message digest<br />- `sig_ptr`: word-aligned memory address containing the 66-byte signature<br />- `result`: 1 if the signature is valid, 0 if invalid<br /><br />All data must be stored in memory as packed u32 values (little-endian), with unused bytes<br />in the final u32 set to zero.<br /> |
| verify_impl | Internal implementation of ECDSA signature verification via deferred computation.<br /><br />Emits an event to trigger the precompile handler, reads the verification result from<br />the advice stack, and computes the commitment and tag for tracking deferred verification.<br /><br />This procedure mimics the `ecdsa_secp256k1::PublicKey::verify_prehash()` function from<br />`miden-crypto`, which takes a pre-hashed message that the caller must provide<br />(e.g. obtained using the keccak256 precompile).<br /><br />Input: `[pk_ptr, digest_ptr, sig_ptr, ...]`<br />Output: `[COMM, TAG, result, ...]`<br /><br />Where:<br />- `pk_ptr`: word-aligned memory address containing 33-byte public key<br />- `digest_ptr`: word-aligned memory address containing 32-byte digest<br />- `sig_ptr`: word-aligned memory address containing 66-byte signature<br />- `COMM`: commitment to calldata computed as<br />`Rpo256(Rpo256(Rpo256(pk) \|\| Rpo256(digest)) \|\| Rpo256(sig))`<br />- `TAG`: `[ECDSA_VERIFY_EVENT, result, 0, 0]`<br />- `result`: 1 if signature is valid, 0 if invalid<br /> |
