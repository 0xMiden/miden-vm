
## std::crypto::fri::frie2f4
| Procedure | Description |
| ----------- | ------------- |
| preprocess | Stores the layer commitments C followed by [d_size, t_depth, a1, a0] and [poe, p, e1, e0] where:<br />1) d_size is the domain size divided by 4 of the domain corresponding to C.<br />2) t_depth is the tree depth of the Merkle tree with commitment C.<br />3) (a0, a1) is the folding challenge to create the next layer.<br />4) p is the query index and (e0, e1) is the evaluation at the first layer and poe is g^p with<br />g being the initial domain generator.<br />TODO: This pre-processing function should in fact compute d_size and t_depth for each C<br />starting from the original domain size.<br /> |
| verify_query_layer | Checks that, for a query with index p at layer i, the folding procedure to create layer (i + 1)<br />was performed correctly. This also advances layer_ptr by 8 to point to the next query layer.<br /><br />Input:  [layer_ptr, layer_ptr, poe, p, e1, e0, layer_ptr, rem_ptr, x, x, x, x, x, x, x, x, ...]<br />Output: [is_not_last_layer, layer_ptr+8, layer_ptr+8, poe^4, f_pos, ne1, ne0, layer_ptr+8, rem_ptr, x, x, x, x, x, x, x, x, ...]<br /><br />Cycles: 83<br /> |
| verify_query_64 | Verifies one FRI query.<br /><br />This procedure is specialized to the case when the remainder polynomial, used in the final check,<br />is expected to have degree at most 64.<br />This procedure is exactly the same as `verify_query_128` except for the remainder polynomial check,<br />thus any change to one procedure will imply an equivalent change to the other one.<br /><br />Input:  [poe, p, e1, e0, layer_ptr, rem_ptr, ...]<br />Output: [x, x, x, x, x, x, x, x, x, x, x, x, ...] (12 "garbage" elements)<br /><br />- poe is g^p.<br />- p is a query index at the first layer.<br />- (e0, e1) is an extension field element corresponding to the value of the first layer at index p.<br />- layer_ptr is the memory address of the layer data (Merkle tree root, alpha etc.) for the next<br />layer.<br />- rem_ptr is the memory address of the remainder polynomial.<br /><br />Cycles: 107 + num_layers * 83<br /> |
| verify_query_128 | Verifies one FRI query.<br /><br />This procedure is specialized to the case when the remainder polynomial, used in the final check,<br />is expected to have degree at most 128.<br />This procedure is exactly the same as `verify_query_64` except for the remainder polynomial check,<br />thus any change to one procedure will imply an equivalent change to the other one.<br /><br />Input:  [poe, p, e1, e0, layer_ptr, rem_ptr, ...]<br />Output: [x, x, x, x, x, x, x, x, x, x, x, x, ...] (12 "garbage" elements)<br /><br />- poe is g^p.<br />- p is a query index at the first layer.<br />- (e0, e1) is an extension field element corresponding to the value of the first layer at index p.<br />- layer_ptr is the memory address of the layer data (Merkle tree root, alpha etc.) for the next<br />layer.<br />- rem_ptr is the memory address of the remainder polynomial.<br /><br />Cycles: 140 + num_layers * 83<br /> |
| verify_64 | Verifies a FRI proof where the proof was generated over the quadratic extension of the base<br />field and layer folding was performed using folding factor 4 when the degree of the remainder<br />polynomial is less than 64.<br />This procedure is exactly the same as `verify_128` except for the remainder polynomial check,<br />thus any change to one procedure will imply an equivalent change to the other one.<br /><br />Input:  [query_ptr, layer_ptr, rem_ptr, g, ...]<br />Output: [...]<br /><br />- query_ptr is a pointer to a list of tuples of the form (e0, e1, p, poe) where poe is equal<br />to g^p with g being the initial FRI domain generator. p is the query index at the first layer<br />and (e0, e1) is an extension field element corresponding to the value of the first layer at index p.<br />- layer_ptr is a pointer to the first layer commitment denoted throughout the code by C.<br />layer_ptr + 1 points to the first [alpha0, alpha1, t_depth, d_size] where d_size is the size<br />of initial domain divided by 4, t_depth is the depth of the Merkle tree commitment to the<br />first layer and (alpha0, alpha1) is the first challenge used in folding the first layer.<br />Both t_depth and d_size are expected to be smaller than 2^32. Otherwise, the result of<br />this procedure is undefined.<br />- rem_ptr is a pointer to the first tuple of two consecutive degree 2 extension field<br />elements making up the remainder polynomial. This procedure is specialized to the case when<br />the the degree of the latter is less than 64.<br /><br />The memory referenced above is used contiguously, as follows:<br /><br />[query_ptr ... layer_ptr ... rem_ptr ...]<br /><br />This means for example that:<br />1. rem_ptr - 1 points to the last (alpha0, alpha1, t_depth, d_size) tuple.<br />2. layer_ptr - 1 points to the last (e0, e1, p, poe) tuple.<br /><br />Cycles: 24 + num_queries * (107 + num_layers * 83)<br /> |
| verify_128 | Verifies a FRI proof where the proof was generated over the quadratic extension of the base<br />field and layer folding was performed using folding factor 4 when the degree of the remainder<br />polynomial is less than 128.<br />This procedure is exactly the same as `verify_64` except for the remainder polynomial check,<br />thus any change to one procedure will imply an equivalent change to the other one.<br /><br />Input:  [query_ptr, layer_ptr, rem_ptr, g, ...]<br />Output: [...]<br /><br />- query_ptr is a pointer to a list of tuples of the form (e0, e1, p, poe) where poe is equal<br />to g^p with g being the initial FRI domain generator. p is the query index at the first layer<br />and (e0, e1) is an extension field element corresponding to the value of the first layer at index p.<br />- layer_ptr is a pointer to the first layer commitment denoted throughout the code by C.<br />layer_ptr + 1 points to the first [alpha0, alpha1, t_depth, d_size] where d_size is the size<br />of initial domain divided by 4, t_depth is the depth of the Merkle tree commitment to the<br />first layer and (alpha0, alpha1) is the first challenge used in folding the first layer.<br />Both t_depth and d_size are expected to be smaller than 2^32. Otherwise, the result of<br />this procedure is undefined.<br />- rem_ptr is a pointer to the first tuple of two consecutive degree 2 extension field<br />elements making up the remainder polynomial. This procedure is specialized to the case when<br />the the degree of the latter is less than 128.<br /><br />The memory referenced above is used contiguously, as follows:<br /><br />[query_ptr ... layer_ptr ... rem_ptr ...]<br /><br />This means for example that:<br />1. rem_ptr - 1 points to the last (alpha0, alpha1, t_depth, d_size) tuple.<br />2. layer_ptr - 1 points to the last (e0, e1, p, poe) tuple.<br /><br />Cycles: 24 + num_queries * (140 + num_layers * 83)<br /> |
| verify | Verifies a FRI proof where the proof was generated over the quadratic extension of the base<br />field and layer folding was performed using folding factor 4.<br /><br />Input:  [...]<br />Output: [...]<br /><br />Cycles:<br /><br />Polynomial degree less than 64: 24 + num_queries * (107 + num_layers * 83)<br />Polynomial degree less than 128: 24 + num_queries * (140 + num_layers * 83)<br /> |
