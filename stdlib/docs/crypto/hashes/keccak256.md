
## std::crypto::hashes::keccak256
| Procedure | Description |
| ----------- | ------------- |
| hash_memory | Computes Keccak256 hash of data stored in memory.<br /><br />Input: [ptr, len_bytes, ...]<br />Output: [DIGEST_U32[8], ...]<br /><br />Where:<br />- ptr: word-aligned memory address containing INPUT_U32[len_u32] where len_u32=⌈len_bytes/4⌉<br />- len_bytes: number of bytes to hash<br />- INPUT_U32[len_u32] ~ INPUT_U8[len_bytes] with u32 packing (unused bytes in final u32 must be 0)<br />- DIGEST_U32[8] = [d_0, ..., d_7] = Keccak256(INPUT_U8[len_bytes])<br /> |
| hash_1to1 | Computes Keccak256 hash of a single 256-bit input.<br /><br />Input: [INPUT_U32[8], ...]<br />Output: [DIGEST_U32[8], ...]<br /><br />Where<br />- DIGEST_U32[8] = [d_0, ..., d_7] = Keccak256(INPUT_U8[32])<br />- INPUT_U32[8] = [i_0, ..., i_7] = [INPUT_LO, INPUT_HI] ~ INPUT_U8[32] with u32 packing<br /> |
| hash_2to1 | Merges two 256-bit digests via Keccak256 hash.<br /><br />Input: [INPUT_L_U32[8], INPUT_R_U32[8], ...]<br />Output: [DIGEST_U32[8], ...]<br /><br />Where<br />- INPUT_L_U32[8] = [l_0, ..., l_7] = [INPUT_L_LO, INPUT_L_HI] ~ INPUT_L_U8[32]<br />- INPUT_R_U32[8] = [r_0, ..., r_7] = [INPUT_R_LO, INPUT_R_HI] ~ INPUT_R_U8[32]<br />- DIGEST_U32[8] = [d_0, ..., d_7] = Keccak256(INPUT_L_U8[32] \|\| INPUT_R_U8[32])<br /> |
| hash_memory_impl | Internal implementation of memory-based Keccak256 computation via deferred computation.<br /><br />Emits an event to populate the advice stack with digest and store the preimage for deferred verification.<br />Returns the commitment to the precompile call and its tag.<br /><br />Input: [ptr, len_bytes, ...]<br />Output: [COMM, TAG, DIGEST_U32[8], ...]<br /><br />Where:<br />- ptr: word-aligned memory address containing INPUT_U32[len_u32] where len_u32=⌈len_bytes/4⌉<br />- len_bytes: number of bytes to hash<br />- COMM: the calldata commitment `Rpo256(Rpo256(INPUT_U32[..]) \|\| Rpo256(DIGEST_U32[..]))` consumed by `log_precompile`<br />- TAG = [KECCAK_HASH_MEMORY_EVENT, len_bytes, 0, 0] encodes the precompile identifier and the byte length as metadata<br />- DIGEST_U32[8] = [d_0, ..., d_7] = Keccak256(INPUT_U8[len_bytes])<br /> |
| to_bit_interleaved | Given two 32 -bit unsigned integers ( standard form ), representing upper and lower<br />bits of a 64 -bit unsigned integer ( actually a keccak-[1600, 24] lane ),<br />this function converts them into bit interleaved representation, where two 32 -bit<br />unsigned integers ( even portion & then odd portion ) hold bits in even and odd<br />indices of 64 -bit unsigned integer ( remember it's represented in terms of<br />two 32 -bit elements )<br /><br />Input stack state :<br /><br />[hi, lo, ...]<br /><br />After application of bit interleaving, stack looks like<br /><br />[even, odd, ...]<br /><br />Read more about bit interleaved representation in section 2.1 of https://keccak.team/files/Keccak-implementation-3.2.pdf<br /><br />See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/utils.hpp#L123-L149<br />for reference implementation in higher level language.<br /> |
| from_bit_interleaved | Given two 32 -bit unsigned integers ( in bit interleaved form ), representing even and odd<br />positioned bits of a 64 -bit unsigned integer ( actually a keccak-[1600, 24] lane ),<br />this function converts them into standard representation, where two 32 -bit<br />unsigned integers hold higher ( 32 -bit ) and lower ( 32 -bit ) bits of standard<br />representation of 64 -bit unsigned integer<br /><br />Input stack state :<br /><br />[even, odd, ...]<br /><br />After application of logic, stack looks like<br /><br />[hi, lo, ...]<br /><br />This function reverts the action done by `to_bit_interleaved` function implemented above.<br /><br />Read more about bit interleaved representation in section 2.1 of https://keccak.team/files/Keccak-implementation-3.2.pdf<br /><br />See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/utils.hpp#L151-L175<br />for reference implementation in higher level language.<br /> |
| hash_deprecated | Given 64 -bytes input, in terms of sixteen 32 -bit unsigned integers, where each pair<br />of them holding higher & lower 32 -bits of 64 -bit unsigned integer ( reinterpreted on<br />host CPU from little endian byte array ) respectively, this function computes 32 -bytes<br />keccak256 digest, held on stack top, represented in terms of eight 32 -bit unsigned integers,<br />where each pair of them keeps higher and lower 32 -bits of 64 -bit unsigned integer respectively<br /><br />Expected stack state :<br /><br />[iword0, iword1, iword2, iword3, iword4, iword5, iword6, iword7,<br />iword8, iword9, iword10, iword11, iword12, iword13, iword14, iword15, ... ]<br /><br />Final stack state :<br /><br />[oword0, oword1, oword2, oword3, oword4, oword5, oword6, oword7, ... ]<br /><br />See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/keccak_256.hpp#L232-L257<br /> |
