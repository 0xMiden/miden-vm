
## std::crypto::hashes::keccak256
| Procedure | Description |
| ----------- | ------------- |
| hash_memory | Computes Keccak256 hash of data stored in memory.<br /><br />Input: [ptr, len_bytes, ...]<br />Output: [KECCAK_LO, KECCAK_HI, ...]<br /><br />Where:<br />- ptr: word-aligned memory address containing len_u32=⌈len_bytes/4⌉ field elements<br />- len_bytes: number of bytes to hash<br />- KECCAK_LO/HI: 256-bit output digest as two 128-bit words (8 field elements).<br />Each word contains 4 32-bit values packing 4 bytes in little-endian order.<br />On the stack we have [W_LO, W_HI] = [[w_3, ..., w_0], [w_7, ..., w_4]].<br /><br />The memory is expected to contain len_u32 values with each element packing 4 bytes in<br />little-endian order. If len_bytes is not divisible by 4, the last word's upper bytes are zero.<br /> |
| hash_1to1 | Computes Keccak256 hash of a single 256-bit input.<br /><br />Input: [INPUT_LO, INPUT_HI, ...]<br />Output: [KECCAK_LO, KECCAK_HI, ...]<br /><br />Computes: Keccak256(INPUT_LO \|\| INPUT_HI)<br /><br />Where:<br />- INPUT_LO/HI and KECCAK_LO/HI are 256-bit values encoded as 2 128-bit words (8 field elements).<br />Each word contains 4 32-bit values packing 4 bytes in little-endian order.<br />On the stack we have [W_LO, W_HI] = [[w_3, ..., w_0], [w_7, ..., w_4]].<br /> |
| hash_2to1 | Merges two 256-bit digests via Keccak256 hash.<br /><br />Input: [INPUT_L_LO, INPUT_L_HI, INPUT_R_LO, INPUT_R_HI, ...]<br />Output: [KECCAK_LO, KECCAK_HI, ...]<br /><br />Computes: Keccak256(INPUT_L_LO \|\| INPUT_L_HI \|\| INPUT_R_LO \|\| INPUT_R_HI) where each chunk is 128 bits<br /><br />Where:<br />- INPUT_L_LO/HI, INPUT_R_LO/HI, and KECCAK_LO/HI are 256-bit values encoded as<br />2 128-bit words (8 field elements).<br />Each word contains 4 32-bit values packing 4 bytes in little-endian order.<br />On the stack we have [W_LO, W_HI] = [[w_3, ..., w_0], [w_7, ..., w_4]].<br /> |
| hash_memory_impl | Internal implementation of memory-based Keccak256 computation via deferred computation.<br /><br />Emits event to populate advice stack with digest, computes commitment for tracking<br />deferred computations, and stores witness in advice map for later proof generation.<br /><br />Input: [ptr, len_bytes, ...]<br />Output: [COMM, KECCAK_LO, KECCAK_HI, ...]<br /><br />Where:<br />- ptr: word-aligned memory address containing ⌈len_bytes/4⌉ field elements<br />- len_bytes: number of bytes to hash<br />- COMM: commitment word = RPO(RPO(input) \|\| RPO(hash)) for kernel tracking<br />- KECCAK_LO/HI: 256-bit digest as two 128-bit words<br />Each word contains 4 32-bit values packing 4 bytes in little-endian order.<br />On the stack we have [W_LO, W_HI] = [[w_3, ..., w_0], [w_7, ..., w_4]].<br /> |
| build_commitment_from_digest | Builds commitment from RPO(input) and advice stack digest.<br /><br />Input: [RPO(input), ...]<br />Output: [COMM, KECCAK_LO, KECCAK_HI, ...]<br /><br />Where COMM = RPO(RPO(input) \|\| RPO(keccak))<br /> |
