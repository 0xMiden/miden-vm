Prepares the top of the stack with the hasher initial state.<br /><br />This procedures does not handle padding, therefore, the user is expected to<br />consume an amount of data which is a multiple of the rate (2 words).<br /><br />Input: []<br />Output: [PERM, PERM, PERM, ...]<br /><br />Cycles: 12<br />


## std::crypto::hashes::rpo
| Procedure | Description |
| ----------- | ------------- |
| squeeze_digest | Given the hasher state, returns the hash output.<br /><br />Input: [C, B, A, ...]<br />Output: [HASH, ...]<br /><br />Where:<br />- `A` is the capacity word that will be used by the hashing function.<br />- `B` is the hash output.<br /><br />Cycles: 9<br /> |
| copy_digest | Copies the result of hash permutation to the top of the stack.<br /><br />It is expected to have the hasher state at the top of the stack at the beginning of the procedure<br />execution.<br /><br />Input: [C, B, A, ...]<br />Output: [B, C, B, A, ...]<br /><br />Where:<br />- `A` is the capacity word that will be used by the hashing function.<br />- `B` is the hash output.<br />- `C` is the rate word that will be used by the hashing function.<br /><br />Cycles: 4<br /> |
| absorb_double_words_from_memory | Hashes the memory `start_addr` to `end_addr` given an RPO state specified by 3 words.<br /><br />This requires that `end_addr = start_addr + 8n` where n = {0, 1, 2 ...}, otherwise the procedure<br />will enter an infinite loop.<br /><br />Input: [C, B, A, start_addr, end_addr, ...]<br />Output: [C', B', A', end_addr, end_addr ...]<br /><br />Where:<br />- `A` is the capacity word that will be used by the hashing function.<br />- `B` is the hash output.<br /><br />Cycles: 4 + 3 * words, where `words` is the `start_addr - end_addr`<br /> |
| hash_memory_double_words | Hashes the pairs of words in the memory from `start_addr` to `end_addr`.<br /><br />This procedure requires that `end_addr = start_addr + 8n` where n = {0, 1, 2 ...} (i.e. we must<br />always hash some number of double words), otherwise the procedure will enter an infinite loop.<br /><br />Input: [start_addr, end_addr, ...]<br />Output: [HASH, ...]<br /><br />Where:<br />- `HASH` is the cumulative hash of the provided memory values.<br /><br />Cycles: 37 + 3 * words, where `words` is the `start_addr - end_addr`<br /> |
| hash_memory_words | Hashes the memory `start_addr` to `end_addr`, handles odd number of elements.<br /><br />Requires `start_addr â‰¤ end_addr`, `end_addr` is not inclusive.<br />Requires `start_addr` and `end_addr` to be word-aligned.<br /><br />Input: [start_addr, end_addr, ...]<br />Output: [H, ...]<br /><br />Cycles:<br />- even words: 53 cycles + 3 * words<br />- odd words: 65 cycles + 3 * words<br />where `words` is the `start_addr - end_addr - 1`<br /> |
| prepare_hasher_state | Initializes the hasher state required for the `hash_memory_with_state` procedure.<br /><br />Depending on the provided pad_inputs_flag, this procedure initializes the hasher state using<br />different values for capacity element:<br />- If pad_inputs_flag = 1 the capacity element is set to 0. This will essentially "pad" the<br />hashed values with zeroes to the next multiple of 8.<br />- If pad_inputs_flag = 0 the capacity element is set to the remainder of the division of<br />number of hashed elements by 8 (num_elements%8).<br /><br />Inputs:  [ptr, num_elements, pad_inputs_flag]<br />Outputs: [C, B, A, ptr, end_pairs_addr, num_elements%8]<br /><br />Where:<br />- ptr is the  memory address of the first element to be hashed. This address must be<br />word-aligned - i.e., divisible by 4.<br />- num_elements is the number of elements to be hashed.<br />- pad_inputs_flag is the flag which indicates whether the values which will be hashed should be<br />padded with zeros to the next multiple of 8.<br />- C, B, A are three words representing the hasher state.<br />- end_pairs_addr is the memory address at which the pairs of words end.<br />- num_elements%8 is the number of elements which didn't fit to the word pairs and should be<br />hashed separately.<br /> |
| hash_memory_with_state | Computes hash of Felt values starting at the specified memory address using the provided hasher<br />state.<br /><br />This procedure divides the hashing process into two parts: hashing pairs of words using<br />`absorb_double_words_from_memory` procedure and hashing the remaining values using the `hperm`<br />instruction.<br /><br />Inputs:  [C, B, A, ptr, end_pairs_addr, num_elements%8]<br />Outputs: [HASH]<br /><br />Where:<br />- ptr is the  memory address of the first element to be hashed. This address must be<br />word-aligned - i.e., divisible by 4.<br />- C, B, A are three words representing the hasher state.<br />- end_pairs_addr is the memory address at which the pairs of words end.<br />- num_elements%8 is the number of elements which didn't fit to the word pairs and should be<br />hashed separately.<br />- HASH is the resulting hash of the provided memory values.<br /> |
| hash_memory | Computes hash of Felt values starting at the specified memory address.<br /><br />This procedure divides the hashing process into two parts: hashing pairs of words using<br />`absorb_double_words_from_memory` procedure and hashing the remaining values using the `hperm`<br />instruction.<br /><br />Inputs:  [ptr, num_elements]<br />Outputs: [HASH]<br /><br />Where:<br />- ptr is the  memory address of the first element to be hashed. This address must be<br />word-aligned - i.e., divisible by 4.<br />- num_elements is the number of elements to be hashed.<br /><br />Cycles:<br />- If number of elements divides by 8: 52 cycles + 3 * words<br />- Else: 185 cycles + 3 * words<br />where `words` is the number of quads of input values.<br /> |
