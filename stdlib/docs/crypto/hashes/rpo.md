
## std::crypto::hashes::rpo
| Procedure | Description |
| ----------- | ------------- |
| init_no_padding | Prepares the top of the stack with the hasher initial state.<br /><br />This procedures does not handle padding, therefore, the user is expected to<br />consume an amount of data which is a multiple of the rate (2 words).<br /><br />Input: []<br />Output: [PERM, PERM, PERM, ...]<br /><br />Cycles: 12<br /> |
| squeeze_digest | Given the hasher state, returns the hash output.<br /><br />Input: [C, B, A, ...]<br />Output: [HASH, ...]<br /><br />Where:<br />- `A` is the capacity word that will be used by the hashing function.<br />- `B` is the hash output.<br /><br />Cycles: 9<br /> |
| copy_digest | Copies the result of hash permutation to the top of the stack.<br /><br />It is expected to have the hasher state at the top of the stack at the beginning of the procedure<br />execution.<br /><br />Input: [C, B, A, ...]<br />Output: [B, C, B, A, ...]<br /><br />Where:<br />- `A` is the capacity word that will be used by the hashing function.<br />- `B` is the hash output.<br />- `C` is the rate word that will be used by the hashing function.<br /><br />Cycles: 4<br /> |
| absorb_double_words_from_memory | Hashes the memory `start_addr` to `end_addr` given an RPO state specified by 3 words.<br /><br />This requires that `end_addr = start_addr + 8n` where n = {0, 1, 2 ...}, otherwise the procedure<br />will enter an infinite loop.<br /><br />Input: [C, B, A, start_addr, end_addr, ...]<br />Output: [C', B', A', end_addr, end_addr ...]<br /><br />Where:<br />- `A` is the capacity word that will be used by the hashing function.<br />- `B` is the hash output.<br /><br />Cycles: 4 + 3 * words, where `words` is the `start_addr - end_addr`<br /> |
| hash_memory_double_words | Hashes the pairs of words in the memory from `start_addr` to `end_addr`.<br /><br />This procedure requires that `end_addr = start_addr + 8n` where n = {0, 1, 2 ...} (i.e. we must<br />always hash some number of double words), otherwise the procedure will enter an infinite loop.<br /><br />Input: [start_addr, end_addr, ...]<br />Output: [HASH, ...]<br /><br />Where:<br />- `HASH` is the cumulative hash of the provided memory values.<br /><br />Cycles: 37 + 3 * words, where `words` is the `start_addr - end_addr`<br /> |
| hash_memory_words | Hashes the memory `start_addr` to `end_addr`, handles odd number of elements.<br /><br />Requires `start_addr â‰¤ end_addr`, `end_addr` is not inclusive.<br />Requires `start_addr` and `end_addr` to be word-aligned.<br /><br />Input: [start_addr, end_addr, ...]<br />Output: [H, ...]<br /><br />Cycles:<br />- even words: 53 cycles + 3 * words<br />- odd words: 65 cycles + 3 * words<br />where `words` is the `start_addr - end_addr - 1`<br /> |
| hash_elements_wo_padding | Computes hash of Felt values starting at the specified memory address.<br /><br />Notice that this procedure does not pad the elements to hash to the next multiple of 8.<br /><br />This procedure divides the hashing process into two parts: hashing pairs of words using<br />`absorb_double_words_from_memory` procedure and hashing the remaining values using the `hperm`<br />instruction.<br /><br />Inputs:  [ptr, num_elements]<br />Outputs: [HASH]<br /><br />Where:<br />- ptr is the  memory address of the first element to be hashed. This address must be<br />word-aligned - i.e., divisible by 4.<br />- num_elements is the number of elements to be hashed.<br />- HASH is the resulting hash of the provided memory values.<br /><br />Cycles:<br />- If number of elements divides by 8: 52 cycles + 3 * words<br />- Else: 185 cycles + 3 * words<br />where `words` is the number of quads of input values.<br /> |
| hash_elements_w_padding | Computes hash of Felt values starting at the specified memory address.<br /><br />Notice that this procedure essentially pads the elements to be hashed to the next multiple of 8<br />by setting the capacity element to 0.<br /><br />This procedure divides the hashing process into two parts: hashing pairs of words using<br />`absorb_double_words_from_memory` procedure and hashing the remaining values using the `hperm`<br />instruction.<br /><br />Inputs:  [ptr, num_elements]<br />Outputs: [HASH]<br /><br />Where:<br />- ptr is the  memory address of the first element to be hashed. This address must be<br />word-aligned - i.e., divisible by 4.<br />- num_elements is the number of elements to be hashed.<br />- HASH is the resulting hash of the provided memory values.<br /><br />Cycles:<br />- If number of elements divides by 8: 52 cycles + 3 * words<br />- Else: 185 cycles + 3 * words<br />where `words` is the number of quads of input values.<br /> |
| hash | Computes RPO hash of a single 256-bit input (1 word = 4 field elements).<br /><br />Input: [A, ...]<br />Output: [B, ...]<br /><br />Where:<br />- A = [a_0, a_1, a_2, a_3] represents 4 field elements (1 word)<br />- B = [b_0, b_1, b_2, b_3] = RPO256(A)<br /> |
| merge | Merges two 256-bit digests (2 words = 8 field elements) via RPO hash.<br /><br />Input: [B, A, ...]<br />Output: [C, ...]<br /><br />Where:<br />- A = [a_0, a_1, a_2, a_3] represents first digest (1 word)<br />- B = [b_0, b_1, b_2, b_3] represents second digest (1 word)<br />- C = [c_0, c_1, c_2, c_3] = RPO256(A \|\| B)<br /> |
| permute | Performs RPO permutation on the hasher state.<br /><br />Input: [C, B, A, ...]<br />Output: [C', B', A', ...]<br /><br />Where:<br />- A, B, C are the three words of the hasher state<br />- A', B', C' are the permuted state words<br /><br />Cycles: 1<br /> |
