
## std::collections::sorted_array
| Procedure | Description |
| ----------- | ------------- |
| find_word | Finds a value in a sorted array of words.<br /><br />This function will crash if the following conditions aren't met:<br />- words must be sorted in non-decreasing order,<br />- start_ptr, end_ptr are word-aligned<br />- `start_ptr <= end_ptr`<br /><br />Input:  [VALUE, start_ptr, end_ptr]<br />Output: [is_value_found, value_ptr, start_ptr, end_ptr]<br /><br />Cycles:<br />Value exists: 46 cycles<br />Value doesn't exist and the array is empty: 25 cycles<br />Value doesn't exist and is smaller than all elements: 151 cycles<br />Value doesn't exist and is larger than all elements: 149 cycles<br />Value doesn't exist: 286 cycles<br /> |
| find_key_value | TODO: Docs.<br /><br />Inputs: [KEY, start_ptr, end_ptr]<br />Output: [is_key_found, key_ptr, start_ptr, end_ptr]<br /> |
| find_half_key_value | TODO: Docs.<br /><br />Inputs: [key_prefix, key_suffix, start_ptr, end_ptr]<br />Output: [is_key_found, key_ptr, start_ptr, end_ptr]<br /> |
| find_key_value_inner | TODO: Update cycle counts.<br />TODO: Avoid local memory.<br /><br />Finds a key in a sorted array of (key, value) word tuples.<br /><br />This function will crash if the following conditions aren't met:<br />- keys must be sorted in non-decreasing order,<br />- start_ptr must be word-aligned<br />- end_ptr must be double-word-aligned with the start_ptr:<br />`(end_ptr - start_ptr)` must be divisible by 8<br />- `start_ptr <= end_ptr`<br /><br />Input:  [KEY, start_ptr, end_ptr, key_size]<br />Output: [is_key_found, key_ptr, start_ptr, end_ptr]<br /><br />Cycles:<br />Key exists: 56 cycles<br />Key doesn't exist and the array is empty: 25 cycles<br />Key doesn't exist and is smaller than all stored keys: 151 cycles<br />Key doesn't exist and is larger than all stored keys: 149 cycles<br />Key doesn't exist: 298 cycles<br /> |
| load_key | Loads the KEY at the pointer from memory and conditionally sets its elements to zero.<br /><br />Given the KEY layout as [key3, key2, key1, key0]:<br /><br />if key_size == 4: return KEY unchanged<br />if key_size <= 3 -> is_key_size_3 or is_key_size_2 or is_key_size_1: set key0 = 0<br />if key_size <= 2 -> is_key_size_2 or is_key_size_1: set key1 = 0<br />if key_size <= 1 -> is_key_size_1: set key2 = 0<br /><br />Inputs:  [key_size, key_ptr]<br />Outputs: [KEY]<br /> |
