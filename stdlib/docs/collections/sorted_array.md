
## std::collections::sorted_array
| Procedure | Description |
| ----------- | ------------- |
| find_word | Finds a value in a sorted array of words.<br /><br />This function will crash if the following conditions aren't met:<br />- words must be sorted in non-decreasing order,<br />- start_ptr, end_ptr are word-aligned<br />- `start_ptr <= end_ptr`<br /><br />Input:  [VALUE, start_ptr, end_ptr]<br />Output: [is_value_found, value_ptr, start_ptr, end_ptr]<br /><br />Cycles:<br />Value exists: 46 cycles<br />Value doesn't exist and the array is empty: 25 cycles<br />Value doesn't exist and is smaller than all elements: 151 cycles<br />Value doesn't exist and is larger than all elements: 149 cycles<br />Value doesn't exist: 286 cycles<br /> |
| find_key_value | TODO: Update docs.<br /><br />Finds a key in a sorted array of (key, value) word tuples.<br /><br />This function will crash if the following conditions aren't met:<br />- keys must be sorted in non-decreasing order,<br />- start_ptr must be word-aligned<br />- end_ptr must be double-word-aligned with the start_ptr:<br />`(end_ptr - start_ptr)` must be divisible by 8<br />- `start_ptr <= end_ptr`<br /><br />Input:  [KEY, start_ptr, end_ptr]<br />Output: [is_key_found, key_ptr, start_ptr, end_ptr]<br /><br />Cycles:<br />Key exists: 56 cycles<br />Key doesn't exist and the array is empty: 25 cycles<br />Key doesn't exist and is smaller than all stored keys: 151 cycles<br />Key doesn't exist and is larger than all stored keys: 149 cycles<br />Key doesn't exist: 298 cycles<br /> |
| find_half_key_value | TODO: Update docs.<br /><br />Finds a key in a sorted array of (key, value) word tuples.<br /><br />The procedure finds the key-value pair where the key's elements at indices 2 and 3 match the<br />provided suffix and prefix, respectively.<br /><br />This function will crash if the following conditions aren't met:<br />- keys must be sorted in non-decreasing order,<br />- start_ptr must be word-aligned<br />- end_ptr must be double-word-aligned with the start_ptr:<br />`(end_ptr - start_ptr)` must be divisible by 8<br />- `start_ptr <= end_ptr`<br /><br />Inputs: [key_prefix, key_suffix, start_ptr, end_ptr]<br />Output: [is_key_found, key_ptr, start_ptr, end_ptr]<br /> |
| find_partial_key_value | TODO: Update cycle counts (how?).<br />TODO: Keep key_size on the stack?<br /><br />Finds a key in a sorted array of (key, value) word tuples.<br /><br />If a match is only required on a part of the KEY, the key_size parameter can be set as follows.<br />Assume a KEY is laid out as [key3, key2, key1, key0].<br /><br />If key_size is 4, then the entry whose key matches the entire KEY is searched for.<br />If key_size is 3, then the entry whose elements key3, key2 and key1 match the corresponding<br />elements in KEY is searched for.<br />If key_size is 2, then the entry whose elements key3 and key2 match the corresponding elements<br />in KEY is searched for.<br />If key_size is 1, then the entry whose element key3 matches the corresponding element in KEY is<br />searched for.<br /><br />If key_size != 4, then the provided KEY *must* already be laid out with the unused key elements set to<br />0.<br /><br />When loading a key from memory, the loaded key's elements that do not need to match are set<br />to 0 in the same way, before comparing the two keys using word::eq.<br /><br />This function will crash if the following conditions aren't met:<br />- keys must be sorted in non-decreasing order,<br />- start_ptr must be word-aligned<br />- end_ptr must be double-word-aligned with the start_ptr:<br />`(end_ptr - start_ptr)` must be divisible by 8<br />- `start_ptr <= end_ptr`<br /><br />Input:  [KEY, start_ptr, end_ptr, key_size]<br />Output: [is_key_found, key_ptr, start_ptr, end_ptr]<br /><br />Cycles:<br />Key exists: 56 cycles<br />Key doesn't exist and the array is empty: 25 cycles<br />Key doesn't exist and is smaller than all stored keys: 151 cycles<br />Key doesn't exist and is larger than all stored keys: 149 cycles<br />Key doesn't exist: 298 cycles<br /> |
| load_key | Loads the KEY at the pointer from memory and conditionally sets its elements to zero.<br /><br />Given the KEY laid out as [key3, key2, key1, key0]:<br /><br />if key_size == 4: return KEY unchanged<br />if key_size <= 3 -> is_key_size_3 or is_key_size_2 or is_key_size_1: set key0 = 0<br />if key_size <= 2 -> is_key_size_2 or is_key_size_1: set key1 = 0<br />if key_size == 1 -> is_key_size_1: set key2 = 0<br /><br />Key sizes outside the range 1..=4 are unsupported.<br /><br />Inputs:  [key_size, key_ptr]<br />Outputs: [KEY]<br /> |
