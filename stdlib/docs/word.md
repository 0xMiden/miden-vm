Reverses order of the first four elements on the stack<br /><br />Inputs:  [a, b, c, d, ...]<br />Outputs: [d, c, b, a, ...]<br /><br />Cycles: 3<br />


## std::word
| Procedure | Description |
| ----------- | ------------- |
| eqz | Returns a boolean indicating whether the input word is [0, 0, 0, 0].<br /><br />Inputs:  [INPUT_WORD]<br />Outputs: [is_empty_word]<br /><br />Where:<br />- INPUT_WORD is the word to compare against [0, 0, 0, 0].<br />- is_empty_word is a boolean indicating whether INPUT_WORD is all zeros.<br /><br />Cycles: 10<br /> |
| testz | Returns a boolean indicating whether the input word is [0, 0, 0, 0]. Unlike eqz, this does not<br />consume the inputs.<br /><br />Inputs:  [INPUT_WORD]<br />Outputs: [is_empty_word, INPUT_WORD]<br /><br />Where:<br />- INPUT_WORD is the word to compare against [0, 0, 0, 0].<br />- is_empty_word is a boolean indicating whether INPUT_WORD is all zeros.<br /><br />Cycles: 11<br /> |
| gt | Returns true if LHS is strictly greater than RHS, false otherwise.<br /><br />This compares words using the same ordering as Merkle tree key comparisons.<br /><br />The implementation avoids branching for performance reasons.<br /><br />For reference, this is equivalent to the following Rust function:<br /><br />fn is_word_greater(word1: Word, word2: Word) -> bool {<br />let mut result = false;<br />let mut cont = true;<br /><br />for i in (0..4).rev() {<br />let gt = word1[i].as_int() > word2[i].as_int();<br />let eq = word1[i].as_int() == word2[i].as_int();<br />result \|= gt & cont;<br />cont &= eq;<br />}<br /><br />result<br />}<br /><br />Inputs:  [RHS, LHS]<br />Outputs: [is_lhs_greater]<br /><br />Cycles: 121<br /> |
| gte | Returns true if LHS is greater than or equal to RHS.<br /><br />Inputs:  [RHS, LHS]<br />Outputs: [is_lhs_greater_or_equal]<br /><br />Cycles: 118<br /> |
| lt | Returns true if LHS is strictly less than RHS, false otherwise.<br /><br />The implementation avoids branching for performance reasons.<br /><br />From an implementation standpoint this is exactly the same as `word::gt` except it uses<br />`lt` rather than `gt`. See its docs for details.<br /><br />Inputs:  [RHS, LHS]<br />Outputs: [is_lhs_lesser]<br /><br />Cycles: 117<br /> |
| lte | Returns true if LHS is less than or equal to RHS, false otherwise.<br /><br />Inputs:  [RHS, LHS]<br />Outputs: [is_lhs_less_or_equal]<br /><br />Cycles: 122<br /> |
| eq | Returns true if LHS is exactly equal to RHS, false otherwise.<br /><br />The implementation does not branch, and always performs the same number of comparisons.<br /><br />This is currently equivalent to the eqw instruction.<br /><br />Inputs:  [RHS, LHS]<br />Outputs: [lhs_eq_rhs]<br /><br />Cycles: 13<br /> |
| test_eq | Returns true if LHS is exactly equal to RHS, false otherwise. Preserves stack inputs.<br /><br />Like word::eq, the implementation does not branch, and always performs the same number<br />of comparisons.<br /><br />Inputs:  [RHS, LHS]<br />Outputs: [lhs_eq_rhs, RHS, LHS]<br /><br />Cycles: 15<br /> |
| arrange_words_adjacent | Arranges the given words such that the corresponding elements are next to each other.<br /><br />Inputs:  [WORD1, WORD2]<br />Outputs: [word2_3, word1_3, word2_2, word1_2, word2_1, word1_1, word2_0, word1_0]<br /><br />Cycles: 8<br /> |
