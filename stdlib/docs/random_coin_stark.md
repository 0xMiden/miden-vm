
## std::crypto::stark::random_coin
| Procedure | Description |
| ----------- | ------------- |
| get_rate_1 | Return the first half of the rate portion of the random coin state<br /><br />Input: [...]<br /><br />Output: [R1] |
| init_seed | Initializes the seed for randomness generation by computing the hash of the proof context using<br /><br />the trace length, number of queries, logarithm of blowup factor and the number of bits of<br /><br />grinding. Currently, this part, as well as the rest of the STARK verifier has the blowup factor<br /><br />fixed to 8, number of queries to 27.<br /><br />The ouput of this procedure is the capacity portion of the state after applying `hperm`.<br /><br />Input: [log(trace_length), num_queries, blowup, grinding, ...]<br /><br />Output: [C]<br /><br />Cycles: 104 |
| reseed | Reseed the random coin with `DATA`<br /><br />Input: [DATA, ...]<br /><br />Ouput: [...]<br /><br />Cycles: 54 |
| generate_aux_randomness | Draw a list of random extension field elements related to the auxiliary trace and store the list<br /><br />in memory from `aux_rand_elem_ptr` to `aux_rand_elem_ptr + 8 - 1`<br /><br />Input: [aux_rand_elem_ptr, ...]<br /><br />Output: [...]<br /><br />Cycles: 150 |
| generate_constraint_composition_coefficients | Draw constraint composition random coefficients and save them into memory in the region from<br /><br />`compos_coef_ptr` `compos_coef_ptr + 118 - 1` as `(r1_1, r1_0, r0_1, r0_0)`<br /><br />Input: [compos_coef_ptr, ...]<br /><br />Output: [...]<br /><br />Cycles: 1309 |
| generate_deep_composition_random_coefficients | Draw deep composition polynomial random coefficients and save them into memory in the region from<br /><br />`deep_rand_coef_ptr` `deep_rand_coef_ptr + 90 - 1` as `(0, 0, r0_1, r0_0)`<br /><br />The number of equal coefficients is equal to:<br /><br />(73 + 9) * 2 Felt for the trace.<br /><br />8 * 2 Felt for constraint polynomial.<br /><br />Total: 90 tuples of type (Felt, Felt)<br /><br />Input: [deep_rand_coef_ptr, ...]<br /><br />Output: [...]<br /><br />Cycles: 1693 |
| generate_z_zN | Generate the OOD challenge point `z = (z0, z1)` and compute `z^N` where N is the trace length.<br /><br />The resulting word `[z^N_1, z^N_0, z1, z0]` is stored in the global memory address reserved<br /><br />for it.<br /><br />Input: [...]<br /><br />Output: [...]<br /><br />Cycles: 21 + 10 * log(N) |
| generate_list_indices | Generate a list of random indices in the range [0, lde_size] and store it in memory starting<br /><br />from `query_ptr`. The list is stored as `(r, depth, y, y)` where `depth` is<br /><br />`log(lde_domain_size)`. `depth` is needed when computing the deep queries.<br /><br />TODO: the case of duplicate queries<br /><br />TODO: generalize to any number of queries<br /><br />Input: [query_ptr, ...]<br /><br />Output: [...]<br /><br />Cycles: 797 |
| check_pow | Check that the Proof-of-Work contained in the nonce is equal to the required number<br /><br />of bits prescribed by grinding bits. The grinding factor is assumed to be less than 32.<br /><br />Input: [grinding_factor, ...]<br /><br />Output: [...]<br /><br />Cycles: 73 |
