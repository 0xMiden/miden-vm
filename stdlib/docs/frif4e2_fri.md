
## std::crypto::fri::frif4e2
| Procedure | Description |
| ----------- | ------------- |
| preprocess | Stores the layer commitments C followed by [d_size, t_depth, a1, a0] and [0, p, e1, e0] where:<br /><br />1) d_size is the domain size divided by 4 of the domain corresponding to C.<br /><br />2) t_depth is the tree depth of the Merkle tree with commitment C.<br /><br />3) (a0, a1) is the folding challenge to create the next layer.<br /><br />4) p is the query index and (e0, e1) is the evaluation at the first layer.<br /><br />TODO: This processing function should in fact compute d_size and t_depth for each C<br /><br />starting from the original domain size. |
| verify_remainder_query | This functions checks that the last folded codeword is agrees at index p with the remainder<br /><br />codeword sent by the prover.<br /><br />Input: [ptr_rem_start, ptr_rem_start, poe^2^n, f_pos, ne1, ne0, ptr_rem_start, ptr_rem_start, x, x, x, x, x, x, x, x, ..]<br /><br />Output: [ptr_rem_start, ptr_rem_start, x, x, x, x, x, x, x, x, ..]<br /><br />Cost: 20 cycles |
| verify_query_layer | Checks that, for a query with index p at layer i, the folding procedure to create layer (i + 1)<br /><br />was performed correctly.<br /><br />Input: [ptr0 + 2 * i, ptr0 + 2 * i, poe, p, e1, e0, ptr0 + 2 * i, ptr_rem_start, x, x, x, x, x, x, x, x, ...]<br /><br />Output: [ptr0 + 2 * (i + 1), ptr0 + 2 * (i + 1), poe^4, f_pos, ne1, ne0, ptr0 + 2 * (i + 1), ptr_rem_start, x, x, x, x, x, x, x, x, ...]<br /><br />Cost: 83 |
| verify_query | Verifies one FRI query.<br /><br />Input: [poe, p, e1, e0, ptr0, ptr_rem_start, ..]<br /><br />Output: ()<br /><br />Cost: 37 + num_layers * 105 |
| verify | Verifies a FRI proof<br /><br />Expects a stack in the following configuration [ptr_query_start, ptr_query_end, ptr0, ptr_rem_start, g] where:<br /><br />1) ptr0 is a pointer to the first layer commitment denoted throughout the code by C. ptr0 + 1<br /><br />points to the first [d_size, t_depth, alpha1, alpha0] where d_size is the size of initial domain<br /><br />divided by 4, t_depth is the depth of the Merkle tree commiment to the first layer and (alpha1, alpha0)<br /><br />is the first challenge used in folding the first layer.<br /><br />2) ptr_rem_start is a pointer to the first tuple of two consecutive degree 2 extension field elements<br /><br />making up the remainder codeword. This codeword can be of length either 32 or 64.<br /><br />3) ptr_queries_start is a pointer to a list of tuples of the form (0, p, e1, e0) where p is a query<br /><br />index at the first layer and (e0, e1) is an extension field elements corresponding to the value<br /><br />of the first layer at index p.<br /><br />4) ptr_queries_end is a pointer to the first empty memory address after the last (0, p, e1, e0) tuple.<br /><br />The memory referenced above is used contiguously. This means for example that:<br /><br />1)  ptr_rem_start - 1 points to the last (d_size, t_depth, alpha1, alpha0) tuple.<br /><br />2) The length of the remainder codeword is 2 * (ptr_rem_start - ptr_queries_start).<br /><br />Input: [ptr_query_start, ptr_query_end, ptr0, ptr_rem_start, g]<br /><br />Output: ()<br /><br />Cost: 2626 + 8 + num_queries * (37 + num_layers * 105 + 58) |
