
## std::math::poly512
| Procedure | Description |
| ----------- | ------------- |
| mul_zq.128 |  Given two polynomials of degree 512 on stack as absolute memory addresses,<br /> this routine computes polynomial multiplication, using NTT and iNTT.<br /><br /> Imagine, two polynomials are f, g<br /><br /> h = f . g, can be computed using<br /><br /> iNTT(NTT(f) * NTT(g))<br /><br /> Note, * -> element wise multiplication of polynomial coefficients in NTT domain<br /><br /> Input stack state :<br /><br /> [f_start_addr, g_start_addr, ...]<br /><br /> - {f, g}_addr`i` -> {f, g}[ (i << 2) .. ((i+1) << 2) ), address holding four consecutive coefficients<br /> - {f, g}_addr0 -> {f, g}_start_addr<br /><br /> Output stack state :<br /><br /> [h_start_addr, ...]<br /><br /> - h_addr`i` is the address of four elements \| h[ (i << 2) .. ((i+1) << 2) ) & i ∈ [0..128)<br /><br /> Consecutive 127 memory addresses can be computed from starting memory address ( living on stack top ) by <br /> continuing to apply `INCR` ( = add.1 ) instruction on previous absolute memory address.<br /><br /> Note, input memory addresses are considered to be read-only, they are not mutated. |
| add_zq.128 |  Given two polynomials of degree 512 on stack as absolute memory addresses,<br /> this routine computes polynomial addition.<br /><br /> Imagine, two polynomials f, g<br /><br /> h = f + g, can be computed as<br /><br /> [(f[i] + g[i]) % Q for i in range(512)] \| Q = 12289 ( = Falcon Digital Signature Algorithm's Prime Number )<br /><br /> Input stack state :<br /><br /> [f_start_addr, g_start_addr, ...]<br /><br /> - {f, g}_addr`i` -> {f, g}[ (i << 2) .. ((i+1) << 2) ), address holding four consecutive coefficients<br /> - {f, g}_addr0 -> {f, g}_start_addr<br /><br /> Output stack state :<br /><br /> [h_start_addr, ...]<br /><br /> - h_addr`i` is the address of four elements \| h[ (i << 2) .. ((i+1) << 2) ) & i ∈ [0..128)<br /><br /> Consecutive 127 memory addresses can be computed from starting memory address ( living on stack top ) by <br /> continuing to apply `INCR` ( = add.1 ) instruction on previous absolute memory address.<br /><br /> Note, input memory addresses are considered to be read-only, they are not mutated. |
| neg_zq.128 |  Given one polynomial of degree 512 on stack as absolute memory addresses,<br /> this routine negates each coefficient of that polynomial.<br /><br /> Imagine, polynomial f<br /><br /> g = -f, can be computed as<br /><br /> [(-f[i]) % Q for i in range(512)] \| Q = 12289 ( = Falcon Digital Signature Algorithm's Prime Number )<br /><br /> Input stack state :<br /><br /> [f_addr0, f_addr1, ..., f_addr127]<br /><br /> f_addr`i` -> f[ (i << 2) .. ((i+1) << 2) ), address holding four consecutive coefficients<br /><br /> Output stack state :<br /><br /> [g_addr0, g_addr1, ..., g_addr127]<br /><br /> g_addr`i` is the address of four elements \| g[ (i << 2) .. ((i+1) << 2) ) & i ∈ [0..128)<br /><br /> Note, input memory addresses are considered to be read-only, they are not mutated. |
| sub_zq.256 |  Given two polynomials of degree 512 on stack as absolute memory addresses,<br /> this routine subtracts second polynomial from first one.<br /><br /> Imagine, two polynomials f, g<br /><br /> h = f - g, can be computed as<br /><br /> [(f[i] - g[i]) % Q for i in range(512)] \| Q = 12289 ( = Falcon Digital Signature Algorithm's Prime Number )<br /><br /> Input stack state :<br /><br /> [f_addr0, f_addr1, ..., f_addr127, g_addr0, g_addr1, ..., g_addr127]<br /><br /> {f, g}_addr`i` -> {f, g}[ (i << 2) .. ((i+1) << 2) ), address holding four consecutive coefficients<br /><br /> Output stack state :<br /><br /> [h_addr0, h_addr1, ..., h_addr127]<br /><br /> h_addr`i` is the address of four elements \| h[ (i << 2) .. ((i+1) << 2) ) & i ∈ [0..128)<br /><br /> Note, input memory addresses are considered to be read-only, they are not mutated. |
