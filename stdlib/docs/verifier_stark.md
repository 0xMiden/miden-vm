
## std::crypto::stark::verifier
| Procedure | Description |
| ----------- | ------------- |
| verify | Verify a STARK proof attesting to the correct execution of a program in the Miden VM.<br /><br />The following simplifying assumptions are currently made:<br /><br />- The blowup is set to 8, the grinding to 16bits and number of FRI queries to 27.<br /><br />- The maximal allowed degree of the remainder polynomial is 7.<br /><br />- Only the input and output stacks, assumed of fixed size equal to 16, are handled in regards<br /><br />to public inputs.<br /><br />- There are two trace segments, main and auxiliary. It is assumed that the main trace segment<br /><br />is 73 columns wide while the auxiliary trace segment is 9 columns wide.<br /><br />- The OOD evaluation frame is composed of two interleaved rows, current and next, each composed<br /><br />of 73 elements representing the main trace portion and 9 elements for the auxiliary trace one.<br /><br />- To boost soundness, the protocol is run on a quadratic extension field and this means that<br /><br />the OOD evaluation frame is composed of elements in a quadratic extension field i.e. tuples.<br /><br />Similarly, elements of the auxiliary trace are quadratic extension field elements.<br /><br />- The following procedure makes use of global memory address beyond 3 * 2^30. More precisely,<br /><br />the following is a list of pointers used by `stark::verify`:<br /><br />* ZERO_ZERO_ZERO_ONE_PTR. [0, 0, 0, 1] used for hmerge in case the number of elements to be hashed is not divisible by 8<br /><br />* ZERO_WORD_PTR. [0, 0, 0, 0] used for hmerge in case the number of elements to be hashed is divisible by 8<br /><br />* LDE_SIZE_PTR. [lde_size, log2(lde_size), 0, 0]<br /><br />* Z_PTR. [zN_1, zN_0, z1, z0] where z = (z_0, z_1) is the OOD random element and ZN is z to the power trace length<br /><br />* MAIN_TRACE_COM_PTR. Main trace commitment<br /><br />* AUX_TRACE_COM_PTR. Aux trace commitment<br /><br />* COMPOSITION_POLY_COM_PTR. Constraint polynomial columns trace commitment<br /><br />* PUBLIC_INPUTS_PTR. Points to the memory region containing the public inputs.<br /><br />* AUX_RAND_ELEM_PTR.    Auxiliary trace random coefficients<br /><br />* COMPOSITION_COEF_PTR.    Constraint composition coefficients<br /><br />* OOD_TRACE_PTR.    The OOD evaluation frame with current and next rows interleaved<br /><br />* OOD_CONSTRAINT_EVALS_PTR.    value_i for i in 0..=7 where H(z) := \sum_0^7 value_i * z^(N*i) and H is the constraint compostion polynomial<br /><br />* DEEP_RAND_CC_PTR.    Deep query coefficients<br /><br />* FRI_QUERIES_PTR.    [poe, query_index, evaluation_1, evaluation_0] for the 27 FRI queries where poe = lde_domain_generator^query_index<br /><br />* PARAMETERS_PTR.   [log(trace_length), num_queries, log(blowup), grinding]<br /><br />* TMP1.   [gz1, gz0, z1, z0]<br /><br />* TMP2.   [x, _, _, _] where x := offset * lde_domain_generator^query_index<br /><br />* TMP3.   Leaf value at index `query_index` of the commitment tree to either main, auxiliary or constraint traces.<br /><br />* TMP4.   [query_index, depth, _, _] where query_index is the current deep FRI query being computed.<br /><br />* TMP5.   [lde_size, log2(lde_size), lde_domain_generator, 0]<br /><br />* TMP6.   [num_fri_layers, remainder_size, lde_size, lde_domain_generator]<br /><br />* TMP7.   Remainder commitment<br /><br />* TMP8.   [remainder_ptr, remainder_size, lde_size, lde_size]<br /><br />Input: [log(trace_length), num_queries, log(blowup), grinding]<br /><br />Output: []<br /><br />Cycles:<br /><br />1- Remainder codeword size 32:<br /><br />5000 + num_queries * (40 + num_fri_layers * 76 + 26 + 465) + 83 * num_fri_layers + 10 * log(trace_length) + 1498<br /><br />2- Remainder codeword size 64:<br /><br />5000 + num_queries * (40 + num_fri_layers * 76 + 26 + 465) + 83 * num_fri_layers + 10 * log(trace_length) + 2792 |
