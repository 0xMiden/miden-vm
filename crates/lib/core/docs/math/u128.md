
## miden::core::math::u128
| Procedure | Description |
| ----------- | ------------- |
| overflowing_add | Performs addition of two unsigned 128 bit integers preserving the overflow.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition is as follows:<br />[b0, b1, b2, b3, a0, a1, a2, a3, ...] -> [overflow, c0, c1, c2, c3, ...], where c = (a + b) % 2^128<br /> |
| widening_add | Performs addition of two unsigned 128 bit integers preserving the overflow with sum on top.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition is as follows:<br />[b0, b1, b2, b3, a0, a1, a2, a3, ...] -> [c0, c1, c2, c3, overflow, ...], where c = (a + b) % 2^128<br /> |
| wrapping_add | Performs addition of two unsigned 128 bit integers discarding the overflow.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition is as follows:<br />[b0, b1, b2, b3, a0, a1, a2, a3, ...] -> [c0, c1, c2, c3, ...], where c = (a + b) % 2^128<br /> |
| overflowing_sub | Performs subtraction of two unsigned 128 bit integers preserving the underflow.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition is as follows:<br />[b0, b1, b2, b3, a0, a1, a2, a3, ...] -> [underflow, c0, c1, c2, c3, ...], where c = (a - b) % 2^128<br /> |
| wrapping_sub | Performs subtraction of two unsigned 128 bit integers discarding the underflow.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition is as follows:<br />[b0, b1, b2, b3, a0, a1, a2, a3, ...] -> [c0, c1, c2, c3, ...], where c = (a - b) % 2^128<br /> |
| overflowing_mul | Performs multiplication of two unsigned 128 bit integers preserving the overflow.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition is as follows:<br />[b0, b1, b2, b3, a0, a1, a2, a3, ...] -> [overflow, c0, c1, c2, c3, ...], where c = (a * b) % 2^128<br /><br />Schoolbook multiplication (LE layout with low limbs on top):<br /><br />a0    a1    a2    a3<br />x b0    b1    b2    b3<br />-------------------------------------------<br />(position)     0       1       2       3       4       5       6<br /><br />Partial products contributing to each position:<br />c0 (pos 0): a0*b0<br />c1 (pos 1): a1*b0 + a0*b1 + carries from pos 0<br />c2 (pos 2): a2*b0 + a1*b1 + a0*b2 + carries from pos 1<br />c3 (pos 3): a3*b0 + a2*b1 + a1*b2 + a0*b3 + carries from pos 2<br />overflow (pos 4+): a3*b1 + a2*b2 + a1*b3 + carries from pos 3<br />+ a3*b2 + a2*b3 (pos 5)<br />+ a3*b3 (pos 6)<br /><br /> |
| widening_mul | Performs multiplication of two unsigned 128 bit integers preserving the overflow with sum on top.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition is as follows:<br />[b0, b1, b2, b3, a0, a1, a2, a3, ...] -> [c0, c1, c2, c3, overflow, ...], where c = (a * b) % 2^128<br /> |
| wrapping_mul | Performs multiplication of two unsigned 128 bit integers discarding the overflow.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition is as follows:<br />[b0, b1, b2, b3, a0, a1, a2, a3, ...] -> [c0, c1, c2, c3, ...], where c = (a * b) % 2^128<br /><br />Uses schoolbook multiplication with u32wrapping_madd for products contributing to c3<br />since overflow there doesn't affect the result.<br /> |
| eq | Performs equality comparison of two unsigned 128 bit integers.<br />Stack transition: [b0, b1, b2, b3, a0, a1, a2, a3, ...] -> [c, ...], where c = 1 when a == b, and 0 otherwise.<br /> |
| neq | Performs inequality comparison of two unsigned 128 bit integers.<br />Stack transition: [b0, b1, b2, b3, a0, a1, a2, a3, ...] -> [c, ...], where c = 1 when a != b, and 0 otherwise.<br /> |
| eqz | Performs comparison to zero of an unsigned 128 bit integer.<br />Stack transition: [a0, a1, a2, a3, ...] -> [c, ...], where c = 1 when a == 0, and 0 otherwise.<br /> |
| lt | Performs less-than comparison of two unsigned 128 bit integers.<br />Stack transition: [b0, b1, b2, b3, a0, a1, a2, a3, ...] -> [c, ...], where c = 1 when a < b, and 0 otherwise.<br /> |
| lte | Performs less-than-or-equal comparison of two unsigned 128 bit integers.<br />Stack transition: [b0, b1, b2, b3, a0, a1, a2, a3, ...] -> [c, ...], where c = 1 when a <= b, and 0 otherwise.<br /> |
| gt | Performs greater-than comparison of two unsigned 128 bit integers.<br />Stack transition: [b0, b1, b2, b3, a0, a1, a2, a3, ...] -> [c, ...], where c = 1 when a > b, and 0 otherwise.<br /> |
| gte | Performs greater-than-or-equal comparison of two unsigned 128 bit integers.<br />Stack transition: [b0, b1, b2, b3, a0, a1, a2, a3, ...] -> [c, ...], where c = 1 when a >= b, and 0 otherwise.<br /> |
| min | Compares two unsigned 128 bit integers and drops the larger one from the stack.<br />Stack transition: [b0, b1, b2, b3, a0, a1, a2, a3, ...] -> [c0, c1, c2, c3, ...], where c = min(a, b).<br /> |
| max | Compares two unsigned 128 bit integers and drops the smaller one from the stack.<br />Stack transition: [b0, b1, b2, b3, a0, a1, a2, a3, ...] -> [c0, c1, c2, c3, ...], where c = max(a, b).<br /> |
| and | Performs bitwise AND of two unsigned 128-bit integers.<br />Stack transition: [b0, b1, b2, b3, a0, a1, a2, a3, ...] -> [c0, c1, c2, c3, ...], where c = a AND b.<br /> |
| or | Performs bitwise OR of two unsigned 128-bit integers.<br />Stack transition: [b0, b1, b2, b3, a0, a1, a2, a3, ...] -> [c0, c1, c2, c3, ...], where c = a OR b.<br /> |
| xor | Performs bitwise XOR of two unsigned 128-bit integers.<br />Stack transition: [b0, b1, b2, b3, a0, a1, a2, a3, ...] -> [c0, c1, c2, c3, ...], where c = a XOR b.<br /> |
| clz | Counts the number of leading zeros of one unsigned 128-bit integer.<br />Stack transition: [a0, a1, a2, a3, ...] -> [clz, ...], where clz is the number of leading zeros of value a.<br /> |
| ctz | Counts the number of trailing zeros of one unsigned 128-bit integer.<br />Stack transition: [a0, a1, a2, a3, ...] -> [ctz, ...], where ctz is the number of trailing zeros of value a.<br /> |
| clo | Counts the number of leading ones of one unsigned 128-bit integer.<br />Stack transition: [a0, a1, a2, a3, ...] -> [clo, ...], where clo is the number of leading ones of value a.<br /> |
| cto | Counts the number of trailing ones of one unsigned 128-bit integer.<br />Stack transition: [a0, a1, a2, a3, ...] -> [cto, ...], where cto is the number of trailing ones of value a.<br /> |
| shl | Performs left shift of one unsigned 128-bit integer.<br />Stack transition: [n, a0, a1, a2, a3, ...] -> [c0, c1, c2, c3, ...], where c = (a << n) mod 2^128.<br />The shift value n should be in the range [0, 128).<br /> |
| shr | Performs right shift of one unsigned 128-bit integer.<br />Stack transition: [n, a0, a1, a2, a3, ...] -> [c0, c1, c2, c3, ...], where c = a >> n.<br />The shift value n should be in the range [0, 128).<br /> |
| rotl | Performs left rotation of one unsigned 128-bit integer.<br />Stack transition: [n, a0, a1, a2, a3, ...] -> [c0, c1, c2, c3, ...], where c = a <<< n (rotate left).<br />The rotation amount n should be in the range [0, 128).<br /> |
| rotr | Performs right rotation of one unsigned 128-bit integer.<br />Stack transition: [n, a0, a1, a2, a3, ...] -> [c0, c1, c2, c3, ...], where c = a >>> n (rotate right).<br />The rotation amount n should be in the range [0, 128).<br /> |
