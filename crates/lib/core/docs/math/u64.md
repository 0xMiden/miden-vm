
## miden::core::math::u64
| Procedure | Description |
| ----------- | ------------- |
| u32split_be | Splits a field element into two 32-bit limbs with big-endian order (high bits on top).<br />This is a compatibility wrapper for code expecting the legacy u32split behavior.<br />Stack transition: [a, ...] -> [a_hi, a_lo, ...], where a = a_hi * 2^32 + a_lo<br />This takes 2 cycles.<br /> |
| overflowing_add_le | Performs addition of two unsigned 64 bit integers preserving the overflow using little-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [overflow, c_lo, c_hi, ...], where c = (a + b) % 2^64<br />This takes 7 cycles.<br /> |
| overflowing_add_be | Performs addition of two unsigned 64 bit integers preserving the overflow using big-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [overflow, c_hi, c_lo, ...], where c = (a + b) % 2^64<br />This takes 11 cycles.<br /> |
| wrapping_add_le | Performs addition of two unsigned 64 bit integers discarding the overflow using little-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [c_lo, c_hi, ...], where c = (a + b) % 2^64<br />This takes 8 cycles.<br /> |
| wrapping_add_be | Performs addition of two unsigned 64 bit integers discarding the overflow using big-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = (a + b) % 2^64<br />This takes 10 cycles.<br /> |
| wrapping_sub_le | Performs subtraction of two unsigned 64 bit integers discarding the overflow using little-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [c_lo, c_hi, ...], where c = (a - b) % 2^64<br />This takes 9 cycles.<br /> |
| wrapping_sub_be | Performs subtraction of two unsigned 64 bit integers discarding the overflow using big-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = (a - b) % 2^64<br />This takes 13 cycles.<br /> |
| overflowing_sub_le | Performs subtraction of two unsigned 64 bit integers preserving the overflow using little-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [underflow, c_lo, c_hi, ...], where c = (a - b) % 2^64<br />This takes 13 cycles.<br /> |
| overflowing_sub_be | Performs subtraction of two unsigned 64 bit integers preserving the overflow using big-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [underflow, c_hi, c_lo, ...], where c = (a - b) % 2^64<br />This takes 19 cycles.<br /> |
| wrapping_mul_le | Performs multiplication of two unsigned 64 bit integers discarding the overflow.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [c_lo, c_hi, ...], where c = (a * b) % 2^64<br />This takes 15 cycles.<br /> |
| wrapping_mul_be | Performs multiplication of two unsigned 64 bit integers discarding the overflow (big-endian).<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = (a * b) % 2^64<br />This takes 17 cycles.<br /> |
| overflowing_mul_be | Performs multiplication of two unsigned 64 bit integers preserving the overflow (big-endian).<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_mid_hi, c_mid_lo, c_lo, ...], where<br />c = a * b is represented as a 128-bit value split into 4 32-bit limbs.<br />This takes 18 cycles.<br /> |
| overflowing_mul_le | Performs multiplication of two unsigned 64 bit integers preserving the overflow.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [c_lo, c_mid_lo, c_mid_hi, c_hi, ...], where<br />c = a * b is represented as a 128-bit value split into 4 32-bit limbs.<br />This takes 20 cycles.<br /> |
| lt_le | Performs less-than comparison of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [c, ...], where c = 1 when a < b, and 0 otherwise.<br />This takes 10 cycles.<br /> |
| lt_be | Less-than comparison using big-endian limbs.<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a < b, and 0 otherwise.<br />This takes 12 cycles.<br /> |
| gt_le | Performs greater-than comparison of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [c, ...], where c = 1 when a > b, and 0 otherwise.<br />This takes 11 cycles.<br /> |
| gt_be | Greater-than comparison using big-endian limbs.<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a > b, and 0 otherwise.<br />This takes 12 cycles.<br /> |
| lte_le | Performs less-than-or-equal comparison of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [c, ...], where c = 1 when a <= b, and 0 otherwise.<br />This takes 12 cycles.<br /> |
| lte_be | Less-than-or-equal comparison using big-endian limbs.<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a <= b, and 0 otherwise.<br />This takes 12 cycles.<br /> |
| gte_le | Performs greater-than-or-equal comparison of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [c, ...], where c = 1 when a >= b, and 0 otherwise.<br />This takes 12 cycles.<br /> |
| gte_be | Greater-than-or-equal comparison using big-endian limbs.<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a >= b, and 0 otherwise.<br />This takes 13 cycles.<br /> |
| eq_le | Performs equality comparison of two unsigned 64 bit integers using little-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [c, ...], where c = 1 when a == b, and 0 otherwise.<br />This takes 5 cycles.<br /> |
| eq_be | Performs equality comparison of two unsigned 64 bit integers using big-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a == b, and 0 otherwise.<br />This takes 5 cycles.<br /> |
| neq_le | Performs inequality comparison of two unsigned 64 bit integers using little-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [c, ...], where c = 1 when a != b, and 0 otherwise.<br />This takes 5 cycles.<br /> |
| neq_be | Performs inequality comparison of two unsigned 64 bit integers using big-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a != b, and 0 otherwise.<br />This takes 5 cycles.<br /> |
| eqz_le | Performs comparison to zero of an unsigned 64 bit integer using little-endian limbs.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, ...] -> [c, ...], where c = 1 when a == 0, and 0 otherwise.<br />This takes 4 cycles.<br /> |
| eqz_be | Performs comparison to zero of an unsigned 64 bit integer using big-endian limbs.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_hi, a_lo, ...] -> [c, ...], where c = 1 when a == 0, and 0 otherwise.<br />This takes 4 cycles.<br /> |
| min_be | Compares two unsigned 64 bit integers and drops the larger one from the stack using big-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = min(a, b).<br />This takes 22 cycles.<br /> |
| min_le | Compares two unsigned 64 bit integers and drops the larger one from the stack using little-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [c_lo, c_hi, ...], where c = min(a, b).<br />This takes 25 cycles.<br /> |
| max_be | Compares two unsigned 64 bit integers and drops the smaller one from the stack using big-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = max(a, b).<br />This takes 23 cycles.<br /> |
| max_le | Compares two unsigned 64 bit integers and drops the smaller one from the stack using little-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [c_lo, c_hi, ...], where c = max(a, b).<br />This takes 26 cycles.<br /> |
| div | Performs division of two unsigned 64 bit integers discarding the remainder using little-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [c_lo, c_hi, ...], where c = a // b<br />This takes 54 cycles.<br /> |
| div_be | Performs division of two unsigned 64 bit integers discarding the remainder using big-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a // b<br />This takes 56 cycles.<br /> |
| mod | Performs modulo operation of two unsigned 64 bit integers using little-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [c_lo, c_hi, ...], where c = a % b<br />This takes 54 cycles.<br /> |
| mod_be | Performs modulo operation of two unsigned 64 bit integers using big-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a % b<br />This takes 56 cycles.<br /> |
| divmod | Performs divmod operation of two unsigned 64 bit integers using little-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [q_lo, q_hi, r_lo, r_hi, ...], where q = a / b, r = a % b.<br />This takes 54 cycles.<br /> |
| divmod_be | Performs divmod operation of two unsigned 64 bit integers using big-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [r_hi, r_lo, q_hi, q_lo ...], where r = a % b, q = a / b<br />This takes 58 cycles.<br /> |
| and_le | Performs bitwise AND of two unsigned 64-bit integers using little-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [c_lo, c_hi, ...], where c = a AND b.<br />This takes 5 cycles.<br /> |
| and_be | Performs bitwise AND of two unsigned 64-bit integers using big-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a AND b.<br />This takes 7 cycles.<br /> |
| or_le | Performs bitwise OR of two unsigned 64 bit integers using little-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [c_lo, c_hi, ...], where c = a OR b.<br />This takes 5 cycles.<br /> |
| or_be | Performs bitwise OR of two unsigned 64 bit integers using big-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a OR b.<br />This takes 7 cycles.<br /> |
| xor_le | Performs bitwise XOR of two unsigned 64 bit integers using little-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_lo, a_hi, b_lo, b_hi, ...] -> [c_lo, c_hi, ...], where c = a XOR b.<br />This takes 5 cycles.<br /> |
| xor_be | Performs bitwise XOR of two unsigned 64 bit integers using big-endian limbs.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a XOR b.<br />This takes 7 cycles.<br /> |
| shl | Performs left shift of one unsigned 64-bit integer using little-endian limbs.<br />The input value to be shifted is assumed to be represented using 32 bit limbs, but this is not checked.<br />The shift value n should be in the range [0, 64), otherwise it will result in an error.<br />Stack transition looks as follows:<br />[n, a_lo, a_hi, ...] -> [c_lo, c_hi, ...], where c = (a << n) mod 2^64.<br />This takes 21 cycles.<br /> |
| shl_be | Performs left shift of one unsigned 64-bit integer using big-endian limbs.<br />The input value to be shifted is assumed to be represented using 32 bit limbs, but this is not checked.<br />The shift value n should be in the range [0, 64), otherwise it will result in an error.<br />Stack transition looks as follows:<br />[n, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = (a << n) mod 2^64.<br />This takes 24 cycles.<br /> |
| shr | Performs right shift of one unsigned 64-bit integer using little-endian limbs.<br />The input value to be shifted is assumed to be represented using 32 bit limbs, but this is not checked.<br />The shift value n should be in the range [0, 64), otherwise it will result in an error.<br />Stack transition looks as follows:<br />[n, a_lo, a_hi, ...] -> [c_lo, c_hi, ...], where c = a >> n.<br />This takes 44 cycles.<br /> |
| shr_be | Performs right shift of one unsigned 64-bit integer using big-endian limbs.<br />The input value to be shifted is assumed to be represented using 32 bit limbs, but this is not checked.<br />The shift value n should be in the range [0, 64), otherwise it will result in an error.<br />Stack transition looks as follows:<br />[n, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a >> n.<br />This takes 47 cycles.<br /> |
| rotl | Performs left rotation of one unsigned 64-bit integer using little-endian limbs.<br />The input value to be rotated is assumed to be represented using 32 bit limbs, but this is not checked.<br />The rotation amount n should be in the range [0, 64), otherwise it will result in an error.<br />Stack transition looks as follows:<br />[n, a_lo, a_hi, ...] -> [c_lo, c_hi, ...], where c = a <<< n (rotate left).<br />This takes 35 cycles.<br /> |
| rotl_be | Performs left rotation of one unsigned 64-bit integer using big-endian limbs.<br />The input value to be rotated is assumed to be represented using 32 bit limbs, but this is not checked.<br />The rotation amount n should be in the range [0, 64), otherwise it will result in an error.<br />Stack transition looks as follows:<br />[n, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a <<< n (rotate left).<br />This takes 38 cycles.<br /> |
| rotr | Performs right rotation of one unsigned 64-bit integer using little-endian limbs.<br />The input value to be rotated is assumed to be represented using 32 bit limbs, but this is not checked.<br />The rotation amount n should be in the range [0, 64), otherwise it will result in an error.<br />Stack transition looks as follows:<br />[n, a_lo, a_hi, ...] -> [c_lo, c_hi, ...], where c = a >>> n (rotate right).<br />This takes 44 cycles.<br /> |
| rotr_be | Performs right rotation of one unsigned 64-bit integer using big-endian limbs.<br />The input value to be shifted is assumed to be represented using 32 bit limbs.<br />The shift value should be in the range [0, 64), otherwise it will result in an<br />error.<br />Stack transition looks as follows:<br />[n, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a >>> n (rotate right).<br />This takes 47 cycles.<br /> |
| clz | Counts the number of leading zeros of one unsigned 64-bit integer using little-endian limbs.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[n_lo, n_hi, ...] -> [clz, ...], where clz is the number of leading zeros of value n.<br />This takes 48 cycles.<br /> |
| clz_be | Counts the number of leading zeros of one unsigned 64-bit integer using big-endian limbs.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[n_hi, n_lo, ...] -> [clz, ...], where clz is a number of leading zeros of value n.<br />This takes 49 cycles.<br /> |
| ctz | Counts the number of trailing zeros of one unsigned 64-bit integer using little-endian limbs.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[n_lo, n_hi, ...] -> [ctz, ...], where ctz is the number of trailing zeros of value n.<br />This takes 41 cycles.<br /> |
| ctz_be | Counts the number of trailing zeros of one unsigned 64-bit integer using big-endian limbs.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[n_hi, n_lo, ...] -> [ctz, ...], where ctz is a number of trailing zeros of value n.<br />This takes 42 cycles.<br /> |
| clo | Counts the number of leading ones of one unsigned 64-bit integer using little-endian limbs.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[n_lo, n_hi, ...] -> [clo, ...], where clo is the number of leading ones of value n.<br />This takes 47 cycles.<br /> |
| clo_be | Counts the number of leading ones of one unsigned 64-bit integer using big-endian limbs.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[n_hi, n_lo, ...] -> [clo, ...], where clo is a number of leading ones of value n.<br />This takes 48 cycles.<br /> |
| cto | Counts the number of trailing ones of one unsigned 64-bit integer using little-endian limbs.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[n_lo, n_hi, ...] -> [cto, ...], where cto is the number of trailing ones of value n.<br />This takes 40 cycles.<br /> |
| cto_be | Counts the number of trailing ones of one unsigned 64-bit integer using big-endian limbs.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[n_hi, n_lo, ...] -> [cto, ...], where cto is a number of trailing ones of value n.<br />This takes 41 cycles.<br /> |
