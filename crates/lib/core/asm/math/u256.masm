pub type u256 = struct { lo: u128, hi: u128 }

# ===== LIMB ORDER HELPERS ========================================================================

#! Reorders the top u256 value between LE and BE limb order. This is an involution.
#! Input/Output (LE <-> BE):
#! [x0, x1, x2, x3, x4, x5, x6, x7, ...] <-> [x7, x6, x5, x4, x3, x2, x1, x0, ...]
proc u256_le_to_be
    swapw
    reversew
    swapw
    reversew
    swapw
end

#! Reorders two u256 values between LE and BE limb order.
proc u256_le_to_be_pair
    exec.u256_le_to_be
    swapdw
    exec.u256_le_to_be
    swapdw
end

# ===== ADDITION ==================================================================================

proc add_with_carry_be(rhs: u256, lhs: u256) -> (i1, u256)
    swapw.3
    movup.3
    movup.7
    u32overflowing_add
    movup.4
    movup.7
    u32overflowing_add3
    movup.4
    movup.6
    u32overflowing_add3
    movup.4
    movup.5
    u32overflowing_add3
    movdn.12
    swapw.2
    movup.12
    movup.4
    movup.8
    u32overflowing_add3
    movup.4
    movup.7
    u32overflowing_add3
    movup.4
    movup.6
    u32overflowing_add3
    movup.4
    movup.5
    u32overflowing_add3
end

pub proc wrapping_add(rhs: u256, lhs: u256) -> u256
    exec.u256_le_to_be_pair
    exec.add_with_carry_be
    drop
    exec.u256_le_to_be
end

#! Performs addition of two unsigned 256 bit integers preserving the overflow.
#! Stack transition looks as follows:
#! [b0, b1, b2, b3, b4, b5, b6, b7, a0, a1, a2, a3, a4, a5, a6, a7, ...]
#!   -> [overflow, c0, c1, c2, c3, c4, c5, c6, c7, ...], where c = (a + b) % 2^256.
pub proc overflowing_add(rhs: u256, lhs: u256) -> (i1, u256)
    exec.u256_le_to_be_pair
    exec.add_with_carry_be
    movdn.8
    exec.u256_le_to_be
    movup.8
end

#! Performs addition of two unsigned 256 bit integers preserving the overflow with sum on top.
#! Stack transition looks as follows:
#! [b0, b1, b2, b3, b4, b5, b6, b7, a0, a1, a2, a3, a4, a5, a6, a7, ...]
#!   -> [c0, c1, c2, c3, c4, c5, c6, c7, overflow, ...], where c = (a + b) % 2^256.
pub proc widening_add(rhs: u256, lhs: u256) -> (u256, i1)
    exec.u256_le_to_be_pair
    exec.add_with_carry_be
    movdn.8
    exec.u256_le_to_be
end

# ===== SUBTRACTION ===============================================================================

proc sub_with_borrow_be(rhs: u256, lhs: u256) -> (i1, u256)
    swapw.3
    movup.7
    movup.4
    u32overflowing_sub
    movup.7
    u32widening_add
    movup.5
    u32overflowing_sub
    movup.2
    add
    movup.6
    u32widening_add
    movup.5
    u32overflowing_sub
    movup.2
    add
    movup.5
    u32widening_add
    movup.5
    u32overflowing_sub
    movup.2
    add
    movdn.12
    swapw.2
    movup.12
    movup.4
    u32widening_add
    movup.8
    u32overflowing_sub
    movup.2
    add
    movup.4
    u32widening_add
    movup.7
    u32overflowing_sub
    movup.2
    add
    movup.4
    u32widening_add
    movup.6
    u32overflowing_sub
    movup.2
    add
    movup.5
    movup.5
    movup.2
    u32widening_add
    drop
    swap u32overflowing_sub
end

pub proc wrapping_sub(rhs: u256, lhs: u256) -> u256
    exec.u256_le_to_be_pair
    exec.sub_with_borrow_be
    drop
    exec.u256_le_to_be
end

#! Performs subtraction of two unsigned 256 bit integers preserving the underflow.
#! Stack transition looks as follows:
#! [b0, b1, b2, b3, b4, b5, b6, b7, a0, a1, a2, a3, a4, a5, a6, a7, ...]
#!   -> [underflow, c0, c1, c2, c3, c4, c5, c6, c7, ...], where c = (a - b) % 2^256.
pub proc overflowing_sub(rhs: u256, lhs: u256) -> (i1, u256)
    exec.u256_le_to_be_pair
    exec.sub_with_borrow_be
    movdn.8
    exec.u256_le_to_be
    movup.8
end

pub proc and(rhs: u256, lhs: u256) -> u256
    exec.u256_le_to_be_pair
    swapw.3
    movup.3
    movup.7
    u32and
    movup.3
    movup.6
    u32and
    movup.3
    movup.5
    u32and
    movup.3
    movup.4
    u32and
    swapw.2
    movup.3
    movup.7
    u32and
    movup.3
    movup.6
    u32and
    movup.3
    movup.5
    u32and
    movup.3
    movup.4
    u32and
    exec.u256_le_to_be
end

pub proc or(rhs: u256, lhs: u256) -> u256
    exec.u256_le_to_be_pair
    swapw.3
    movup.3
    movup.7
    u32or
    movup.3
    movup.6
    u32or
    movup.3
    movup.5
    u32or
    movup.3
    movup.4
    u32or
    swapw.2
    movup.3
    movup.7
    u32or
    movup.3
    movup.6
    u32or
    movup.3
    movup.5
    u32or
    movup.3
    movup.4
    u32or
    exec.u256_le_to_be
end

pub proc xor(rhs: u256, lhs: u256) -> u256
    exec.u256_le_to_be_pair
    swapw.3
    movup.3
    movup.7
    u32xor
    movup.3
    movup.6
    u32xor
    movup.3
    movup.5
    u32xor
    movup.3
    movup.4
    u32xor
    swapw.2
    movup.3
    movup.7
    u32xor
    movup.3
    movup.6
    u32xor
    movup.3
    movup.5
    u32xor
    movup.3
    movup.4
    u32xor
    exec.u256_le_to_be
end

pub proc eqz(rhs: u256, lhs: u256) -> i1
    exec.u256_le_to_be
    eq.0
    repeat.7
        swap
        eq.0
        and
    end
end

pub proc eq(rhs: u256, lhs: u256) -> i1
    exec.u256_le_to_be_pair
    swapw.3
    eqw
    movdn.8
    dropw
    dropw
    movdn.8
    eqw
    movdn.8
    dropw
    dropw
    and
end

# ===== MULTIPLICATION ============================================================================

proc mulstep
    # Input: [k, c, b, a, ...]
    #   k = carry from previous step
    #   c = partial sum to accumulate into
    #   b = multiplier limb
    #   a = multiplicand limb
    # Output: [new_k, result, ...]

    movdn.2                    # [c, b, k, a, ...]
    u32widening_madd        # [lo, hi, a, ...]  (computes c*b+k)
    movup.2                    # [a, lo, hi, ...]
    u32overflowing_add      # [carry, result, hi, ...]  (computes a+lo)
    movup.2                    # [hi, carry, result, ...]
    add                        # [new_k, result, ...]  (computes hi+carry)
end

proc mulstep4
    movup.12
    dup.1
    movup.10
    push.0 # start k at 0
    exec.mulstep
    swap
    movdn.9
    dup.1
    movup.9
    movup.13
    swap.3
    exec.mulstep
    swap
    movdn.8
    dup.1
    movup.8
    movup.12
    swap.3
    exec.mulstep
    swap
    movdn.7
    dup.1
    movup.7
    movup.11
    swap.3
    exec.mulstep
    swap
    movdn.6
end

#! Performs multiplication of two unsigned 256 bit integers discarding the overflow.
#! The input values are assumed to be represented using 32 bit limbs, but this is not checked.
#! Stack transition looks as follows:
#! [b0, b1, b2, b3, b4, b5, b6, b7, a0, a1, a2, a3, a4, a5, a6, a7, ...] -> [c0, c1, c2, c3, c4, c5, c6, c7, ...]
#! where c = (a * b) % 2^256, and a0, b0, and c0 are least significant 32-bit limbs of a, b, and c respectively.
@locals(24)
pub proc wrapping_mul(rhs: u256, lhs: u256) -> u256
    exec.u256_le_to_be_pair
    # Memory storing setup
    loc_storew_be.0
    dropw
    # b[5-8] at 0
    loc_storew_be.4
    # b[0-4] at 1
    push.0 dropw
    # b[0] at top of stack, followed by a[0-7]
    movdn.8
    loc_storew_be.8
    # a[0-4] at 2
    swapw
    loc_storew_be.12
    # a[5-8] at 3
    padw
    loc_storew_be.16
    loc_storew_be.20
    # p at 4 and 5

    # b[0]
    dropw
    swapw
    padw
    loc_loadw_be.16
    movdnw.2
    movup.12

    exec.mulstep4

    movdn.9
    movdn.9
    swapw
    loc_storew_be.16
    dropw
    padw
    loc_loadw_be.20
    swapw
    movup.9
    movup.9

    dup.1
    movup.6
    movup.10
    swap.3
    exec.mulstep
    swap
    movdn.5
    dup.1
    movup.5
    movup.9
    swap.3
    exec.mulstep
    swap
    movdn.4
    dup.1
    movup.4
    movup.8
    swap.3
    exec.mulstep
    swap
    movdn.3
    swap
    movup.2
    movup.6
    swap.3
    exec.mulstep

    drop
    loc_storew_be.20
    dropw

    # b[1]
    padw
    loc_loadw_be.16
    padw
    loc_loadw_be.20
    movup.7
    dropw
    padw
    loc_loadw_be.12 padw
    loc_loadw_be.8 # load the xs
    padw
    loc_loadw_be.4
    movup.2
    movdn.3
    push.0 dropw # only need b[1]

    exec.mulstep4

    movdn.9
    movdn.9
    swapw
    movdn.3
    padw
    loc_loadw_be.16
    push.0 dropw # only need p[0]
    movdn.3
    # save p[0-3] to memory, not needed any more
    loc_storew_be.16
    dropw

    padw
    loc_loadw_be.20
    movup.3
    drop
    swapw
    movup.9
    movup.9

    dup.1
    movup.6
    movup.9
    swap.3
    exec.mulstep
    swap
    movdn.7
    dup.1
    movup.5
    movup.7
    swap.3
    exec.mulstep
    swap
    movdn.5
    swap
    movup.3
    movup.4
    swap.3
    exec.mulstep

    drop
    swap
    drop
    loc_storew_be.20
    dropw

    # b[2]
    padw
    loc_loadw_be.16
    padw
    loc_loadw_be.20
    movup.7
    movup.7
    dropw
    padw
    loc_loadw_be.12 padw
    loc_loadw_be.8 # load the xs
    padw
    loc_loadw_be.4
    swap
    movdn.3
    push.0 dropw # only need b[1]

    exec.mulstep4

    movdn.9
    movdn.9
    swapw
    movdn.3
    movdn.3
    padw
    loc_loadw_be.16
    drop drop
    movdn.3
    movdn.3
    loc_storew_be.16
    dropw

    padw
    loc_loadw_be.20
    movup.3
    movup.3
    drop
    drop
    swapw
    movup.9
    movup.9

    dup.1
    movup.6
    movup.8
    swap.3
    exec.mulstep
    swap
    movdn.6
    dup.1
    movup.5
    movup.6
    swap.3
    exec.mulstep
    swap
    swap drop
    movdn.3
    drop drop drop
    loc_storew_be.20
    dropw

    # b[3]
    padw
    loc_loadw_be.16
    padw
    loc_loadw_be.20

    movup.7 movup.7 movup.7
    dropw
    padw
    loc_loadw_be.12 padw
    loc_loadw_be.8

    padw
    loc_loadw_be.4
    movdn.3
    push.0 dropw

    exec.mulstep4

    movdn.9
    movdn.9

    swapw
    movup.3
    padw
    loc_loadw_be.16
    drop
    movup.3

    loc_storew_be.16
    dropw
    padw
    loc_loadw_be.20
    movdn.3
    push.0 dropw
    swapw
    movup.9
    movup.9

    swap
    movup.5
    movup.6
    swap.3
    exec.mulstep

    drop
    movdn.3
    push.0 dropw

    # b[4]
    padw
    loc_loadw_be.12 padw
    loc_loadw_be.8 # load the xs
    # OPTIM: don't need a[4-7], but can't use mulstep4 if we don't load

    padw
    loc_loadw_be.0
    push.0 dropw # b[4]

    exec.mulstep4
    dropw drop drop # OPTIM: don't need a[4-7], but can't use mulstep4 if we don't load

    # b[5]
    padw
    loc_loadw_be.12
    padw
    loc_loadw_be.0
    movup.2 movdn.3
    push.0 dropw
    movup.7
    dup.1
    movup.6
    push.0
    exec.mulstep
    swap
    movdn.7
    movup.4
    dup.2
    movup.7
    swap.3
    exec.mulstep
    swap
    movdn.5
    swap
    movup.3
    movup.4
    swap.3
    exec.mulstep
    drop
    swap
    drop

    # b[6]
    padw
    loc_loadw_be.12
    padw
    loc_loadw_be.0
    swap
    movdn.3
    push.0 dropw
    movup.6
    dup.1
    movup.6
    push.0
    exec.mulstep
    swap
    movdn.6
    swap
    movup.4
    movup.5
    swap.3
    exec.mulstep
    drop
    movdn.2
    drop drop

    # b[7]
    padw
    loc_loadw_be.12
    padw
    loc_loadw_be.0

    movdn.3 push.0 dropw
    movup.4
    movup.5
    movdn.2
    push.0
    exec.mulstep
    drop
    movdn.3
    drop drop drop

    padw
    loc_loadw_be.16
    swapw
    exec.u256_le_to_be
end
