# Error Context Refactor: Lazy Evaluation Plan

**Date**: 2025-11-10
**Branch**: `adr1anh/errctx-next`
**Goal**: Replace eager error context evaluation with lazy pattern for hot-path performance

---

## Problem Statement

### Original Implementation Issue

The `err_ctx!` macro **eagerly** evaluates error context on every operation:

```rust
// Old pattern: Expensive work happens NOW, even on success
let err_ctx = err_ctx!(program, basic_block_node, host, self.clk);
// ^ Walks MAST, calls host.get_label_and_source_file()
// ^ Happens BEFORE we know if an error will occur

self.execute_sync_op(...)
    .map_exec_err(&err_ctx)?;  // Just uses pre-computed context
```

**Performance Impact**:
- Every operation in hot path pays cost of source location lookup
- Operations succeed far more often than they fail
- We're optimizing the error path at the expense of the success path

**Cost Breakdown**:
1. `err_ctx!` macro calls:
   - `node.get_assembly_op(op_idx)` - MAST traversal
   - `host.get_label_and_source_file(assembly_op)` - Potentially expensive lookup
2. These happen **before** the operation executes
3. Context is discarded if operation succeeds (99%+ of cases)

### Migration Risk - Source Location Loss

**CRITICAL**: After introducing `OpErrorContext` with lazy evaluation, any code site that still calls the old host-free error wrapping pattern **loses source location information**:

```rust
// BROKEN: Falls back to SourceSpan::UNKNOWN
let err_ctx = OpErrorContext::new(program, node_id, clk);
some_operation()
    .map_exec_err(&err_ctx)?;  // ❌ No host → can't resolve source
```

**Affected Areas**:
- **Decoder routines** (`processor/src/decoder/mod.rs`): All `map_exec_err(err_ctx)` calls need updating
- **External error handler** (`add_error_ctx_to_external_error`): Calls `label_and_source_file()` instead of `resolve_source(host)`
- **Slow-path helpers**: Any function passing `err_ctx` without also passing `host`

**The Fix**: Thread the host through so lazy resolution can work:
```rust
// CORRECT: Host enables lazy source resolution
let err_ctx = OpErrorContext::new(program, node_id, clk);
some_operation()
    .map_exec_err_with_host(&err_ctx, host)?;  // ✅ Host → resolves source on error
```

---

## Solution: Lazy Error Context

### Core Insight

**Defer all expensive work until we're inside `.map_err()` closure**:

```rust
// Proposed: Store only cheap references
let err_ctx = OpErrorContext::with_op(program, node_id, op_idx, self.clk);
// ^ Just stores pointers + scalars, no MAST walk, no host calls

self.execute_sync_op(...)
    .map_exec_err(&err_ctx, host)?;
    // ^ Only does expensive work inside map_err if error occurs
```

**Benefits**:
- ✅ Success path: ~free (just struct construction)
- ✅ Error path: Same cost as before (acceptable since error already occurred)
- ✅ No diagnostic information lost
- ✅ Simpler than macro (explicit, type-safe)
- ✅ `no_err_ctx` feature can collapse to scalars

---

## Design Overview

### 1. OpErrorContext Struct

**Purpose**: Lightweight handle that stores only references and scalars needed to resolve error context later.

```rust
#[cfg(not(feature = "no_err_ctx"))]
pub struct OpErrorContext<'a> {
    clk: RowIndex,
    program: &'a MastForest,
    node_id: MastNodeId,
    op_idx: Option<usize>,
}

#[cfg(feature = "no_err_ctx")]
pub struct OpErrorContext<'a> {
    clk: RowIndex,
    _phantom: PhantomData<&'a ()>,
}
```

**Construction**:
```rust
impl<'a> OpErrorContext<'a> {
    /// Create context for node-level errors (no specific operation)
    pub fn new(
        program: &'a MastForest,
        node_id: MastNodeId,
        clk: RowIndex,
    ) -> Self {
        #[cfg(not(feature = "no_err_ctx"))]
        { Self { clk, program, node_id, op_idx: None } }

        #[cfg(feature = "no_err_ctx")]
        { Self { clk, _phantom: PhantomData } }
    }

    /// Create context for operation-level errors (specific op in node)
    pub fn with_op(
        program: &'a MastForest,
        node_id: MastNodeId,
        op_idx: usize,
        clk: RowIndex,
    ) -> Self {
        #[cfg(not(feature = "no_err_ctx"))]
        { Self { clk, program, node_id, op_idx: Some(op_idx) } }

        #[cfg(feature = "no_err_ctx")]
        { Self { clk, _phantom: PhantomData } }
    }
}
```

**Why MastNodeId instead of &MastNode?**
- Don't need to keep node reference alive
- Can retrieve node from forest when needed (only in error path)
- Smaller struct (one word instead of pointer)

### 2. ErrorContext Trait

**Purpose**: Abstract interface for resolving error context lazily.

```rust
pub trait ErrorContext {
    /// Get the clock cycle (always cheap)
    fn clk(&self) -> RowIndex;

    /// Resolve source location (expensive, only called in error path)
    fn resolve_source(
        &self,
        host: &impl BaseHost,
    ) -> Option<(SourceSpan, Option<Arc<SourceFile>>)>;

    /// Wrap an OperationError with context (calls resolve_source internally)
    fn wrap_op_err(
        &self,
        host: &impl BaseHost,
        err: OperationError,
    ) -> ExecutionError {
        match self.resolve_source(host) {
            Some((label, source_file)) => ExecutionError::OperationError {
                clk: self.clk(),
                label,
                source_file,
                err: Box::new(err),
            },
            None => ExecutionError::OperationErrorNoContext {
                clk: self.clk(),
                err: Box::new(err),
            },
        }
    }
}
```

**Implementation for OpErrorContext**:
```rust
#[cfg(not(feature = "no_err_ctx"))]
impl<'a> ErrorContext for OpErrorContext<'a> {
    fn clk(&self) -> RowIndex {
        self.clk
    }

    fn resolve_source(
        &self,
        host: &impl BaseHost,
    ) -> Option<(SourceSpan, Option<Arc<SourceFile>>)> {
        // Only happens in error path - expensive work deferred until here
        let node = self.program.get_node_by_id(self.node_id)?;

        if let Some(op_idx) = self.op_idx {
            // Operation-level error: get specific operation's location
            let assembly_op = node.get_assembly_op(op_idx)?;
            let (label, source_file) = host.get_label_and_source_file(assembly_op)?;
            Some((label, source_file))
        } else {
            // Node-level error: try to get node's location
            // (implementation depends on whether nodes have locations)
            None  // For now, conservative
        }
    }
}

#[cfg(feature = "no_err_ctx")]
impl<'a> ErrorContext for OpErrorContext<'a> {
    fn clk(&self) -> RowIndex {
        self.clk
    }

    fn resolve_source(&self, _host: &impl BaseHost) -> Option<(SourceSpan, Option<Arc<SourceFile>>)> {
        None  // Always no context in no_err_ctx build
    }
}
```

### 3. ResultOpErrExt Update

**Purpose**: Change trait to accept host in error-wrapping method.

```rust
pub trait ResultOpErrExt<T> {
    /// Wrap OperationError with context (requires host for resolution)
    fn map_exec_err(
        self,
        ctx: &impl ErrorContext,
        host: &impl BaseHost,
    ) -> Result<T, ExecutionError>;

    /// Wrap OperationError without context (for external errors)
    fn map_exec_err_no_ctx(self, clk: RowIndex) -> Result<T, ExecutionError>;
}

impl<T> ResultOpErrExt<T> for Result<T, OperationError> {
    fn map_exec_err(
        self,
        ctx: &impl ErrorContext,
        host: &impl BaseHost,
    ) -> Result<T, ExecutionError> {
        self.map_err(|err| ctx.wrap_op_err(host, err))
    }

    fn map_exec_err_no_ctx(self, clk: RowIndex) -> Result<T, ExecutionError> {
        self.map_err(|err| ExecutionError::OperationErrorNoContext {
            clk,
            err: Box::new(err),
        })
    }
}
```

**Key Change**: `map_exec_err` now takes `host` parameter, allowing lazy resolution.

### 4. Call Site Pattern

**Before (eager evaluation)**:
```rust
let err_ctx = err_ctx!(program, basic_block, host, op_idx_in_block, self.clk);
self.execute_sync_op(op, op_idx_in_block, program, host, tracer)
    .map_exec_err(&err_ctx)?;
```

**After (lazy evaluation)**:
```rust
let err_ctx = OpErrorContext::with_op(program, node_id, op_idx_in_block, self.clk);
self.execute_sync_op(op, op_idx_in_block, program, host, tracer)
    .map_exec_err(&err_ctx, host)?;
```

**Cost Comparison**:
- Before: Expensive work happens at `err_ctx!` call (always)
- After: Expensive work happens inside `.map_err()` closure (only on error)

---

## Implementation Phases

### Phase 1: Core Infrastructure ✅ COMPLETE

**Summary**: Traits and `OpErrorContext` merged; `err_ctx!` macro no longer used in codebase.

**What was accomplished**:
- ✅ Added `OpErrorContext` struct with lazy evaluation
- ✅ Updated `ErrorContext` trait with `resolve_source(host)` method
- ✅ Added `ResultOpErrExt::map_exec_err_with_host()` for host-aware wrapping
- ✅ Migrated all call sites from `err_ctx!` macro to `OpErrorContext` builders
- ✅ All 2411 tests passing

---

### Remaining Work

The infrastructure is in place, but there are still sites that call the **old pattern** without the host parameter, causing them to fall back to `SourceSpan::UNKNOWN`. These must be updated:

#### 1. Update decoder routines to use host-aware error wrapping

**File**: `processor/src/decoder/mod.rs`

**Status**: ✅ COMPLETE (updated in previous session)

All decoder methods now accept `host` parameter and use `.map_exec_err_with_host(err_ctx, host)`:
- `start_join_node` / `end_join_node`
- `start_split_node` / `end_split_node`
- `start_loop_node` / `end_loop_node`
- `start_call_node` / `end_call_node`
- `start_dyn_node` / `end_dyn_node`
- `start_dyncall_node` / `end_dyncall_node`

#### 2. Update slow-path external error handler

**File**: `processor/src/lib.rs`

**Status**: ✅ COMPLETE (updated in previous session)

The `add_error_ctx_to_external_error` function now:
- Accepts `host: &impl SyncHost` parameter
- Calls `err_ctx.resolve_source(host)` instead of `label_and_source_file()`
- All call sites updated to pass host

#### 3. Fix source unavailability detection

**File**: `processor/src/errors.rs`

**Status**: ✅ COMPLETE (fixed in previous session)

The `OpErrorContext::resolve_source` method now properly returns `None` when:
- The span is `SourceSpan::default()` AND
- There is no source file

This ensures errors without debug info become `OperationErrorNoContext` with help text instead of `OperationError` with empty spans.

#### 4. Delete the `err_ctx!` macro

**File**: `processor/src/errors.rs`

**Status**: ⏳ TODO

Since all usages have been replaced, the macro definition itself can be deleted:

```bash
# Verify no remaining usages (should return only the macro definition):
rg "err_ctx!" processor/src/

# Delete the macro definition from errors.rs
# Then verify compilation:
make test
```

**Verification steps**:
1. Search for any remaining `err_ctx!` usages: `rg "err_ctx!" processor/ miden-vm/ stdlib/`
2. Delete macro definition from `processor/src/errors.rs`
3. Run full test suite: `make test`
4. Test with `no_err_ctx` feature: `make test-fast FEATURES=no_err_ctx`

---
```rust
// Add to processor/src/errors.rs after ErrorContext trait

/// Lightweight error context handle for lazy source location resolution.
///
/// This struct stores only references and scalars needed to resolve error context
/// later (in the error path). Unlike the `err_ctx!` macro, this does not eagerly
/// call expensive operations like `get_assembly_op()` or `get_label_and_source_file()`.
///
/// # Performance
///
/// - Construction: ~free (just stores pointers + scalars)
/// - Resolution: Only happens inside `.map_err()` closure when error occurs
///
/// # Feature Flags
///
/// When `no_err_ctx` is enabled, this struct collapses to just the clock cycle.
#[cfg(not(feature = "no_err_ctx"))]
pub struct OpErrorContext<'a> {
    clk: RowIndex,
    program: &'a MastForest,
    node_id: MastNodeId,
    op_idx: Option<usize>,
}

#[cfg(feature = "no_err_ctx")]
pub struct OpErrorContext<'a> {
    clk: RowIndex,
    _phantom: PhantomData<&'a ()>,
}
```

#### 1.2. Add constructors
```rust
impl<'a> OpErrorContext<'a> {
    /// Create context for node-level errors (no specific operation index).
    ///
    /// Use this for errors that occur at the node boundary (e.g., node not found,
    /// invalid node type) rather than during execution of a specific operation.
    #[inline]
    pub fn new(
        program: &'a MastForest,
        node_id: MastNodeId,
        clk: RowIndex,
    ) -> Self {
        #[cfg(not(feature = "no_err_ctx"))]
        {
            Self {
                clk,
                program,
                node_id,
                op_idx: None,
            }
        }

        #[cfg(feature = "no_err_ctx")]
        {
            Self {
                clk,
                _phantom: PhantomData,
            }
        }
    }

    /// Create context for operation-level errors (specific operation in node).
    ///
    /// Use this for errors that occur during execution of a specific operation
    /// within a node (e.g., divide by zero, failed assertion).
    #[inline]
    pub fn with_op(
        program: &'a MastForest,
        node_id: MastNodeId,
        op_idx: usize,
        clk: RowIndex,
    ) -> Self {
        #[cfg(not(feature = "no_err_ctx"))]
        {
            Self {
                clk,
                program,
                node_id,
                op_idx: Some(op_idx),
            }
        }

        #[cfg(feature = "no_err_ctx")]
        {
            Self {
                clk,
                _phantom: PhantomData,
            }
        }
    }
}
```

#### 1.3. Update ErrorContext trait
```rust
// Modify existing ErrorContext trait in processor/src/errors.rs

pub trait ErrorContext {
    /// Returns the clock cycle at which the error occurred.
    ///
    /// This is always cheap to access.
    fn clk(&self) -> RowIndex;

    /// Resolve the source location for this error context.
    ///
    /// This may be expensive (MAST traversal, host lookups) and should only
    /// be called in the error path.
    ///
    /// Returns `None` if:
    /// - Source information is not available
    /// - The `no_err_ctx` feature is enabled
    /// - The node or operation has no associated source location
    fn resolve_source(
        &self,
        host: &impl BaseHost,
    ) -> Option<(SourceSpan, Option<Arc<SourceFile>>)>;

    /// Wrap an OperationError with this context, resolving source information lazily.
    ///
    /// This is the primary method for converting an OperationError into an ExecutionError
    /// with appropriate diagnostic information.
    fn wrap_op_err(
        &self,
        host: &impl BaseHost,
        err: OperationError,
    ) -> ExecutionError {
        match self.resolve_source(host) {
            Some((label, source_file)) => ExecutionError::OperationError {
                clk: self.clk(),
                label,
                source_file,
                err: Box::new(err),
            },
            None => ExecutionError::OperationErrorNoContext {
                clk: self.clk(),
                err: Box::new(err),
            },
        }
    }
}
```

#### 1.4. Implement ErrorContext for OpErrorContext
```rust
// Add after OpErrorContext impl block

#[cfg(not(feature = "no_err_ctx"))]
impl<'a> ErrorContext for OpErrorContext<'a> {
    #[inline]
    fn clk(&self) -> RowIndex {
        self.clk
    }

    fn resolve_source(
        &self,
        host: &impl BaseHost,
    ) -> Option<(SourceSpan, Option<Arc<SourceFile>>)> {
        // Expensive work happens here, but only in error path
        let node = self.program.get_node_by_id(self.node_id)?;

        if let Some(op_idx) = self.op_idx {
            // Operation-level error: get specific operation's location
            let assembly_op = node.get_assembly_op(op_idx)?;
            let (label, source_file) = host.get_label_and_source_file(assembly_op)?;
            Some((label, source_file))
        } else {
            // Node-level error: no operation-specific location
            // Future: Could try to get node's overall location if available
            None
        }
    }
}

#[cfg(feature = "no_err_ctx")]
impl<'a> ErrorContext for OpErrorContext<'a> {
    #[inline]
    fn clk(&self) -> RowIndex {
        self.clk
    }

    #[inline]
    fn resolve_source(
        &self,
        _host: &impl BaseHost,
    ) -> Option<(SourceSpan, Option<Arc<SourceFile>>)> {
        None  // Always no context in no_err_ctx build
    }
}
```

#### 1.5. Update ResultOpErrExt trait
```rust
// Modify existing ResultOpErrExt in processor/src/errors.rs

pub trait ResultOpErrExt<T> {
    /// Wrap an OperationError with error context, resolving source information lazily.
    ///
    /// The context and host are used to resolve source location information only if
    /// an error occurs (inside the `.map_err()` closure).
    ///
    /// # Arguments
    ///
    /// * `ctx` - Error context handle (cheap to construct)
    /// * `host` - Host for resolving source locations (only used on error path)
    fn map_exec_err(
        self,
        ctx: &impl ErrorContext,
        host: &impl BaseHost,
    ) -> Result<T, ExecutionError>;

    /// Wrap an OperationError without context.
    ///
    /// Use this for errors that occur outside program execution (e.g., during
    /// external program loading, deserialization failures).
    fn map_exec_err_no_ctx(self, clk: RowIndex) -> Result<T, ExecutionError>;
}

impl<T> ResultOpErrExt<T> for Result<T, OperationError> {
    #[inline]
    fn map_exec_err(
        self,
        ctx: &impl ErrorContext,
        host: &impl BaseHost,
    ) -> Result<T, ExecutionError> {
        self.map_err(|err| ctx.wrap_op_err(host, err))
    }

    #[inline]
    fn map_exec_err_no_ctx(self, clk: RowIndex) -> Result<T, ExecutionError> {
        self.map_err(|err| ExecutionError::OperationErrorNoContext {
            clk,
            err: Box::new(err),
        })
    }
}
```

#### 1.6. Add necessary imports
```rust
// Add to top of processor/src/errors.rs
use core::marker::PhantomData;
use miden_core::mast::MastNodeId;
```

**Validation**:
- Run `cargo check --package miden-processor`
- Run `cargo check --package miden-processor --features no_err_ctx`
- Ensure both configurations compile

**Success Criteria**:
- ✅ New types added to `errors.rs`
- ✅ ErrorContext trait updated with `resolve_source()`
- ✅ ResultOpErrExt updated to take `host` parameter
- ✅ Both feature configurations compile
- ✅ No breaking changes to existing code (old `err_ctx!` still works)

---

### Phase 2: Migrate Call Sites

**Goal**: Replace `err_ctx!` macro usage with `OpErrorContext` builders.

**Strategy**: Migrate module by module, running tests after each.

#### 2.1. Fast Processor - Basic Block (Pilot)

**File**: `processor/src/fast/basic_block.rs`

**Current pattern**:
```rust
let decorator_err_ctx = err_ctx!(program, basic_block, host, op_idx_in_block, self.clk);
let decorator = program
    .get_decorator_by_id(decorator_id)
    .ok_or(OperationError::DecoratorNotFoundInForest(decorator_id))
    .map_exec_err(&decorator_err_ctx)?;
```

**New pattern**:
```rust
let decorator_err_ctx = OpErrorContext::with_op(
    program,
    node_id,
    op_idx_in_block,
    self.clk
);
let decorator = program
    .get_decorator_by_id(decorator_id)
    .ok_or(OperationError::DecoratorNotFoundInForest(decorator_id))
    .map_exec_err(&decorator_err_ctx, host)?;
```

**Changes needed**:
1. Replace `err_ctx!` macro calls with `OpErrorContext::new` or `::with_op`
2. Add `host` parameter to `.map_exec_err()` calls
3. Pass `node_id` instead of `&node` reference (need to track this)

**Locations in basic_block.rs**:
- Line 117: Decorators after operations (no op_idx)
- Line 152: Decorators during operations (with op_idx)
- Line 176: Operation execution error (with op_idx)

**Test**: `make test-fast test=basic_block` after changes

#### 2.2. Fast Processor - Other Modules

**Files**:
- `processor/src/fast/call.rs`
- `processor/src/fast/dyn.rs`
- `processor/src/fast/join.rs`
- `processor/src/fast/loop.rs`
- `processor/src/fast/split.rs`
- `processor/src/fast/syscall.rs`

**Pattern**: Same as basic_block.rs - replace macro with builder

**Test**: `make test-processor` after each file

#### 2.3. Decoder

**File**: `processor/src/decoder/mod.rs`

**Changes needed**:
1. Update method signatures to take `ctx: &impl ErrorContext` instead of building inside
2. Replace `err_ctx!` with context parameter usage
3. Update callers to pass context

**Example**:
```rust
// Before:
pub fn start_join_node(
    &mut self,
    node_id: MastNodeId,
    program: &MastForest,
    err_ctx: &impl ErrorContext,
) -> Result<(), ExecutionError> {
    // err_ctx already created by caller
    let join_node = program
        .get_node_by_id(node_id)
        .ok_or(OperationError::MastNodeNotFoundInForest(node_id))
        .map_exec_err(err_ctx)?;  // OLD: missing host
    // ...
}

// After:
pub fn start_join_node(
    &mut self,
    node_id: MastNodeId,
    program: &MastForest,
    err_ctx: &impl ErrorContext,
    host: &impl BaseHost,
) -> Result<(), ExecutionError> {
    let join_node = program
        .get_node_by_id(node_id)
        .ok_or(OperationError::MastNodeNotFoundInForest(node_id))
        .map_exec_err(err_ctx, host)?;  // NEW: pass host
    // ...
}
```

**All decoder methods to update**:
- `start_join_node` / `end_join_node`
- `start_split_node` / `end_split_node`
- `start_loop_node` / `end_loop_node`
- `start_call_node` / `end_call_node`
- `start_dyn_node` / `end_dyn_node`
- `start_dyncall_node` / `end_dyncall_node`

**Test**: `make test-processor` after changes

#### 2.4. Slow Processor

**Files**:
- `processor/src/lib.rs` (main execution loop)

**Changes**: Similar to fast processor - replace macro with builder

**Test**: `make test-processor` after changes

#### 2.5. Parallel Processor

**File**: `processor/src/parallel/mod.rs`

**Changes**: Replace macro usage with builder

**Test**: `make test-processor` after changes

#### 2.6. Chiplets

**Files**:
- `processor/src/chiplets/memory/mod.rs`
- `processor/src/chiplets/ace/mod.rs`
- `processor/src/chiplets/bitwise/mod.rs`
- `processor/src/chiplets/kernel_rom/mod.rs`

**Changes**: Replace any `err_ctx!` usage (should be minimal in chiplets)

**Test**: `make test-processor` after changes

**Success Criteria for Phase 2**:
- ✅ All `err_ctx!` macro calls replaced
- ✅ All `.map_exec_err()` calls updated to pass `host`
- ✅ All tests pass: `make test`
- ✅ Both feature configs work: test with and without `no_err_ctx`

---

### Phase 3: Remove Macro

**Goal**: Delete the now-unused `err_ctx!` macro.

**Files to modify**:
1. `processor/src/errors.rs`

**Tasks**:

#### 3.1. Remove macro definition
```rust
// DELETE this entire macro block from errors.rs:
macro_rules! err_ctx {
    // ... entire macro definition
}
```

#### 3.2. Verify no remaining usages
```bash
# Should return no results:
rg "err_ctx!" processor/ miden-vm/ stdlib/
```

#### 3.3. Run full test suite
```bash
make test
make test-fast FEATURES=no_err_ctx
```

**Success Criteria**:
- ✅ Macro deleted
- ✅ No compilation errors
- ✅ All tests pass
- ✅ Both feature configurations work

---

### Phase 4: Documentation & Cleanup

**Goal**: Update documentation and clean up any remaining cruft.

**Tasks**:

#### 4.1. Update review.md
Add section documenting the lazy evaluation pattern:
- How OpErrorContext works
- Performance characteristics
- When to use `new` vs `with_op`
- Feature flag behavior

#### 4.2. Update errors.rs module docs
Add doc comments explaining:
- The two-tier error pattern
- How lazy evaluation works
- Performance benefits
- Feature flag configuration

#### 4.3. Add examples to OpErrorContext
```rust
/// # Examples
///
/// ```
/// use miden_processor::{OpErrorContext, ResultOpErrExt};
///
/// // Node-level error (no specific operation)
/// let ctx = OpErrorContext::new(program, node_id, clk);
/// some_operation()
///     .map_exec_err(&ctx, host)?;
///
/// // Operation-level error (specific op index)
/// let ctx = OpErrorContext::with_op(program, node_id, op_idx, clk);
/// execute_operation()
///     .map_exec_err(&ctx, host)?;
/// ```
```

#### 4.4. Optional: Measure performance improvement
```bash
# Before/after benchmark of hot path operations
cargo bench --bench processor_ops
```

**Success Criteria**:
- ✅ Documentation updated
- ✅ Examples added
- ✅ Code is clean and maintainable
- ✅ Performance improvement measured (optional but nice)

---

## Key Design Decisions

### 1. Why MastNodeId instead of &MastNode?
**Decision**: Store `MastNodeId` instead of node reference

**Rationale**:
- Don't need to keep node alive during operation execution
- Smaller struct (one word vs pointer)
- Can retrieve node from forest in error path (acceptable cost)
- Avoids lifetime complexity

### 2. Why pass host to map_exec_err?
**Decision**: Add `host` parameter to `.map_exec_err()`

**Rationale**:
- Makes dependency explicit (need host to resolve labels)
- Only used in error path (acceptable to pass through)
- Cleaner than storing host reference in context
- Matches actual requirement

### 3. Why keep map_exec_err_no_ctx?
**Decision**: Keep both methods on ResultOpErrExt

**Rationale**:
- Some errors have no program context (external loads, deserialization)
- Explicitly signals "no context available" vs "context available but lazy"
- Simpler than making program/node optional

### 4. Why Option<usize> for op_idx?
**Decision**: Make operation index optional in OpErrorContext

**Rationale**:
- Node-level errors don't have operation index
- Simpler than separate types for node vs operation contexts
- Clear semantics: None = node-level, Some = operation-level

### 5. Why not cache resolved source in Cell?
**Decision**: Don't add caching (yet)

**Rationale**:
- We bail on first error (no multiple resolutions)
- Adds complexity without measured benefit
- Can add later if profiling shows need
- Keep it simple first

---

## Migration Checklist

### Phase 1: Core Infrastructure ✅
- [ ] Add OpErrorContext struct (both feature configs)
- [ ] Add OpErrorContext::new and ::with_op constructors
- [ ] Update ErrorContext trait with resolve_source
- [ ] Implement ErrorContext for OpErrorContext
- [ ] Update ResultOpErrExt to take host parameter
- [ ] Add necessary imports
- [ ] Verify both feature configs compile

### Phase 2: Migrate Call Sites
- [ ] Fast processor - basic_block.rs
- [ ] Fast processor - call.rs
- [ ] Fast processor - dyn.rs
- [ ] Fast processor - join.rs
- [ ] Fast processor - loop.rs
- [ ] Fast processor - split.rs
- [ ] Fast processor - syscall.rs
- [ ] Decoder - all methods
- [ ] Slow processor - lib.rs
- [ ] Parallel processor - mod.rs
- [ ] Chiplets - memory/mod.rs
- [ ] Chiplets - ace/mod.rs
- [ ] Chiplets - bitwise/mod.rs
- [ ] Chiplets - kernel_rom/mod.rs
- [ ] Verify all tests pass after each module
- [ ] Verify both feature configs work

### Phase 3: Remove Macro
- [ ] Delete err_ctx! macro from errors.rs
- [ ] Verify no remaining usages with rg
- [ ] Run full test suite
- [ ] Test both feature configurations

### Phase 4: Documentation
- [ ] Update review.md with lazy pattern
- [ ] Update errors.rs module docs
- [ ] Add examples to OpErrorContext
- [ ] Optional: Measure performance improvement

---

## Testing Strategy

### Unit Tests
- No new unit tests needed (behavior unchanged)
- Existing tests verify correctness

### Integration Tests
- Run after each module migration
- Verify both success and error paths work

### Feature Flag Tests
```bash
# Default configuration
make test

# With no_err_ctx
make test-fast FEATURES=no_err_ctx
```

### Performance Verification
```bash
# Optional: Benchmark before/after
cargo bench --bench processor_ops

# Look for improvement in success-path operations
# Error path should be same cost
```

---

## Rollback Plan

If issues arise during migration:

1. **Phase 1 issues**: Just don't use new types yet (old macro still works)
2. **Phase 2 issues**: Revert individual module changes
3. **Phase 3 issues**: Can't easily rollback (would need to restore macro)

**Recommendation**: Complete Phase 2 thoroughly before Phase 3.

---

## Success Metrics

### Correctness
- ✅ All tests pass
- ✅ Both feature configurations work
- ✅ Error messages unchanged
- ✅ Source locations still attached correctly

### Performance
- ✅ Success path faster (or same)
- ✅ Error path same cost
- ✅ No regressions in benchmarks

### Code Quality
- ✅ No macro magic
- ✅ Explicit, type-safe API
- ✅ Clear separation of concerns
- ✅ Well-documented pattern

---

## Notes & Observations

### Performance Considerations
- Current macro may be doing redundant work in loops
- Lazy evaluation amortizes cost better
- Feature flag allows complete elimination if needed

### Type Safety Wins
- Compiler enforces correct usage
- Lifetime checking prevents dangling references
- Clear intent at call sites

### Future Improvements
- Could add `Cell<Option<...>>` cache if needed
- Could extend to other error context types
- Could add helper methods for common patterns

---

## Open Questions

1. **Should we track node_id in fast processor?**
   - Currently fast processor has node reference
   - Need to either pass node_id or extract from node
   - Decision: Extract node.id() at context creation

2. **Should decoder methods create context internally?**
   - Option A: Caller creates context, passes to decoder
   - Option B: Decoder creates context from parameters
   - Decision: Option A (current pattern, keeps decoder focused)

3. **What about errors in decorators?**
   - Decorators don't have operation index
   - Use OpErrorContext::new (node-level context)
   - Future: Could add decorator-specific context if needed

---

## References

- Current implementation: `processor/src/errors.rs` (err_ctx! macro)
- Fast processor: `processor/src/fast/*.rs`
- Slow processor: `processor/src/lib.rs`
- Decoder: `processor/src/decoder/mod.rs`
- Review document: `review.md`
