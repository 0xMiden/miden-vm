use std::{path::PathBuf, time::Instant};

use clap::Parser;
use miden_assembly::diagnostics::{Report, WrapErr};
use miden_processor::{DefaultHost, ExecutionOptions, ExecutionOptionsError};
use miden_stdlib::StdLibrary;
use miden_vm::{HashFunction, ProvingOptions, internal::InputFile};
use tracing::info_span;

use super::{
    data::{Libraries, OutputFile, ProofFile},
    utils::{get_masm_program, get_masp_program},
};

#[derive(Debug, Clone, Parser)]
#[command(about = "Prove a Miden program")]
pub struct ProveCmd {
    /// Path to a .masm assembly file or a .masp package file
    #[arg(value_parser)]
    program_file: PathBuf,

    /// Number of cycles the program is expected to consume
    #[arg(short = 'e', long = "exp-cycles", default_value = "64")]
    expected_cycles: u32,

    /// Path to input file
    #[arg(short = 'i', long = "input", value_parser)]
    input_file: Option<PathBuf>,

    /// Paths to .masl library files
    #[arg(short = 'l', long = "libraries", value_parser)]
    library_paths: Vec<PathBuf>,

    /// Maximum number of cycles a program is allowed to consume
    #[arg(short = 'm', long = "max-cycles", default_value_t = ExecutionOptions::MAX_CYCLES)]
    max_cycles: u32,

    /// Number of outputs
    #[arg(short = 'n', long = "num-outputs", default_value = "16")]
    num_outputs: usize,

    /// Path to output file
    #[arg(short = 'o', long = "output", value_parser)]
    output_file: Option<PathBuf>,

    /// Path to proof file
    #[arg(short = 'p', long = "proof", value_parser)]
    proof_file: Option<PathBuf>,

    /// Specifies the hash function to be used
    /// Valid options: blake3-192, blake3-256, rpo, rpx, poseidon2
    #[arg(long = "hasher", default_value = "blake3-192")]
    hasher: String,

    /// Security level for execution proofs generated by the VM
    #[arg(short = 's', long = "security", default_value = "96bits")]
    security: String,

    /// Enable tracing to monitor execution of the VM
    #[arg(short = 't', long = "trace")]
    trace: bool,

    /// Disable debug instructions (release mode)
    #[arg(long = "release")]
    release: bool,
}

impl ProveCmd {
    pub fn get_proof_options(&self) -> Result<ProvingOptions, ExecutionOptionsError> {
        let exec_options = ExecutionOptions::new(
            Some(self.max_cycles),
            self.expected_cycles,
            self.trace,
            !self.release,
        )?;

        let hash_fn = HashFunction::try_from(self.hasher.as_str())?;
        Ok(match self.security.as_str() {
            "96bits" => ProvingOptions::with_96_bit_security(hash_fn),
            "128bits" => ProvingOptions::with_128_bit_security(hash_fn),
            other => panic!("{other} is not a valid security setting"),
        }
        .with_execution_options(exec_options))
    }
    pub fn execute(&self) -> Result<(), Report> {
        println!("===============================================================================");
        println!("Prove program: {}", self.program_file.display());
        println!("-------------------------------------------------------------------------------");

        let (program, mut host, input_data) =
            info_span!("load_masm_data").in_scope(|| -> Result<_, Report> {
                // load libraries from files
                let libraries = info_span!("read_library_files")
                    .in_scope(|| Libraries::new(&self.library_paths))?;

                // determine file type based on extension
                let ext = self
                    .program_file
                    .extension()
                    .and_then(|s| s.to_str())
                    .unwrap_or("")
                    .to_lowercase();

                let input_data = info_span!("read_input_file")
                    .in_scope(|| InputFile::read(&self.input_file, &self.program_file))?;

                let host = DefaultHost::default().with_library(&StdLibrary::default())?;

                // Use a single match expression to load the program.
                let (program, host) =
                    info_span!("read_program_file", path = %self.program_file.display()).in_scope(
                        || -> Result<_, Report> {
                            match ext.as_str() {
                                "masp" => Ok((get_masp_program(&self.program_file)?, host)),
                                "masm" => {
                                    let (program, source_manager) = info_span!("compile_program")
                                        .in_scope(|| {
                                        get_masm_program(&self.program_file, &libraries, true)
                                    })?;
                                    Ok((program, host.with_source_manager(source_manager)))
                                },
                                _ => Err(Report::msg(
                                    "The provided file must have a .masm or .masp extension",
                                )),
                            }
                        },
                    )?;

                Ok((program, host, input_data))
            })?;

        let program_hash: [u8; 32] = program.hash().into();
        println!("Proving program with hash {}...", hex::encode(program_hash));
        let now = Instant::now();

        // fetch the stack and program inputs from the arguments
        let stack_inputs = input_data.parse_stack_inputs().map_err(Report::msg)?;
        let advice_inputs = input_data.parse_advice_inputs().map_err(Report::msg)?;

        let proving_options =
            self.get_proof_options().map_err(|err| Report::msg(format!("{err}")))?;

        // execute program and generate proof
        let (stack_outputs, proof) = info_span!("program proving")
            .in_scope(|| {
                miden_prover::prove(
                    &program,
                    stack_inputs,
                    advice_inputs,
                    &mut host,
                    proving_options,
                )
            })
            .wrap_err("Failed to prove program")?;

        println!("Program proved in {} ms", now.elapsed().as_millis());

        // write proof to file
        let default_proof_path = self.program_file.with_extension("proof");
        let proof_path = self.proof_file.as_ref().unwrap_or(&default_proof_path);
        info_span!("write_data_to_proof_file", path = %proof_path.display(), size = "251 KB")
            .in_scope(|| ProofFile::write(proof, &self.proof_file, &self.program_file))
            .map_err(Report::msg)?;

        // provide outputs
        if let Some(output_path) = &self.output_file {
            // write all outputs to specified file.
            OutputFile::write(&stack_outputs, output_path).map_err(Report::msg)?;
        } else {
            // if no output path was provided, get the stack outputs for printing to the screen.
            let stack = stack_outputs.stack_truncated(self.num_outputs).to_vec();

            // write all outputs to default location if none was provided
            let default_output_path = self.program_file.with_extension("outputs");
            info_span!("write_data_to_output_file", path = %default_output_path.display())
                .in_scope(|| OutputFile::write(&stack_outputs, &default_output_path))
                .map_err(Report::msg)?;

            // print stack outputs to screen.
            println!("Output: {stack:?}");
        }

        Ok(())
    }
}
