use miden::core::crypto::hashes::rpo256

# ===== MEMORY FUNCTIONS ==========================================================================

#! Copies `n` elements from `read_ptr` to `write_ptr`.
#!
#! If possible, this procedure will copy word-aligned words internally using `memcopy_words` 
#! procedure, decreasing the total number of cycles required to make a copy.
#!
#! It is advised to copy small chunks of memory (num_elements < 12) using `memcopy_elements` 
#! procedure instead, since it won't have a computation logic overhead.
#!
#! Inputs:  [n, read_ptr, write_ptr]
#! Outputs: []
#!
#! Where:
#! - n is the number of elements which should be copied.
#! - read_ptr is the memory pointer where the elements to copy are stored.
#! - write_ptr is the memory pointer where the elements will be copied.
#!
#! Panics if:
#! - read_ptr and write_ptr are not a u32 values.
#!
#! Total cycles:
#! - if read and write pointers are mutually word-unaligned: 27 + 14 * num_elements
#! - if `n` is less than 12 elements: 27 + 14 * num_elements
#! - if read and write pointers are mutually mutually word-aligned, it's equal to the sum of:
#!   - prologue: 19 cycles
#!   - prefix handling: 31 + 14 * num_prefix_elements, where num_prefix_elements is 
#!     the number of elements required to make the read (and write) pointer word-aligned
#!   - words handling: 15 + 16 * num_words
#!   - suffix handling: 9 + 14 * num_suffix_elements
#!     - in total: 74 + 14 * num_prefix_elements + 16 * num_words + 14 * num_suffix_elements
pub proc memcopy
    # check whether the difference between `read_ptr` and `write_ptr` is a multiple of 4, otherwise
    # these pointers will never be simultaneously word-alined, so we won't be able to use 
    # `memcopy_words`
    movdn.2 u32assert2.err="memory addresses must be valid u32 values" # 2 cycles
    # => [read_ptr, write_ptr, n]

    # Compute the remainders of dividing read_ptr and write_ptr by 4. Compare them to get the 
    # "alignment flag".
    dup.1 u32mod.4 dup.1 u32mod.4 eq # 11 cycles
    # => [alignment_flag, read_ptr, write_ptr, n]

    # if the number of elements to copy is small (less than 12), use only the `memcopy_elements`
    # procedure 
    dup.3 u32lt.12 or # 6 cycles
    # => [alignment_flag, read_ptr, write_ptr, n]

    if.true
        # if read pointer and write pointer are mutually word-aligned (i.e. 
        # (read_ptr - write_ptr) mod 4 = 0) we will be able to use `memcopy_words` in the cycle to
        # optimize the copy
        # => [read_ptr, write_ptr, n]

        ### "prefix" handling #####################################################################

        # copy `m` values, where `m` is the number of elements needed to make pointers word-aligned.
        # If `m` > `n` (meaning we don't have enough values to make pointers word-aligned), copy all
        # `n` available values.  

        # get the number of elements required to make read_ptr multiple of 4
        dup.2 exec.elements_to_next_multiple_of_4 # 20 cycles
        # => [m, read_ptr, write_ptr, n]

        # update the total number of values left to copy
        movup.3 dup.1 sub movdn.3 # 5 cycles
        # => [m, read_ptr, write_ptr, n - m]

        # copy the prefix elements
        exec.memcopy_elements_internal # 4 + 14 * num_prefix_elements cycles
        # => [0, read_ptr + m, write_ptr + m, n - m]

        # rearrange the stack for word copy
        drop movup.2 # 2 cycles
        # => [n - m, read_ptr + m, write_ptr + m]

        ### "words" handling ######################################################################

        # get the number of words we should handle and the number of remaining felt values
        u32divmod.4 # 2 cycles
        # => [values_left, num_words, read_ptr', write_ptr']

        # copy the words
        movdn.3 exec.memcopy_words_internal # 13 + 16 * num_words cycles
        # => [0, read_ptr'', write_ptr'', values_left]

        ### "suffix" handling #####################################################################

        # handle the remaining values
        drop movup.2 exec.memcopy_elements # 9 + 14 * num_suffix_elements cycles
        # => []
    else
        # if read pointer and write pointer are not word-aligned between each other, use 
        # `memcopy_elements` to copy values one-by-one
        # => [read_ptr, write_ptr, n]

        movup.2 exec.memcopy_elements # 8 + 14 * num_elements cycles
        # => []
    end
    # => []
end

#! Returns the number of elements required to make the provided memory pointer multiple of 4, or `n`
#! if it is smaller than the above described value.
#!
#! Inputs:  [n, ptr]
#! Outputs: [m, ptr]
#!
#! Where:
#! - n is the value that limits the result from below: the result cannot be less than it.
#! - ptr is the memory pointer relative to which the next multiple of 4 should be computed.
#! - m is the value equal to the number of elements required to make the provided pointer multiple
#!   of 4 or `n` if it is smaller than the above described value.
#!
#! Total cycles: 19 cycles
proc elements_to_next_multiple_of_4
    # get the quotient and the remainder of the division by 4
    dup.1 u32divmod.4 # 3 cycles
    # => [ptr mod 4, ptr / 4, n, ptr]

    # get the memory pointer which is next multiple of 4
    neq.0 add mul.4 # 5 cycles
    # => [ptr + to_next_4, n, ptr]

    # get the number of values required to make the pointer multiple of 4
    dup.2 sub # 3 cycles
    # => [to_next_4, n, ptr]

    # leave the smallest of the two values on the stack
    dup.1 dup.1 u32gte cdrop # 8 cycles
    # => [m, ptr]
end

#! Copies `n` words from `read_ptr` to `write_ptr`.
#!
#! `read_ptr` and `write_ptr` pointers *must be* word-aligned.
#!
#! Inputs:  [n, read_ptr, write_ptr]
#! Outputs: []
#!
#! Where:
#! - n is the number of words which should be copied.
#! - read_ptr is the memory pointer where the words to copy are stored.
#! - write_ptr is the memory pointer where the words will be copied.
#!
#! Total cycles: 15 + 16 * num_words
pub proc memcopy_words
    exec.memcopy_words_internal
    # => [n = 0, read_ptr + 4n, write_ptr + 4n]
    
    # clean the stack (3 cycles)
    drop drop drop
    # => []
end

#! Copies `n` words from `read_ptr` to `write_ptr`.
#!
#! `read_ptr` and `write_ptr` pointers *must be* word-aligned.
#!
#! Inputs:  [n, read_ptr, write_ptr]
#! Outputs: [n = 0, read_ptr + 4n, write_ptr + 4n]
#!
#! Where:
#! - n is the number of words which should be copied.
#! - read_ptr is the memory pointer where the words to copy are stored.
#! - write_ptr is the memory pointer where the words will be copied.
#!
#! Total cycles: 12 + 16 * num_words
proc memcopy_words_internal
    # The loop variable is changed with an add instead of sub because the former
    # uses one fewer cycle. So here the counter is negated. (1 cycles)
    # stack: [-n, read_ptr, write_ptr, ...]
    neg

    # Pad the stack because mem_load overwrites it (4 cycles)
    # stack: [0, 0, 0, 0, -n, read_ptr, write_ptr, ...]
    padw

    # check loop condition (3 cycles)
    # stack: [b, 0, 0, 0, 0, -n, read_ptr, write_ptr, ...]
    dup.4 neq.0

    # LOOP: [0, 0, 0, 0, -n, read_ptr, write_ptr, ...]
    # while(n != 0) (16 cycles)
    while.true
        # perform read (2 cycles)
        # stack: [a3, a2, a1, a0, -n, read_ptr, write_ptr, ...]
        dup.5 mem_loadw_be

        # perform write (2 cycles)
        # stack: [a3, a2, a1, a0, -n, read_ptr, write_ptr, ...]
        dup.6 mem_storew_be

        # note: the values of `A` are no longer necessary, use 0 to signal its a
        # padding
        # stack: [-n, read_ptr, write_ptr, x, 0, 0, 0, 0, ...]
        swapw

        # stack: [-n+1, read_ptr+4, write_ptr+4, x, 0, 0, 0, 0, ...]
        # update counters (9 cycles)
        add.1 movup.3 movup.3 add.4 movup.3 add.4 movup.3

        # stack: [0, 0, 0, 0, -n+1, read_ptr+4, write_ptr+4, x, ...]
        swapw

        dup.4 neq.0 # while(n != 0) (3 cycles)
    end

    # clean stack (4 cycles)
    dropw
    # => [-n+n = 0, read_ptr + 4n, write_ptr + 4n]
end

#! Copies `n` elements from `read_ptr` to `write_ptr`.
#!
#! It is advised to copy big chunks of memory (num_elements >= 12) using `memcopy` procedure 
#! instead, since it will handle the memory more efficiently.
#!
#! Inputs:  [n, read_ptr, write_ptr]
#! Outputs: []
#!
#! Where:
#! - n is the number of elements which should be copied.
#! - read_ptr is the memory pointer where the elements to copy are stored.
#! - write_ptr is the memory pointer where the elements will be copied.
#!
#! Total cycles: 7 + 14 * num_elements
pub proc memcopy_elements
    exec.memcopy_elements_internal
    # => [n = 0, read_ptr + n, write_ptr + n]

    # clean stack (3 cycles)
    drop drop drop
    # => []
end

#! Copies `n` elements from `read_ptr` to `write_ptr`.
#!
#! Inputs:  [n, read_ptr, write_ptr]
#! Outputs: [n = 0, read_ptr + n, write_ptr + n]
#!
#! Where:
#! - n is the number of elements which should be copied.
#! - read_ptr is the memory pointer where the elements to copy are stored.
#! - write_ptr is the memory pointer where the elements will be copied.
#!
#! Total cycles: 4 + 14 * num_elements
proc memcopy_elements_internal
    # The loop variable is changed with an `add` instead of `sub` because the former uses one fewer 
    # cycle. So here the counter is negated. (1 cycle)
    neg
    # => [-n, read_ptr, write_ptr]

    # check the loop condition (3 cycles)
    dup neq.0
    # => [loop_flag, -n, read_ptr, write_ptr]

    while.true
        # perform read (2 cycles)
        dup.1 mem_load
        # => [value_to_store, -n, read_ptr, write_ptr]

        # perform write (3 cycles)
        dup.3 mem_store
        # => [-n, read_ptr, write_ptr]

        # update the pointers and the counter (6 cycles)
        add.1 movup.2 add.1 movup.2 add.1 movup.2
        # => [-n+1, read_ptr+1, write_ptr+1]

        # check the loop condition (3 cycles)
        dup neq.0
        # => [loop_flag, -n+1, read_ptr+1, write_ptr+1]
    end
    # => [n = 0, read_ptr + n, write_ptr + n]
end

#! Copies an even number of words from the advice_stack to memory, computing their permutation.
#!
#! Inputs:  [C, B, A, write_ptr, end_ptr]
#! Outputs: [C, B, A, write_ptr]
#!
#! Where:
#! - A is the capacity of the RPO hasher state
#! - C and B are the rate portion of the RPO hasher state
#! - write_ptr is the memory pointer where the words will be copied.
#! - end_ptr is the memory pointer where the copying should end.
#!
#! Notice that the `end_ptr - write_ptr` value must be positive and a multiple of 8.
#!
#! Total cycles: 9 + 6 * num_word_pairs
pub proc pipe_double_words_to_memory
  dup.13 dup.13 neq # (4 cycles)

  # loop until write_ptr reaches end_ptr (6 cycles per iteration + 1)
  # LOOP: [b, C, B, A, write_ptr, end_ptr, ...]
  while.true
    adv_pipe exec.rpo256::permute # (2 cycles)
    # => [C', B', A', write_ptr', end_ptr, ...]

    dup.13 dup.13 neq # (4 cycles)
    # LOOP: [b, C', B', A', write_ptr', end_ptr, ...]
  end

  movup.13 drop # (5 cycles)
  # [C', B', A', write_ptr', ...]
end

#! Copies an arbitrary number of words from the advice stack to memory, computing their permutation.
#!
#! Inputs:  [num_words, write_ptr]
#! Outputs: [C, B, A, write_ptr']
#!
#! Where:
#! - num_words is the number of words which will be copied to the memory.
#! - write_ptr is the memory pointer where the words will be copied.
#! - write_ptr' is the memory pointer to the end of the copied words.
#! - A is the capacity of the RPO hasher state
#! - C and B are the rate portion of the RPO hasher state
#!
#! Total cycles:
#!  - Even `num_words`: 43 + 9 * num_words / 2
#!  - Odd `num_words`: 60 + 9 * round_down(num_words / 2)
pub proc pipe_words_to_memory
    # check if there is an odd number of words (6 cycles)
    dup is_odd
    # => [is_odd, num_words, write_ptr, ...]

    # copy is_odd, it defines if last word requires padding (2 cycles)
    dup movdn.3
    # => [is_odd, num_words, write_ptr, needs_padding, ...]

    # compute `end_ptr` with an even number of words (7 cycles)
    sub mul.4 dup.1 add swap
    # => [write_ptr, end_ptr, needs_padding, ...]

    # Prepare the capacity word. We use the padding rule which sets the first capacity
    # element to `len % 8` where `len` is the length of the hashed sequence. Since `len % 8`
    # is either equal to 0 or 4,  this is determined by the `needs_padding` flag multiplied
    # by 4. (6 cycles)
    dup.2 mul.4 push.0.0.0
    # => [A, write_ptr, end_ptr, needs_padding, ...]

    # set initial hasher state (8 cycles)
    padw padw
    # => [C, B, A, write_ptr, end_ptr, needs_padding, ...]

    # (9 + 6 * num_words cycles)
    exec.pipe_double_words_to_memory
    # => [C, B, A, write_ptr, needs_padding, ...]

    # (4 cycles)
    movup.13
    # => [needs_padding, C, B, A, write_ptr, ...]

    # if(needs_padding) (17 cycles)
    if.true
        # Rescue Prime Optimized uses overwrite mode, drop `C`. (4 cycles)
        dropw
        # => [B, A, write_ptr, ...]

        # Overwrite the `B` with the new data (1 cycles)
        adv_loadw
        # => [B', A, write_ptr, ...]

        # - get the memory address that B' should be saved to
        # - update the write_ptr to point to the next address (4 cycles)
        movup.8 dup.0 add.4 movdn.5
        # => [write_ptr, B', write_ptr+4, A, ...]

        # save data to memory (1 cycles)
        mem_storew_be
        # => [B', write_ptr+1, A, ...]

        # Fix write_ptr position (2 cycles)
        movup.4 movdn.8
        # => [B', A, write_ptr+1, ...]

        # Push padding word (4 cycles)
        padw
        # => [C, B', A, write_ptr+1, ...]

        # Run RPO permutation (1 cycle)
        exec.rpo256::permute
        # => [C', B', A', write_ptr+1, ...]
    end
end

#! Moves an arbitrary number of words from the advice stack to memory and asserts it matches the
#! commitment.
#!
#! Inputs:  [num_words, write_ptr, COMMITMENT]
#! Outputs: [write_ptr']
#!
#! Where:
#! - num_words is the number of words which will be copied to the memory.
#! - write_ptr is the memory pointer where the words will be copied.
#! - write_ptr' is the memory pointer to the end of the copied words.
#! - COMMITMENT is the commitment that the one calculated during this procedure will be compared
#!   with.
#!
#! Total cycles:
#!  - Even `num_words`: 62 + 9 * num_words / 2
#!  - Odd `num_words`: 79 + 9 * round_down(num_words / 2)
pub proc pipe_preimage_to_memory
    # Copies the advice stack data to memory
    exec.pipe_words_to_memory
    # => [C, B, A, write_ptr', COMMITMENT, ...]

    # Leave only the digest on the stack
    exec.rpo256::squeeze_digest
    # => [B, write_ptr', COMMITMENT, ...]

    # Save the write_ptr (2 cycles)
    movup.4 movdn.8
    # => [HASH, COMMITMENT, write_ptr', ...]

    # Check the COMMITMENT (10 cycles)
    assert_eqw
    # => [write_ptr', ...]
end

#! Moves an even number of words from the advice stack to memory and asserts that their sequential
#! hash matches a given commitment.
#!
#! Inputs:  [num_words, write_ptr, COMMITMENT]
#! Outputs: [write_ptr']
#!
#! Where:
#! - num_words is the number of words which will be copied to the memory.
#! - write_ptr is the memory pointer where the words will be copied.
#! - write_ptr' is the memory pointer to the end of the copied words.
#! - COMMITMENT is the commitment that the one calculated during this procedure will be compared
#!   with.
#!
#! Total cycles: 56 + 3 * num_words / 2
pub proc pipe_double_words_preimage_to_memory
    # Assert precondition (8 cycles).
    dup is_odd assertz.err="pipe_double_words_preimage_to_memory: num_words must be even"
    # => [num_words, write_ptr, COMMITMENT, ...]

    # Compute and move end_ptr (5 cycles)
    mul.4 dup.1 add swap
    # => [write_ptr, end_ptr, COMMITMENT, ...]

    # Setup the initial hasher state, which starts with a capacity word `A`.
    # For us, the capacity word is entirely empty.
    # (12 cycles).
    exec.rpo256::init_no_padding
    # => [C, B, A, write_ptr, end_ptr, COMMITMENT, ...]

    # (9 + 3 * num_words cycles)
    # (e.g., 25 cycles for 4 words)
    exec.pipe_double_words_to_memory
    # => [C, B, A, write_ptr', COMMITMENT, ...]

    # Leave just the digest on the stack (9 cycles).
    exec.rpo256::squeeze_digest
    # => [B, write_ptr', COMMITMENT, ...]

    # Move write_ptr out of the way so we can assert the commitment (2 cycles).
    movup.4 movdn.8

    # Assert the commitment (11 cycles).
    assert_eqw.err="pipe_double_words_preimage_to_memory: COMMITMENT does not match"
end
