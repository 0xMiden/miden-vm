# Cryptographic hashes
Namespace `std::crypto::hashes` contains modules for commonly used cryptographic hash functions.

## BLAKE3
Module `std::crypto::hashes::blake3` contains procedures for computing hashes using [BLAKE3](https://blake3.io/) hash function. The input and output elements are assumed to contain one 32-bit value per element.

| Procedure   | Description                                                                                                                                                                                                                 |
| ----------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| hash_1to1   | Computes BLAKE3 1-to-1 hash.<br/><br/>Input: 32-bytes stored in the first 8 elements of the stack (32 bits per element).<br /> <br/>Output: A 32-byte digest stored in the first 8 elements of stack (32 bits per element). |
| hash_2to1   | Computes BLAKE3 2-to-1 hash.<br/><br/>Input: 64-bytes stored in the first 16 elements of the stack (32 bits per element).<br /> <br/>Output: A 32-byte digest stored in the first 8 elements of stack (32 bits per element) |

## Keccak256
Module `std::crypto::hashes::keccak256` contains procedures for computing hashes using [Keccak256](https://keccak.team/keccak.html) hash function. 

All 256-bit values (inputs and outputs) are represented as two 128-bit words: `[VALUE_LO, VALUE_HI]`. Each word contains 4 field elements, and each field element encodes a u32 value (4 bytes packed in little-endian order). 

Stack representation: `[VALUE_LO, VALUE_HI] = [[v_3, v_2, v_1, v_0], [v_7, v_6, v_5, v_4]]` where `v_i` represents the i-th u32 value (with bytes in little-endian order). This reversed word ordering on the stack ensures efficient memory operations - words can be written directly to memory without reordering.

Internally, the result of the computation is provided non-deterministically. The VM records this computation so that it can be verified externally, either by recursively verifying a STARK of these computations, or by natively re-computing the results when verifying the proof of this program.

| Procedure   | Description                                                                                                                                                                                                                                                                                                                                                                                                                         |
|-------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| hash_memory | Computes Keccak256 hash of data stored in memory.<br /><br />Input: `[ptr, len_bytes, ...]`<br />Output: `[KECCAK_LO, KECCAK_HI, ...]`<br /><br />Where:<br />- `ptr`: word-aligned memory address containing `⌈len_bytes/4⌉` field elements<br />- `len_bytes`: number of bytes to hash<br /><br />Memory layout: Each field element packs 4 bytes. If `len_bytes` is not divisible by 4, the last element's upper bytes are zero. |
| hash_1to1   | Computes Keccak256 hash of a single 256-bit input.<br /><br />Input: `[ptr_tmp, INPUT_LO, INPUT_HI, ...]`<br />Output: `[KECCAK_LO, KECCAK_HI, ...]`<br /><br />Computes: `Keccak256(INPUT_LO \|\| INPUT_HI)`<br /><br />Where `ptr_tmp` is a temporary memory location (uses 8 words).                                                                                                                                             |
| hash_2to1   | Merges two 256-bit digests via Keccak256 hash.<br /><br />Input: `[ptr_tmp, INPUT_L_LO, INPUT_L_HI, INPUT_R_LO, INPUT_R_HI, ...]`<br />Output: `[KECCAK_LO, KECCAK_HI, ...]`<br /><br />Computes: `Keccak256(INPUT_L_LO \|\| INPUT_L_HI \|\| INPUT_R_LO \|\| INPUT_R_HI)`<br /><br />Where `ptr_tmp` is a temporary memory location (uses 16 words).                                                                                |

Note: The old native implementations still exist in the module `std::crypto::hashes::keccak256_deprecated` but are now deprecated.

## SHA256
Module `std::crypto::hashes::sha256` contains procedures for computing hashes using [SHA256](https://en.wikipedia.org/wiki/SHA-2) hash function. The input and output elements are assumed to contain one 32-bit value per element.

| Procedure   | Description                                                                                                                                                                                                                  |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| hash_1to1   | Computes SHA256 1-to-1 hash.<br/><br/>Input: 32-bytes stored in the first 8 elements of the stack (32 bits per element).<br /> <br/>Output: A 32-byte digest stored in the first 8 elements of stack (32 bits per element).  |
| hash_2to1   | Computes SHA256 2-to-1 hash.<br/><br/>Input: 64-bytes stored in the first 16 elements of the stack (32 bits per element).<br /> <br/>Output: A 32-byte digest stored in the first 8 elements of stack (32 bits per element). |

## RPO256
Module `std::crypto::hashes::rpo` contains procedures for computing and managing hashes using [Rescue Prime Optimized](https://docs.rs/miden-crypto/latest/miden_crypto/hash/rpo/struct.Rpo256.html) hash function.

| Procedure                       | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|---------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| squeeze_digest                  | Given the hasher state, returns the hash output.<br /><br />Input: `[C, B, A, ...]`<br />Output: `[HASH, ...]`<br />where: For the native RPO hasher resulting `HASH` is `B`.<br />Cycles: 9<br />                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| copy_digest                     | Copies the result of hash permutation to the top of the stack.<br /><br />It is expected to have the hasher state at the top of the stack at the beginning of the procedure execution.<br /><br />Input: `[C, B, A, ...]`<br />Output: `[B, C, B, A, ...]`<br /><br />Where:<br />- `A` is the capacity word that will be used by the hashing function.<br />- `B` is the hash output.<br />- `C` is the rate word that will be used by the hashing function.<br /><br />Cycles: 4<br />                                                                                                                                                                                                             |
| hash_memory_double_words        | Hashes the pairs of words in the memory from `start_addr` to `end_addr`.<br /><br />This procedure requires that `end_addr = start_addr + 8n` where $n = \{0, 1, 2 ...\}$ (i.e. we must always hash some number of double words), otherwise the procedure will enter an infinite loop.<br /><br />Input: `[start_addr, end_addr, ...]`<br />Output: `[HASH, ...]`<br /><br />Where:<br />- `HASH` is the cumulative hash of the provided memory values.<br /><br />Cycles: 37 + 3 * words, where `words` is the `start_addr - end_addr`<br />                                                                                                                                                        |
| absorb_double_words_from_memory | Hashes the memory `start_addr` to `end_addr` given an RPO state specified by 3 words.<br /><br />This requires that `end_addr=start_addr + 2n + 1`, otherwise the procedure will enter an infinite<br />loop. `end_addr` is not inclusive.<br /><br />Stack transition:<br />Input: `[C, B, A, start_addr, end_addr, ...]`<br />Output: `[C', B', A', end_addr, end_addr ...]`<br />Cycles: 4 + 3 * words, where `words` is the `start_addr - end_addr - 1`<br /><br />Where `A` is the capacity word that will be used by the hashing function, and `B'` the hash output.<br />                                                                                                                     |
| hash_memory_words               | Hashes the memory `start_addr` to `end_addr`, handles odd number of elements.<br /><br />Requires `start_addr < end_addr`, `end_addr` is not inclusive.<br /><br />Stack transition:<br />Input: `[start_addr, end_addr, ...]`<br />Output: `[H, ...]`<br />Cycles:<br />even words: 49 cycles + 3 * words<br />odd words: 61 cycles + 3 * words<br />                                                                                                                                                                                                                                                                                                                                               |
| prepare_hasher_state            | Computes the hasher state required for the `hash_memory_with_state` procedure.<br /><br />Depending on the provided `pad_inputs_flag`, this procedure instantiates the hasher state using different values for capacity element:<br />- If `pad_inputs_flag` equals $1$ the capacity element will be assigned to $0$. This will essentially "pad" the hashing values with zeroes to the next multiple of $8$.<br />- If `pad_inputs_flag` equals $0$ the capacity element will be assigned to the remainder of the division of elements number by $8$ ($num\_elements\%8$).<br /><br />Inputs: `[ptr, num_elements, pad_inputs_flag]`<br />Outputs: `[C, B, A, ptr, end_pairs_addr, num_elements%8]` |
| hash_memory_with_state          | Computes hash of `Felt` values starting at the specified memory address using the provided hasher state.<br /><br />This procedure divides the hashing process into two parts: hashing pairs of words using `absorb_double_words_from_memory` procedure and hashing the remaining values using the `hperm` instruction.<br /><br />Inputs: `[C, B, A, ptr, end_pairs_addr, num_elements%8]`<br />Outputs: `[HASH]`                                                                                                                                                                                                                                                                                   
| hash_memory                     | Computes hash of `Felt` values starting at the specified memory address.<br /><br />This procedure divides the hashing process into two parts: hashing pairs of words using<br />`absorb_double_words_from_memory` procedure and hashing the remaining values using the `hperm`<br />instruction.<br /><br />Inputs: `[ptr, num_elements]`<br />Outputs: [`HASH]`<br />Cycles:<br />- If number of elements divides by $8$: 47 cycles + 3 * words<br />- Else: 180 cycles + 3 * words<br /><br />Panics if number of inputs equals $0$.<br />                                                                                                                                                        |
